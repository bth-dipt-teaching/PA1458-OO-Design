#+Title: Software Design Courses
#+Subtitle: PA1415, PA1435
#+Author: Mikael Svahnberg
#+Email: Mikael.Svahnberg@bth.se
#+Date: 2016-08-18
#+EPRESENT_FRAME_LEVEL: 1
#+OPTIONS: email:t <:t todo:t f:t ':t toc:t
#+STARTUP: beamer
#+TODO: TODO(t) | DONE(d!) WAIT(w!)


#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org/org.css" />
#+HTML: <br/>

#+LATEX_CLASS_OPTIONS: [10pt,t,a4paper]
#+BEAMER_THEME: BTH_msv

#+MACRO: pa1415 PA1415 Software Design
#+MACRO: pa1435 PA1435 Object Oriented Design
#+MACRO: larman C. Larman, /Applying UML and Patterns/, 3rd Edition
#+MACRO: commit Commit and push this document to your project repository.
#+MACRO: submit Submit the assignment as one or several PDFs on It's Learning.
#+MACRO: tasks *Tasks:*
#+MACRO: docStructure *Document Structure:*
#+MACRO: condSat *Conditions of Satisfaction:*
#+MACRO: assignment The title for this Assignment Document is: /$1 for System <system name>/



* Sprint Structure						   :noexport:
** About This Sprint
** User Stories covered in this Sprint
** Introduction
** Learning Material
*** Book Chapters
*** Screencasts
*** Lectures
*** Articles
*** Further Reading
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - 

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment Submission
*** Update Course Backlog

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* Sprint Map							   :noexport:
 | Topic                    | Sprint                                 | Delivery     | PA1415 | PA1435 | PA1443 |
 |                          |                                        |              | 7.5 hp | 6 hp   | 5 hp   |
 |--------------------------+----------------------------------------+--------------+--------+--------+--------|
 | Course Intro             | Sprint 0: Course Introduction          |              | Yes    | Yes    | Yes    |
 | Software Development     | Development Methodologies              |              | Yes    |        |        |
 |                          | Requirements Engineering               |              | Yes    |        |        |
 | Object Oriented Analysis | Use Cases and Use Case Diagrams        | Submission 1 | Yes    | Yes    | Yes    |
 |                          | Concepts and Events                    |              | Yes    | Yes    | Yes    |
 |                          | State Diagram                          |              | Yes    |        |        |
 | Quality Assurance        | Testing                                |              | Yes    | Yes    |        |
 | Object Oriented Design   | Good Interactions                      |              | Yes    | Yes    | Yes    |
 |                          | Interactions and Structure             | Submission 2 | Yes    | Yes    | Yes    |
 |                          | Design Patterns                        |              | Yes    | Yes    | Yes    |
 | Software Architecture    | Introduction to Software Architectures |              |        |        | Yes    |
 |                          | Software Architecture Patterns         |              | Yes    | Yes    | Yes    |
 | From Design to Code      | Designing the User Interface           |              | Yes    |        |        |
 |                          | Implementation                         | Submission 3 | Yes    | Yes    |        |
 | Course Wrap-up           | Preparing for Exam                     |              | Yes    | Yes    | Yes    |
 |                          | Sprint 99: Finalising the Course       |              | Yes    | Yes    | Yes    |
 |--------------------------+----------------------------------------+--------------+--------+--------+--------|

#+BEGIN_SRC dot :file ./images/FSprintMap.svg
digraph {
rankdir=TB;
splines=true;
node [style=filled,fillcolor="/greens3/2"];

s0 [label="Sprint 0: Course Introduction"]
devmet [label="Development Methodologies"]
re [label="Requirements Engineering"]
ucd [label="Use Cases and Use Case Diagrams"]
ce [label="Concepts and Events"]
tst [label="Testing"]
sd [label="State Diagram"]
goodint [label="Good Interactions"]
interact [label="Interactions and Structure"]
dp [label="Design Patterns"]
ui [label="Designing the User Interface"]
sa [label="Introduction to Software Architectures"]
sap [label="Software Architecture Patterns"]
impl [label="Implementation"]
exam [label="Preparing for Exam"]
s99 [label="Sprint 99: Course Wrapup"]


subgraph cluster_intro {
label="Course Introduction";
s0
}

subgraph cluster_development {
label="Software Development";
devmet -> re
}

subgraph cluster_ooa {
label="Object Oriented Analysis";
ucd -> ce -> sd
}

subgraph cluster_qa {
label="Quality Assurance";
tst
}

subgraph cluster_ood {
label="Object Oriented Design";
goodint -> interact -> dp
}


subgraph cluster_sa {
label="Software Architecture";
sa -> sap
}

subgraph cluster_impl {
label="From Design to Code";
ui -> impl
}

subgraph cluster_wrapup {
label="Course Wrap-up"
exam -> s99
}

subgraph PA1415 {
node [style=filled,fillcolor="/greens3/2"];
edge [label="PA1415", color="green", fontcolor="green"]
s0 -> devmet
re -> ucd
sd -> tst
tst-> goodint
dp -> sa
sap -> ui
impl -> exam
}

  
subgraph PA1435 {
node [style=filled,fillcolor="/blues3/2"];
edge [label="PA1435", color="blue", fontcolor="blue"]
s0 -> ucd 
sd -> tst -> goodint
dp -> sa
sap -> ui
impl -> exam
}
 
subgraph PA1443 {
node [style=filled,fillcolor="/bupu3/2"];
edge [label="PA1443", color="blueviolet", fontcolor="blueviolet"]
s0 -> ucd
ce -> goodint
dp -> impl
impl -> exam
}

}
#+END_SRC

* Sprint 0: Course Introduction					   :noexport:
** About This Sprint
   This sprint introduces the course and the course structure.
** User Stories covered in this Sprint
   - As a student I want to pass this course.
   - As a student I want to understand how this course is structured so that I can quickly find the information I need to learn the subject.
   - As a student I want to know why this topic is important so that I can be properly motivated.
** Introduction
   Welcome to the course!

   Of course you want to pass the course, and I want you to too. This document is intended to give an overview of how the course is structured, and give you a "map" of sorts to the rest of the course material. It is my hope that this will help you find the material you want easily so that you can focus on learning each part of the course.

   The course is divided into a series of /Sprints/, that is, short iterations that focus on a small number of issues per sprint. I have borrowed this term from an agile development methodology called [[https://en.wikipedia.org/wiki/Scrum_(software_development)][Scrum]], which is something you will learn more about in this course and are sure to encounter in your future career as well.

   Speaking of agile, there are a few other things I have borrowed from there as well. The /User Stories/ that each sprint document starts with is one such thing. A user story is a sort of stylised requirement, and I use them to set you into the right frame of mind for each sprint. As you notice, the user story contains information about which /perspective/ you should have, the /goals/ you should achieve, and a brief explanation of /why/ this goal is important.

   Related to this is the /Sprint Acceptance Tests/ that you find at the bottom of each sprint document. These acceptance tests tell you how we plan on ensuring that the goal of the sprint has been reached.

   The bulk of the sprint consists of /Learning Material/, and /Experiential Learning/. Learning material are book chapters, videos, blog posts, etc. that you can use to learn more about the topic in the sprint. Experiential Learning (which is not a good name, but I can't think of any better) consists of different activities you should /do/ as part of the sprint. Some of these activities are just practice activities. Others are activities that will help you organise the material better. Others again are those activities that we (as teachers) would like to look at to assess your progress. Let me repeat this:

#+BEGIN_note
Experiential Learning are things you are supposed to /do/, and includes:
 - Things you do for practice
 - Things you do to organise the material
 - Things you submit as assignments to the teachers for marking
#+END_note

   You will note that in some sprints you are expected to produce an assignment document and commit/push it to your project repository without actually submitting it for marking. These documents are intermediate steps, and you will be using the knowledge gained from them when creating the documents that /will/ be marked. In some cases, we will go back to them when marking a subsequent assignment to see that you have not missed anything. In other cases, we will go back to them to be able to follow your reasoning in your submission. I try to ensure that the overhead of creating these documents (as opposed to just doing the analysis/design work) is minimal. *Please* do not skip these documents just because they are not submitted; they are a helpful and sometimes necessary tool to be able to continue.

   Some activities are started during this sprint, and then I ask you to revisit them during every subsequent sprint. The idea with these activities are to help you structure your learning, and give you a means to follow your own progress.

   So, without further ado, let's get started with the learning material. /Good Luck!/
** Learning Material
*** Course Structure
    The course has an online presence as well as a campus existense.

    The online presence consists of these pages, and is organised as a set of sprints, where each sprint focus on a small topic and a few user stories. In each sprint there are things to read and watch, as well as activities to do. The result of some of those activities will be submitted as assignments for marking.

    The campus existense consists of lectures (that I try to run as seminars) and exercises. My idea is that you first study the online material, and then we can have lively discussions during the lectures/seminars. Basically, you go through the design notation and a basic understanding of the topic with the online material and then we discuss together what makes a /good/ design.

    The exercises are done in smaller groups and are more geared towards your specific assignments. Here, the idea is to go through what you are expected to do in the assignments and go through examples of this.

    There are also feedback meetings planned where you get feedback on the assignments that you submitted so that you may improve them.
*** Course Goals
    Below, the course goals for the two courses {{{pa1415}}} and {{{pa1435}}} are listed. As you notice, the PA1435 version is of a newer format, but also contains less focus on requirements engineering, project management, and testing activities. This will of course to some extent influence what you are expected to do and deliver, but will only have a limited effect on the lecture series since the topics are still quite intertwined.

| {{{pa1435}}}                                                                                    | {{{pa1415}}}                                                                                                                       |
|-------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------|
|                                                                                                 | Efter genomförd kurs skall studenten:                                                                                              |
|                                                                                                 | - på en grundläggande nivå i grupp kunna ta fram krav på en programvara och uttrycka dem i en kravspecifikation                    |
|                                                                                                 | - i grupp producera en översiktlig utvecklingsprojektplan baserat på en kravspecifikation                                          |
| *Kunskap och förståelse* Efter genomförd kurs ska studenten:                                    |                                                                                                                                    |
| - kunna visa förståelse för grundläggande principer i objektorienterad programvaruutveckling.   |                                                                                                                                    |
| - kunna visa förståelse för UML som modelleringsspråk.                                          |                                                                                                                                    |
| - kunna visa kunskap om grundläggande designprinciper.                                          |                                                                                                                                    |
| - kunna visa kunskap om grundläggande designmönster.                                            |                                                                                                                                    |
|                                                                                                 |                                                                                                                                    |
| *Färdigheter och förmåga* Efter genomförd kurs ska studenten:                                   |                                                                                                                                    |
| - kunna uttrycka strukturen och beteendet hos ett system i termer av objektorienterade koncept. | - i grupp kunna skapa en detaljerad objektorienterad design för ett mjukvaruprogram                                                |
| - kunna korrekt använda UML för att uttrycka struktur och beteende hos ett system.              | - skapa och analysera objektorienterade artefakter uttryckta i UML                                                                 |
| - kunna korrekt transformera en objektorienterad design till källkod.                           | - i grupp kunna implementera ett mjukvaruprogram inom rimlig tid, baserat på en kravspecifikation och en objektorienterad design   |
| - kunna tillämpa designprinciper och designmönster i allmänhet och inom en särskild domän.      | - kunna motivera och använda designmönster i utvecklingen av mjukvarusystem                                                        |
|                                                                                                 |                                                                                                                                    |
|                                                                                                 | - på en grundläggande nivå i grupp kunna planera och genomföra testning av producerad programvara, baserat på en kravspecifikation |
|                                                                                                 |                                                                                                                                    |
| *Värderingsförmåga och förhållningssätt* Efter genomförd kurs ska studenten:                    |                                                                                                                                    |
| - kunna analysera källkod för eventuella förbättringar.                                         |                                                                                                                                    |
| - kunna analysera och kritiskt diskutera en design för eventuella förbättringar.                |                                                                                                                                    |
|-------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------|
*** TODO Why is this course Important?				   :noexport:
*** TODO Course Roadmap						   :noexport:
*** What should I do with the Sprint Test Plan?
    The Sprint Test Plan is a way to get an overview of your expectations in the course, in relation to the provided material, and align it with my expectations as course responsible and examiner. In some sense, it is also your strategy for learning the topics. I will not mark your Sprint Test Plan -- you are creating and maintaining this for your own sake.

    The Sprint Test Plan will be revisited during every sprint, so that you have an updated record of what you need to learn to pass the course.

    I am loosely basing my suggestion for the Sprint Test Plan document on the IEEE 829-2008 standard. Feel free to add other information to it if you think it is relevant.
*** What is this "Course Backlog" thing?
    As you study, I expect that you will get more questions, or additional information sources (blog pages etc.) that you would like to read, and I hope you will also get ideas for places where you would like to test what you have learnt. Put these into a course backlog document (it will help if you put them in a roughly prioritised order), and then spend time during each sprint to resolve your backlog items.

    At the end of the course, it is my hope that your backlog contains pointers to yourself with how you should go forward with the knowledge gained. For example, how can you use what you have learnt in upcoming courses? Are there any particularly interesting things you have found that you would like to study more? Are there any courses you are interested in taking as a consequence of taking this course? Are there any courses you would like to /replace/ in your education as a consequence of taking this course? Are there any ideas you can use for your bachelor or master's thesis?

    The course backlog is revisited in every sprint. I will not mark it; you create it for your own benefit.
** Experiential Learning
*** Create Infrastructure
    *Introduction.* In your future career you are going to use configuration management systems such as [[http://svnbook.red-bean.com/][Subversion]] or [[https://git-scm.com/][Git]], so why not start already now? This gives you an easy way to share work between your colleagues, and opens up for me to review your work even before you have submitted it.

    If you also write your documents in for example [[https://daringfireball.net/projects/markdown/][Markdown]], they are formatted for you by github. Myself, I am partial to [[http://orgmode.org/][Org-mode]] and [[https://www.gnu.org/software/emacs/][Emacs]], especially because of the nice integration with [[http://plantuml.com/][PlantUML]] for generating design diagrams and the excellent export facilities. Org-mode is also nicely supported by github.

    *Things to do:*
    - [[https://education.github.com/][Create an account on Github]] (or use your existing one)
    - Create a Project for the course ~OOD-<course code>-<your name>~
    - Invite me ([[https://github.com/mickesv][mickesv]]) to the project
    - checkout your project and create a directory structure:
      - ~/Assignments/~
      - ~/SprintTestPlan/~
      - ~/CourseBacklog/~
    - add a file to each directory, otherwise you will not be able to commit them. For example, add an empty ~.gitignore~ file to each directory.
    - commit and push
*** Sprint Test Plan
    Create a document with the following sections:
    - /Test Items./ These are the assignments you are expected to submit for marking. It will probably be a good idea if you are able to tag them with the corresponding sprint, so that you can easily find them.
    - /Features to be Tested./ These are the user stories at the top of every sprint. Describe each of these features in terms of the object oriented modelling concepts or software development concepts that you need to master before you can satisfy the user story.
    - /Approach./ Here, you will describe /your/ strategy for ensuring that you have learnt the material in the sprint. How do you ensure that you are confident that the assignments you submit will pass with the grade you are aiming for?
    - /Item Pass/Fail Criteria./ What do you have to be able to show to yourself to ensure that you have learnt the material in the sprint? What do you have to show in the submitted assignments?
    - /Schedule./ When do you plan on passing each test item and feature?
    - /Planning Risks and Contingencies./ Are there any foreseeable risks that may limit your ability to pass the course on time? What is your contingency plan?
    - /Glossary./ In this section you will build up a glossary of important terms in the course that you can use when studying. I suggest you collaborate with the rest of the class in the course discussion forum (on It's Learning) and post your terms and definitions there so that they can be discussed.

    In this sprint, the following items can be added already (you may think of more items, please add them too):

    - Test Items
      - Exam [[https://studentportal.bth.se/web/studentportal.nsf/web.xsp/tentamen_under_kommande_veckor][Check Date]]
      - Exam Re-sit [[https://studentportal.bth.se/web/studentportal.nsf/web.xsp/tentamen_under_kommande_veckor][Check Date]]
    - Approach
      - Outline your plan for reading the book and doing the sprints in time to be ready for the exam.
      - Describe your plan for joining a group of students (for the group assignments, and for study groups) with the same ambition level as you yourself have.
    - Item Pass/Fail Criteria
      - Outline your ambition level; what grade are you aiming for?
    - Schedule
      - Dates for assignment submissions are available on It's Learning. Copy them here.
      - Add the exam dates.
    - Planning Risks and Contingencies
      - Do you plan on taking any vacations (e.g., skiing trip, easter, ascension day, etc.)? When will you study more to compensate for this? Are your team-mates informed and ok with that you contribute less during these vacations?
      - What is the expected workload for the courses you may be taking in parallel? Does your plan for /this/ course accomodate your plans for the other courses?
      - Do you have time available if you are asked to complete your submitted assignments with more information?
      - Are there any other risks you see at this stage?
    - Glossary
      - Scrum
      - Sprint
      - User Story
      - Test Plan
*** Buy Course Books
*Main Literature (Both Courses)*
#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/ILarman.jpg]]

C. Larman, /Applying UML and Patterns/, Prentice Hall, 3rd Edition.

This book is a complete guide to all things UML, with plenty of examples and detailed descriptions of all diagrams and how to think when using them. The reading instructions in each sprint are based on the 3rd edition, but I recommend you to try to find an older edition since they are essentially the same but with less text.
#+HTML: <br/><br/><br/><br/><br/><br/>

*Reference Literature (PA1415)*
#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/ISommerville.jpg]]

I. Sommerville, /Software Engineering/, Pearson, 8th edition, 2006.

There is also a 9th and a 10th edition (and, of course, the preceeding editions). It does not really matter which one you get. You will use this book as a reference to look up e.g. how a GANTT chart works in case the internet is down.
#+HTML: <br/><br/><br/><br/><br/><br/>

*Reference Literature (PA1435)*
#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/IGamma.jpg]]

Gamma, Helm, Johnson, Vlissides, /Design Patterns, Elements of Reusable Object-Oriented Software/, Addison-Wesley Professional.

This book, also called the Gang of Four book is /the/ reference work when it comes to design patterns. You will be using this book a lot in your future career. If you want to save some money, the most common design patterns are also covered in C. Larman (and these are the ones we will be focusing on in these courses).

/Note to PA1415:/ I warmly recommend that you too get this book even if it is not oficially part of "your" course plan.
#+HTML: <br/><br/><br/><br/><br/><br/>

#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/INystrom.jpg]]

R. Nystrom, /Game Programming Patterns/, Genever Benning, 2014.

Also Available at: http://gameprogrammingpatterns.com/contents.html
#+HTML: <br/><br/><br/><br/><br/><br/>

#+HTML: &nbsp;
*** Form Groups
    We expect the assignments to be done in /groups of three to five people/. Use the following (in this order) to find and/or form a group:

    1. Your friends
    2. It's Learning
    3. First Classroom Lecture
    4. Course Teacher

    Decide in your group how to deal with configuration management (e.g., who creates the git repository (remember to share it with me)), and decide on a schedule for when and how often you plan on working. If you know that you need to be out of touch for some reason (e.g. spring break), agree within the team how to handle this.        
*** Update Course Backlog
    Where do you go from here? Are there any questions already now that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have bought the literature you want/need for the course.
   - You have joined a group.
   - You have created a github account, created a project repository, and committed/pushed the directory structure.
   - You have read the Learning Materials

   You may also have
   - Created a Sprint Test Plan
   - Created a Course Backlog
* Sprint: Development Methodologies				   :noexport:
** About This Sprint
   This sprint introduces different development methodologies. It is primarily targeted at {{{pa1415}}}.
** User Stories covered in this Sprint
   - As a project manager I want to plan the project so that I can make the best use of my resources.
   - As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.
   - As a project manager I want to track the project so that I can see what the current status is.
   - As a project manager I want to track the project so that I can forecast whether we will deliver on time or not.
   - As a software designer I want to document my design in a standardised format so that I can communicate it to other software engineers.
** Introduction
   In this sprint, we focus on a couple of issues surrounding the /development process/. First of all, there are a number of choices of which developent process to use, from the intuitively easy to grasp waterfall process to the highly individualised kanban process. Which process type to use depends to some extent on the product you are trying to build, but perhaps more so on which organisation you have. Basically, with stable development teams and fairly stable requirements, you can perhaps do an iterative or incremental project, but the more user interaction, continuously changing requirements, and staff turnover you expect, your organisation will tend to move towards more agile processes. There is also a lot of hype involved here. Companies that do agile are perceived as more modern, hip, and better.

   Most processes internally follow a waterfall course of events, with planning, requirements engineering, analysis and design, implementation, testing, deployment, and evaluation. The differences boil down to the amount of work that one iteration takes on, the size of the development teams, and the length of each iteration. Again, in agile there are also a lot of buzzwords added, but that's essentially it. So simple, and yet so powerful. You see, /as/ the scope and timespan for each iteration is reduced (down to weeks or even days), you get quicker feedback loops. You develop much less before you get feedback on what you have done. You also need to be smarter with what you develop so that you can get the /most important/ feedback first.

   This is where the concept of a /Minimum Viable Product/ comes in. A minimum viable product, or an MVP, is a product that supports an entire end to end flow. For example, if you are building a hotel booking system, the MVP may be a product that allows you to search and book one single room. Logging in, booking double rooms with extra beds, adding a minibar, room payment, etc. comes later. Searching for and booking a single room means you have /some/ user interface in place, you have a database structure, and you have /some/ architecture with a structure for how to name API endpoints.

*** Project Planning and Tracking
   Once you have decided which development methodology to use, you need to plan your project. You have already decided if you are going to do all analysis before all design or whether you are going to do the full analysis-design-implement-test chain for each feature in your system. But /when/ are you going to do what, and /who/ is going to do what. You may, for example, have some persons in your project that are specialised on user interfaces, on databases, or on exploratory testing. So you need to plan every person and every part of the process. 

   The first step of planning is to break down each task into smaller, more manageable tasks. For example, the task "Search for Room" in the hotel management system mentioned above, may consist of the tasks "database design", "GUI design", "implementation", and "testing". Each of these tasks are easier to estimate the size and difficulty of than the overall task. You can also now start assigning different parts of this task to different people, if you like. This breakdown is usually referred to as a /Work Breakdown Structure/, or a WBS. It is often graphically represented as a tree (see Figure [[fig:WBS]]), but may just as well be represented as several columns in a spreadsheet (see Table [[tab:WBS]]).

#+BEGIN_SRC dot :file images/FWBSExample.png
digraph {
rankdir=BT;
splines=true;
node [shape=box];

"..."
sr [label="Search for Room"]
sr -> "..."
"Database Design" -> sr
"GUI Design" -> sr
"Implementation" -> sr
"Testing" -> sr
"Implement DB" -> "Implementation"
"Implement Logic" -> "Implementation"
"Implement GUI" -> "Implementation"
"Create Tests" -> "Testing"
"Run Tests" -> "Testing"
}
#+END_SRC

#+CAPTION: An example of a graphical representation of a part of a WBS.
#+NAME: fig:WBS
#+RESULTS:
[[file:images/FWBSExample.png]]

#+CAPTION: An example of a spreadsheet representation of a part of a WBS.
#+NAME: tab:WBS
| Feature Group | Feature         | Tasks           | Sub-Tasks       |
|---------------+-----------------+-----------------+-----------------|
| ...           | Search for Room | Database Design |                 |
|               |                 | GUI Design      |                 |
|               |                 | Implementation  | Implement DB    |
|               |                 |                 | Implement Logic |
|               |                 |                 | Implement GUI   |
|               |                 | Testing         | Create Tests    |
|               |                 |                 | Run Tests       |

Having the data in a spreadsheet format makes it (IMHO) easier to work with, and also enables you to easily add more columns with data on who is responsible for the task, your effort estimations, your current status, etc. Essentially, you have the starting point for easily creating a /GANTT/ chart.

GANTT charts visualise your project in terms of activities and calendar dates, but you may just as well add more information to it to make it a full-fledged project tracking tool. For example, a simple format is to include the following information (Table [[tab:PPData]]).

#+CAPTION: Project Planning data that may be added in a GANTT chart
#+NAME: tab:PPData
| Task Name    | Estimated Effort (in hours) | Start Date | End Date                                                | Responsible    | Spent Time | Progress (in percent) | Projected Effort            | Over/Undertime                          | ... And here starts the GANTT chart proper with one column per day |
|--------------+-----------------------------+------------+---------------------------------------------------------+----------------+------------+-----------------------+-----------------------------+-----------------------------------------+--------------------------------------------------------------------|
| Example Task |                          20 | 2016-01-01 | ~(Start Date) + (Estimated Effort)/(Length of Workday)~ | Example Person |         12 |                    50 | ~(spent time) / (progress)~ | ~(estimated effort)-(projected effort)~ |                                                                    |

The discussion above focus on the /work performed/ (or the planned work). In contrast, agile methodologies focus on the /earned value/, which gives a slightly different picture. Whereas you can use the information above to tell your boss whether you are on time or not, you are not able to say at a glance how happy this has made the customer, or how many features you have left to before you are done. For these purposes, we use /Earned Value charts/ and /Burn charts/.

An Earned Value chart has three lines in it
- Planned Value :: How much of the estimated effort should have been completed at a specific point in time.
- Earned Value :: How much of the estimated effort was actually implemented at a specific point in time.
- Actual Cost :: How much effort was actually spent.

This is typically presented in a cumulative earned value chart (where the previous assessment period are added to the next, so that planned value end up at 100% at the far right of the chart. In Figures [[fig:EVChartP]], [[fig:EVChartC]], and [[fig:EVChart]] each of these lines are added. The x-axis represent the time, and the y-axis is some measure of value. This can be in hours, progress, pounds, story points, collected pokemons, or whatever makes sense for your project. Just make sure that it is a unit that is fixed /a priori/, and not something that will change throughout the project. For example, the number of lines of code (LOC) may seem a nice measure, but you know as well as I do that this will become larger than expected, and so you will end up not knowing how much more you need to write before the project is done (as opposed to as big as you initially expected it to be).

The planned value represent how much of the total value you plan on having done for each weeek (cumulative, so the difference in the amount of value added per week can only be seen by the differing slope of the line). If we add the actual cost (Figure [[fig:EVChartC]], sorry that the colour of the lines change, I CBA to fix it right now), we can see that we are spending about as much resources as planned. Specifically, we are spending /more/ than planned up until week 8, and after that we apparently come to grips with the project and continue spending less than planned. This graph shows the current state at week 18, which is why the actual costs flatline after that. Adding the eraned value, finally, gives the situation in Figure [[fig:EVChart]], where we see what we actually managed to deliver for the costs we invested. Up until week 8, we are delivering what is expected (the Earned value curve completely overlays the planned curve), but for a higher cost than expected. From week 8 to week 11, we are delivering more than expected. At best, we are one week ahead of schedule (the biggest horizontal difference between the Earned Value curve and the Planned Value curve). At week 11 we again slip behind shedule for a while, catching up in week 16 and 17, but then falling horribly behind schedule in week 18.

#+CAPTION: Earned Value Chart: Planned
#+NAME: fig:EVChartP
[[./images/IEV_Planned.png]]

#+CAPTION: Earned Value Chart: Adding Actual Cost
#+NAME: fig:EVChartC
[[./images/IEV_Cost.png]]

#+CAPTION: Earned Value Chart
#+NAME: fig:EVChart
[[./images/IEV_Earned.png]]

So what we see in this type of chart is a quick and easy measure of whether we are using our resources as planned (is the actual cost above or below the planned value curve?), and whether we are ahead of, or behind the planned schedule (is the earned value curve above or below the planned value curve?). We can then quickly decide whether we should add more resources to the project. In the example in Figure [[fig:EVChart]] we obviously need to do something if we are going to deliver as expected, for example spending the resources we already have allocated to the project (the difference between planned value and actual cost curves).

A burndown chart essentially turns this chart upside down. Partially, this is done for psychological reasons; it is easier to see how much or how little remains), but more importantly it enables us to easily visualise what happens when we add more work in the middle of a project. Consider the example in Figure [[fig:Burndown]]. The plan is that the project should be complete at week 22. However, at week 5 and week 15, more work is added to the project, so the number of story points still to complete goes up. This means that at week 22, there are still some forty-odd story points left to complete and the project is not done. This is just one example of how a burndown chart can be used to easily visualise the consequences of changing the scope mid-project. Agile development methodologies are not averse to changing the scope -- rather the opposite -- but they /do/ insist on that the consequences are known and easily understood.

#+CAPTION: Burndown chart
#+NAME: fig:Burndown
[[./images/FBurndown_Replan.png]]


*** Design Documentation
#+ATTR_HTML: :width 600
#+NAME: Arne01
[[./images/arne01.png]]

The last user story for this sprint is a bit of an oddball. What, one may wonder, does design documentation have to do with development methodologies. The reason for this is that the currently dominating design documentation format, the Unified Modelling Language (UML), also prescribes a certain way of doing the design, and a certain order for things to be done. This process is known as the /Unified Process/, or the /Rational Unified Process/ (because the originators created the company Rational and wanted to make more money off everything around UML). The Unified Process claims to be agile (we can debate this in the classroom), and is iterative and incremental and whatever buzzword /du jour/. We are not going into detail about all of this in this course, and will focus almost solely on the analysis and design stages, but even here, or especially here the different UML diagrams prescribe a certain order, so that you may use what you learn in one diagram as input to creating the next diagram. Thus:

- We do Requirements Engineering (outside the scope of UML) to find out what the customers and other stakeholders expect from the system.
- We do UML Use Cases to document the requirements in the context of the processes they are going to be used, so that we can communicate with the stakeholders about them.
- We do UML Use Case Diagrams to get an overview of, and understand how the UML Use Cases fit together.
- We do a Conceptual Model based on the requirements and the use cases to understand the problem domain better.
- We do UML State Diagrams based on the requirements and the use cases to understand the dynamic behaviour better.
- We do UML System Sequence Diagrams to understand which system events are generated by each UML Use Case.
- We may do UML Design Contracts to understand how each system operation from the UML System Sequence Diagrams changes the state of the application and instances of domain concepts.
- We do UML Class Diagrams to understand which domain concepts are important to implement, and how to implement them and their relations.
- We do UML Interaction Diagrams to understand how objects (instances of the classes) interact to solve one particular system event from the UML System Sequence Diagrams.
- We revise the UML Class Diagrams based on the UML Interaction Diagrams we just did.
- We implement the system based on the UML Class Diagram and the UML Interaction Diagrams.
- We write test cases based on the UML use cases.

Remember earlier where I mentioned that UML/RUP claims to be agile? Please take a moment to reflect upon whether you are able to do this entire list and remain agile. 

In 2014 a colleague of mine did a survey [fn:TGO-paper] among nearly 4000 professional software developers about their software development practices in general. One of the questions was the seemingly innocent /"Do you model?"/. Answers ranged from "no" to "hell no!", as presented in Figure [[fig:TGOSurvey]].

[fn:TGO-paper] T. Gorschek, E. Tempero, L. Angelis, /On the use of software design models in software development practice: An empirical investigation/, in Journal of Systems and Software 95(2014):176--193.


#+CAPTION: Survey Question and Answers
#+NAME: fig:TGOSurvey
  [[./images/ISurveyModelling.png]]


In the freetext answers a different story emerges:

#+BEGIN_info
The industrial software developers who answered the survey do use sketches, informal models, casual diagrams, etc, but not formal UML.
#+END_info

They were also allowed to provide a a further explanation to their answer. Common explanations were:
    - "Only for very complex designs, sometimes"
    - "Only use initially then start coding (diagrams not kept/updated)"
    - "Enables visualisation of the big picture/high level"
    - "Other types of models but not UML"
    - "Use models to communicate and coordinate with other developers"

... And many more, but the long and the short of it is that /models are not used as researchers expect/. Instead they are used for *conceptual analysis and exploration, problem solving, visualisation, and communication*. And this is the reason for why modelling and UML is worth bothering about. In order to visualise and communicate efficiently, it is helpful to use a common standard, which UML contributes. That way you can focus on /what/ you want to model and discuss instead of spending time explaining /how/ you have chosen to represent the information. For the analysis, exporation, and problem solving aspects it also helps to have a common notation to use. Try explaining how to tie your shoelace while at the same time invent a new language for it, and you'll see what I mean.

That being said, /you will probably never ever going to use all of UML in one particular project/, and after you complete this course, /no-one will probably ever require you to stick fully to the prescribed notation/.

So, why bother?

By taking a course in object oriented modelling, you will get training in a particular mindset, where you begin to analyse a problem in terms of its /objects/ and their /interactions/. This problem solving mindset is difficult to reach when bogged down with all the implementation details. Also, while you will not use /all/ diagrams outside this course, knowledge of which diagrams exist and how they fit together will enable you to make an informed decision about /what/ models are necessary for you to understand the problem and to communicate it. You should, however, bear in mind that there are some good things with doing the full monty UML as well, and by cherry-picking models and parts of the process you are sacrificing them. The trick is to be able to do this with full awareness of what it is you sacrifice.

So, with those heartwarming words, let's delve into /not/ UML, but development processes instead. You will notice that I have thrown in a few book chapters that are not precisely related to development methods, and some of the chapters will appear again in other sprints. But now is as good a time as any to get started on them.
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      1. Object-Oriented Analysis and Design
      2. Iterative, Evolutionary, and Agile
      3. Case Studies (we will be using the POST case study)
      21. [@21] Test-Driven Development and Refactoring
      40. [@40] More on Iterative Development and Agile Project Management
*** Screencasts
    - [[https://play.bth.se/media/Development+Process/1_gmy3m68z][Development Process]]
*** Lectures							   :noexport:
*** Further Reading
    - [[https://www.mountaingoatsoftware.com/presentations/an-introduction-to-scrum][Introduction to Scrum by Mike Kohn]]
    - [[http://www.workbreakdownstructure.com/][Work Breakdown Structure]]
    - [[http://www.gantt.com/][GANTT charts]]
    - [[http://www.dummies.com/how-to/content/earned-value-management-terms-and-formulas-for-pro.html][Earned Value charts]]
    - [[http://alistair.cockburn.us/Earned-value+and+burn+charts][Earned Value and Burn Charts by Alistar Cockburn]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear solution to each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Waterfall Development
    - Iterative Development
    - Incremental Development
    - Agile
    - Scrum
    - Kanban
    - Minimum Viable Product (MVP)
    - Work Breakdown Structure (WBS)
    - GANTT chart
    - Earned Value Charts
    - Burn Charts (Also: Burndown charts and burn-up charts)
    - UML
    - Unified Processs (Also: Rational Unified Process RUP)

    Make sure that you understand what each item is, but also what the differences between them are (where applicable).
*** Assignment: Assignment Plan
    Create a Assignment Plan document (e.g., as a GANTT spreadsheet). Add the assignments that you will need to submit in this course, and do a brief breakdown of them into their most obvious tasks. Add early time estimates for these tasks.

    There is no formal submission in this sprint, but make sure that the plan is committed and pushed to your project repository.
*** Update Course Backlog
    Which development methodology do you plan on using for your projects in this course? Which development methodology would you like to know more about? Which development methodologies are you likely to encounter in the future? Is there any methodology that seems particularly suitable for other courses?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have read the Learning Materials.
   - You have created your Assignment Plan and committed/pushed it to your project repository.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
* Sprint: Requirements Engineering				   :noexport:
** About This Sprint
   This sprint briefly introduces the topic requirements engineering. It is primarily targeted at {{{pa1415}}}.
   
   For more information on this topic, see e.g. the course ~PA1412 Praktisk Kravhantering~.

#+BEGIN_note
   *Note:* In this sprint you will begin with what will eventually be delivered as a part of Assignment 1. In subsequent sprints you will continue with what you produce here and dive deeper into UML. You will thus only produce a partial delivery in this sprint.
#+END_note
** User Stories covered in this Sprint
   - As a requirements engineer I want to know who may have requirements on the system we are building so that I can make sure that all needs are met.
   - As a requirements engineer I want to have a range of methods for finding requirements so that I can choose the best method for each person or source of requirements.
   - As a requirements engineer I want to document the found requirements so that I can discuss them with the customer.
   - As a requirements engineer I want to document the found requirements so that I can communicate them to the developers.
   - As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.
** Introduction
   Before you start designing your system, you need to find out /what/ to design and build. There are of course different ways of doing this. The traditional way advocates that you need to fully understand the entire system before you go ahead with the design (cf. /waterfall development/), whereas at the other end the agile approach (e.g. as advocated by [[http://www.extremeprogramming.org/][eXtreme Programming]] and the [[http://agilemanifesto.org/][Agile Manifesto]]) is that you should only do as much requirements engineering up front as is necessary to understand how to start building, since the requirements are going to change anyway. Note that they do not say "Don't do it!"; they say "Do as little as possible, but not less".

   It is thus important to decide early how much requirements engineering you should do before you start with the project. Incidentally, there is a difference between the traditional, so called /bespoke/ requirements engineering where you start a project when a customer knocks on the door and then you do requirements engineering as part of that project, and the /continuous/ requirements engineering where you always do requirements engineering and spawn new development projects as a result of the requirements engineering process. The latter suits the type of products that you develop and sell to more than one customer, while the former is more suitable for one-off projects. For this course, I would suggest a pragmatic approach (akin to the agile way): Do as much requirements engineering so that you have a rough overview of what the system should do, and do proper requirements engineering on what you need to know do make a Minimum Viable Product. 

   There are many sources and techniques for doing requirements elicitation (i.e., finding the requirements), from reading the old documentation, analysing competitor's products, interviewing users, running surveys among user groups, or simply inventing the requirements yourself. If you do requirements engineering you will be using a mixture of these. Typically, you will start by doing an unstructured interview with a manager to get a broad overview of what they want the system to do. You will then try to define end user groups and find a couple of representative persons from each user group and conduct further interviews with them. At first, these interviews will be exploratory and unstructured, but will pretty soon become semi-structured as you learn about the major features of the system, so that you will be getting further details about each of these major features.

   Finding out who may have an interest in the system (a /stakeholder/) is so important that I have even added a separate user story for it in this sprint. This is not limited to end-users. Other stakeholders may include (but is not limited to): the organisation that is going to maintain and continue development of the system, system service technicians that will be doing backups and adding users and other running maintenance, external parties that you may connect to (for example banks to deal with payments), legal texts (that's right: a text can be a stakeholder), other departments in the organisation you build for that require your system to jack in with their processes, and so on.

#+CAPTION: Requirements Engineering Overview (Simplified)
#+NAME: fig:REProcess
[[./images/FRE_Process.png]]

*** Interviews
I've already touched upon elicitation techniques. The one you are likely to use the most is /Interviews/. "Interview" is actually a cover-all phrase that encompasses a whole range of different techniques that involves two people or more with (at least) voice contact. You /may/ thus do interviews over phone, but I would not recommend it since you loose a lot of nuances that can be learnt by observing body language. Video conference or face-to-face meetings IRL are the most common interview settings. You can be one person interviewing one other person, or there can be more people either doing the interview or being interviewed (although at some point it is perhaps better to run the meeting as a [[https://en.wikipedia.org/wiki/Focus_group][focus group]]).

In its most simple form, you conduct the interview as an /open interview/ with /open answers/. In this setting, you basically just talk, and together explore what the application should do. You rarely have the luxury to be this unstructured, even in the first interview. I would recommend you to do as much homework as possible beforehand so that you have at least a small set of starting questions that you can use to get the interview going and to get back on track when you feel that you have diverged too far from the interview goals. Having a set of questions moves the interview into a /semi-structured/ format, where you are able to follow up on the answers given with further impromptu questions. The extreme is a /structured/ interview where you have a specific set of questions that you want answered in a particular order without room for any further probing. This is typically only used in research contexts.

Similarly, you can allow /open answers/, typically early on when you want to explore and look for new information, or you can restrict the answers to a /closed answer/ space, where each question can e.g. be answered with one of four alternatives. This is good for confirming what you have previously learnt; you can collect answers from larger groups of people and quickly analyse them, and the idea is that at that stage you should not expect to find any new information.

Thus, a requirements engineer will probably use semi-structured open answered interviews. In this course, however, this will not be the case as it would be out of scope for the course. You will instead have to create the requirements yourself (more on this under the Experiential Learning in this sprint).

How you behave during an interview influences the results, because your behaviour can make the interview subjects more or less prone to answer your questions. In Table [[tab:InterviewsDnD]] I have compiled a list of do's and don'ts in interview situations (we have actually used this list to assess requirements elicitation interviews in the requirements engineering courses at BTH).

#+CAPTION: Do and Don't in an Interview Situation
#+NAME: tab:InterviewsDnD
| Do                                                       | Don't                                                                    |
|----------------------------------------------------------+--------------------------------------------------------------------------|
| Do    prepare thoroughly for the meeting                 | Don't put your laptop on the table as a wall between you and your client |
| Do    prepare a checklist for the meeting                | Don't keep your cap on your head                                         |
| Do    introduce yourself properly                        | Don't interrupt the customer                                             |
| Do    ask about access to stakeholders                   | Don't interrupt each other                                               |
| Do    ask about access to previous systems               | Don't take no notes                                                      |
| Do    book the next meeting                              | Don't record the interview without asking                                |
| Do    ask about quality requirements                     | Don't assume stuff                                                       |
| Do    make sure you know who you are talking to, and why | Don't provide requirements                                               |
| Do    ask about deadlines                                | Don't provide goldplating                                                |
|                                                          | Don't technobabble                                                       |
|                                                          | Don't sit quiet                                                          |
|                                                          | Don't kiss up (too much)                                                 |
|                                                          | Don't follow your meeting checklist manically                            |
|                                                          | Don't share war-stories about other customers and systems                |
|                                                          | Don't ask about the budget at the first meeting                          |
|                                                          | Don't argue among yourselves                                             |
*** Specification
    Once you have found the requirements, your next step (after analysing them and negotiating them with the customer, but that is also outside the scope of this course) is to /Specify/ the requirements. There is an IEEE standard, [[fig:SRS][IEEE 830]], for how to structure your requirements document, assuming you specify requirements in the traditional way. The good thing about this is that it has existed for many years, and people are used to seeing it and signing contract based on it. The bad thing about it is that it is not as well known or easy to understand as requirements engineering researchers would like to think it is, and with a few moments of education I am certain that you will be able to educate your customers on any document and requirements format you choose.

#+NAME: fig:SRS
#+BEGIN_info
*IEEE 830 Standard for Software Requirements Specifications*
   1. Introduction
      1. Purpose of the Requirements Document
      2. Scope of the Product
      3. Definitions, Acronyms, and Abbreviations
      4. References
      5. Overview of the Remainder of the Document
   2. General Description
      1. Product Perspective
      2. Product Functions
      3. User Characteristics
      4. General Constraints
      5. Assumptions and Dependencies
   3. Specific Requirements
      Functional, non-functional, and interface requirements
   4. Appendices
   5. Index
#+END_info

To simplify, there are two plus one ways of writing requirements. The two ways are traditional requirements and user stories. The plus one way is UML use cases. UML:ists themselves claim that use cases are not requirments, they are merely scenarios where one or several requirements are "exercised". I would rather avoid re-formatting the requirements once more and just add more documentation that will only be used once, so I would try very hard to get away with only documenting the requirements within the context of a use case if I must use them.

#+BEGIN_SRC ditaa :file ./images/FRESpecification.png
        +------------------+  +-----------+
        | Requirements     |  | UML       |
        | cGRE             |  | Use Cases |
        |                  |  | cBLU      |
        +------------------+  |           |
                              |           |
        +------------------+  |           |
        | User Stories     |  |           |
        | cGRE             |  |           |
        |                  |  |           |
        +------------------+  +-----------+
#+END_SRC

#+CAPTION: Two plus one way of specifying requirements
#+NAME: fig:REtwoplusone
#+RESULTS:
[[file:./images/FRESpecification.png]]

Traditional requirements may be specified as figures, tables, sketches, or plaintext, with the plaintext version being the one most commonly discussed. They usually follow a standardised format with a number of attributes per requirement (title, description, source, date, etc.), and a standardised template for the actual requirement. User Stories are supposed to be less documentation so they try to include the most relevant of all of this information into a single one-liner. Shorter iterations, a more direct path from inception to implementation, and closer collaboration with the customer makes it easier to do away with a lot of the information considered necessary in traditional requirements.

UML use cases are covered in a different course sprint, so I will only briefly mention them here. With a use case, you are attempting to put the requirements into a context. Of course, this means that you need to write more, since you also need to add information about the context. This is one of the reasons why they are not considered requirements -- they are simply too verbose. This verbosity also means that a developer is unlikely to do use cases for every requirement and every part of the system; but will rather do them for those parts of the system where there is a usage flow that is difficult to grasp in one sentence, and where you are likely to hold a "conversation" with the system to fulfill a higher need. For example, searching for a hotel room is a one-liner. /Booking/ a room on the other hand may involve
- a search
- a narrowing of the results to specific types of rooms
- a check whether the room is available
- a selection of the room
- input of information about the person booking the room, and
- a confirmation that the room is booked.

Each of these items may, in turn, comprise more than several requirements, including at least one requirement that restricts the order in which these actions must be performed.

*** Prioritisation
[[./images/I0Programmer.jpg]]

So, which requirement should you focus on developing first?

In traditional requirements engineering, there is a whole phase solely dedicated to requirements prioritisation. Agile software development methodologies (such as Scrum) also assumes that you always have your user stories prioritised in your backlog. Essentially, you are doing insertion sort whenever you add a new user story, while also checking that the priority of the existing items do not change as a result of adding the new user story. Each sprint begins with a review of the backlog, before you select among the top prioritised user stories which you should develop in the sprint. If the user story is really big (called an /epic/), one of the actions you may do is to break it down into more manageable user stories and put these into the backlog.

This, of course, does not answer the question since it only explains /how/ you decide, but not /on what grounds/. Also here, you can probably build a research career on deciding which factors should influence your prioritisation (see, for example, Ruhe and Saliu's paper "The art and Science of Release Planning" [fn:Ruhe]), but a few good starting points are:

- Value for the customer
- Cost of implementation (Cost and Value can be nicely combined as e.g. Karlsson and Ryan [fn:CostValue] shows).
- Penalty for not implementing

UML/RUP would advocate that you wait with prioritising your requirements and instead prioritise the UML use cases, so that you deliver the most important features first. This does not mean that you need to implement the full flow of events in one go; always keep the Minimum Viable Product in mind.

[fn:Ruhe] G. Ruhe and M. O. Saliu. /The art and science of software release planning/. IEEE Software, 22(6):47–53, 2005.
[fn:CostValue] J. Karlsson and K. Ryan. A cost-value approach for prioritizing requirements. IEEE Software, 14(5):67– 74, 1997.

*** Summary
Requirements Engineering is a big topic, and can be quite complex. The introduction above is just meant to get you started. I have, for example, only touched upon the difference between bespoke and market-driven requirements engineering. I have not mentioned any of the challenges involved when you do large scale requirements engineering or very large scale requirements engineering. Nor have I gone through all the different techniques available for eliciting requirements, checklists for analysis, requirements verification, etc. etc. You will get some more information about some of these things in the screencast "Requirements Engineering", and for the rest I direct you towards one of the requirements engineering courses offered at BTH.

I include some of the UML Use Case learning material in this sprint which will give you a head start for the next sprint, but the focus on what you are expected to do is "traditional" requirements engineering.

A note also about elicitation techniques: I say earlier that you are most likely going to use interviews. Well... In this course that's not quite true. In this course you are going to create the requirements yourself, based on a brief system description.
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      4. [@4] Inception is Not the Requirements Phase
      5. Evolutionary Requirements
      6. Use Cases
      7. Other Requirements
*** Screencasts
      - [[https://play.bth.se/media/Requirements+Engineering/1_epma2li8/41750261][Requirements Engineering]]
      - [[https://play.bth.se/media/Use+Cases/1_d4tqygel/41750261][Use Cases]]
*** TODO Lectures						   :noexport:
    Ideas:
    - Requirements Elicitation Roleplay?
    - Good and Bad Requirements?
*** Further Reading						   :noexport:
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Requirements Engineering
      - Requirements Elicitation
      - Stakeholders
      - Software Requirements Specification (SRS)
      - RFC 2119
      - Requirements Prioritisation
    - Quality Attribute (Also: Non-functional Requirement)
    - User Story
    - Epic
    - Backlog
    - Acceptance Test
    - Use Case

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.
*** Self-Study: Requirements Interview
    Let's say you are going to build a student simulator. As a part of this you need to find out the morning practices of a typical student.
    
    Interiew a couple of student colleagues on what they do in the mornings. Try to plan beforehand, and have your colleague assess what you do good and what you can improve during the interview.
*** Self-Study: Requirements Specification
     Try to write down a common process for what you elicited above, i.e. the "getting up, getting ready, and getting to uni in the morning"-process.

     Express this process as:
    - regular requirements (consider their apartment, their mother, the bus, etc. as part of "the system")
    - user stories (think about the role they have for each part, and the motivation for why they want something done)
    - use cases  (consider their apartment, their mother, the bus, etc. as part of "the system")
*** Assignment: Requirements Document
    Your main task is to write user stories based on the system description for the assignments.

    *Tasks*
    1. Describe the system in terms of the most important workflows, as "epics". Add conditions of satisfaction to each epic.
    2. List the epics in order of importance, and add a brief motivation for why you have ordered them the way you have.
    3. Take the three most important epics, and break them down to more manageable user stories. Add conditions of satisfaction to the user stories. Order them according to priority, and add a brief motivation.

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(User Stories)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] High-level Epics
   1. Motivation for Priority
   2. Epics (ordered most important first)
4. User Stories
   1. Motivation for Priority
   2. User Stories and Epics (ordered most important first)
5. References
#+END_info    

#+BEGIN_note
*Please note* that the "User Stories and Epics" shall include /both/ the remaining epics from section 3 in the document /and/ the broken down user stories.

*Please also note* that the user stories from the epics that you break down will probably be interlaced; the least important user stories from the top-most epic need not be more important than the most important user stories from the second epic. You will thus have to review the priorities of /all/ user stories against all other user stories and epics.

*Also also note*, when you go forward you will want each user story to have a unique ID so that you can refer back to them.
#+END_note

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution 
1. Size of assignment: Are there 5-10 epics and 10-30 user stories?
2. Is there a significant difference in scope between the epics and the user stories?
3. Are the epics and user stories well formed (including actor, goal, and reason)?
4. Are there relevant conditions of satisfaction for each user story/epic?
5. Is there a reasonable motivation for the priorities of the epics and user stories?
6. Does the prioritisation actually follow the motivation?
#+END_tip

*** Update Course Backlog
    How do you translate your user stories into UML use cases? How do you use the prioritised order to decide on a development schedule? Why are you specifying your requirements first as user stories if you are then going to re-specify them as UML use cases immediately afterwards?

    What other means are there for eliciting requirements? How may you gain experience in using them?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have read the Learning Materials.
   - You have created the "User Stories" document and committed/pushed it to your project repository.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Performed self-study requirements interviews
   - Documented the results from the self-study interviews in different formats.
* Sprint: Use Cases and Use Case Diagrams		:noexport:submission:
** About This Sprint
   This sprint introduces UML use cases and UML use case diagrams as a means of putting requirements into a context and understanding the interactions between users and the system.
** User Stories covered in this Sprint
   - As a software designer I want to document what the customer is telling me so that I can discuss my understanding of their requirements with them.
   - As a software designer I want to document what the customer is telling me so that I can easily continue designing based on a joint understanding.
   - As a software designer I want to be able to reuse common procedures between my use cases so that I only have to maintain them in one place.
   - As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.
   - As a product manager I want to make sure that we are building software of high quality.
** Introduction
   UML use cases is the first step into Object-Oriented Analysis, according to RUP. The core of a use case is a small set of attributes (name, involved actors, brief description, main course of events, alternative flows). Depending on which version of the course book (Larman) you have you may extend this set with more attributes, and they will have different names (for example Brief (or high-level) use cases and fully dressed (or expanded) use cases) depending on how much information you provide. Outside of this course, it is not important what you call the attributes, or what you call the use cases themselves. What is important, though, is that you establish an order in which to work with the use cases, and that you decide on one standardised format -- at least for your project, but preferrably for your organisation -- since this simplifies both readability and the creation of the use cases.

#+BEGIN_info
*An Example of a Use Case*

- Use Case :: Order Ice Cream
- Actors :: Kid, Ice Cream Man
- Description :: A kid arrives at the ice cream truck and orders an ice cream.
     The Ice Cream Man delivers the ice cream, and informes the kid about the price.
     The kid pays and eats their ice cream.
- Main Course of Events ::
     | Actor                                                    | System                                                           |
     |----------------------------------------------------------+------------------------------------------------------------------|
     | 1. A kid arrives at the ice cream truck                  |                                                                  |
     |                                                          | 2. The system informs about available choices                    |
     | 3. The kid orders an ice cream                           |                                                                  |
     |                                                          | 4. The system prepares the ice cream and informs about the price |
     | 5. The ice cream man delivers the ice cream.             |                                                                  |
     | 6. The kid pays.                                         |                                                                  |
     | 7. The ice cream man enters the payment into the system. |                                                                  |
     |                                                          | 8. The system gives change on the paid amount.                   |
- Alternative Flow of Events :: 6. The kid eats the ice cream and gets sucked into the ice cream van and turned into more ice cream.
#+END_info

   The usefulness of use cases lies in that you put a bunch of requirements into a working scenario. A scenario is easier for both the end-users and for the developers to understand. Rather than having to go through all possible alternative branches and edge cases, you focus on describing /one instance/ of interacting with the system. In the example above, it is not "any kid" that arrives at "any ice cream truck". It is one /specific/ kid (Let's call him Bob) arriving at /one specific/ ice cream truck, at /one particular time/. Yes, we do take some shortcuts by saying that the kid orders "an ice cream" instead of "a vanilla ice cream" in order to simplify a bit, but initially we try to avoid anything that may create branches in the main course of events. When we iterate the use case we may see that there are alternative flows to cover (like the [[http://www.imdb.com/title/tt0113376/][surprise twist]] in the example).

[[./images/Iwow-that-escalated.jpg]]

It is also important to remember that the main course of events should describe a /positive flow/, i.e. a flow where the operation succeeds and everyone leaves the use case happily. All the negative flows (for example, the kid does not have enough cash, the ice cream man is out of voodoo dolls, etc.) should be covered as alternative flows.

*** Use Cases as Test Cases
    As a developer, you may use this use case straight off as a test case for the system. Find Bob, put him in front of the ice cream truck, and tell him to order an ice cream. If you are able to execute the use case as specified, you have a passing test case. You are of course not done with your tests here, since the use case is not complete. If you think about it, you may select different flavours of ice cream, you may ask for one or several scoops of ice cream, you can ask for a cone or a cup, you can pay with cash or card, and so on. All of these choices ought to be covered in the use case and the corresponding test cases. You may also pay up-front or after delivery, but this may be better represented as two separate use cases.
*** Use Cases and Business Requirements
    Take the use case above. Now quickly tell me which business requirements that are involved.

    Do the reverse. Take a requirement. Quickly tell me which use cases this requirement is realised in.

    You can't, can you? This is one of the downsides of use cases if we "do things by the book". All is not lost, however. It is relatively easy to augment the use case format to cover for these two situations.

    The quickest is to add one attribute "Dependencies" (or "Relevant Requirements", or whatever you wish to name it) and simply list all requirements that you are using in the use case. The downside to this approach is that you do not know /how/ the requirements are involved. Let's say that you have a requirement that /"As a customer I want to know if there are any nuts in the ice cream because I am allergic to hazelnuts"/. When should this requirement be used? When the system informs about the available choices? When the kid orders the ice cream? When the kid has already payed?

    Another option is to add a column to the main course of events instead:

#+CAPTION: Adding Business Requirements to a Use Case's Main Course of Events
#+NAME: tab:UC-BR
         | Actor                                                | System                                                           | Business Requirements                                                                                                              |
         |------------------------------------------------------+------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------|
         | 1. A kid arrives at the ice cream truck              |                                                                  |                                                                                                                                    |
         |                                                      | 2. The system informs about available choices                    | BR1: "As a customer I want to know what choices are available because I don't like vanilla"                                        |
         |                                                      |                                                                  | BR2: "As a customer I want to know if there are any nuts in the ice cream because I am allergic to hazelnuts"                      |
         |                                                      |                                                                  | Note: Also list lactose, gluten etc.                                                                                               |
         | 3. The kid orders an ice cream                       |                                                                  | BR3: "As a customer I want to order a particular flavour of ice cream so that I can get the ice cream I like."                     |
         |                                                      | 4. The system prepares the ice cream and informs about the price | BR4: "As an ice cream man I want to get payed before I deliver the ice cream to avoid them pesky kids running away without paying" |
         | 5. The ice cream man delivers the ice cream.         |                                                                  |                                                                                                                                    |
         | 6. The kid pays.                                     |                                                                  |                                                                                                                                    |
         | 7. The ice cream man enters the pay into the system. |                                                                  |                                                                                                                                    |
         |                                                      | 8. The system gives change on the paid amount.                   |                                                                                                                                    |

    Of course, this is more difficult to index (but only slightly and it is easily programmed). You also need not write the entire requirement in the Business Requirements column -- just the requirement's ID. You may think that for a larger system, this kind of cross-referencing may become difficult because you need to have a pretty firm grasp of the entire requirement's database in order to be able to identify the relevant requirements. However, you would then be assuming (a) that all requirements engineering is done before analysis/design in a waterfall methodology, (b) that you could write the use case without this awareness, and (c) that you cannot add requirements to the use case later and alter the main course of events accordingly. Neither of these are true.

    You may wonder why you /should/ link use cases and requirements at all? Simply because you are /not/ following a strict waterfall development methodology in a one-off development. When a requirement changes you want to be able to quickly find out where you have designed and implemented the requirement, and when you are implementing the use case you may have more questions, or you may have different idea of how to solve the problem, and then you need to check what was actually stated in the requirement (and who stated it so you can talk to them about it).
*** Use Cases and Quality Attributes
    Another issue that is not included in the default use cases are /quality attributes/. I suppose you /could/ add it in the regular use case, so that every system response has a subordinate clause specifying the quality constraints. But why not re-use the idea suggested above. Quality requirements are -- once specified -- just ordinary requirements, so you can add them in the "Business Requirements" column for every system response. This makes it easy to add several quality constraints on each system response. Even better, you do not need to have the same quality constraints on the entire use case. For example, presenting the list of ice cream flavours MUST be done within two seconds, but accepting a credit card payment MAY take up to five seconds.
*** Use Case Diagrams
    Roughly (and don't hold me to this, because there are many situations where this is not true) there will be one use case per feature in the system, for a loose definition of feature. (There, did I weasel out that sentence sufficiently to not say anything meaningful?)
    
    This means that there may be quite a lot of use cases, and it may become difficult to get an overview of them if all you have are their textual form. /Use Case Diagrams/ are the UML answer, with the intention of visually clearing up:

- What the /boundaries/ are of the system(s) (to which system does which use case belong)
- What /actors/ are involved for each system and in each use case
- What /use cases/ there are in each system
- What /relationships/ there are between use cases, between use cases and actors, and betwen systems.
*** Use Case Reuse
    When doing larger use cases, you may encounter smaller pieces of processes that are needed by the big use case but are not really dealing with the same problem. For example, what does money and payment have to do with ordering ice-cream (my kids struggle with this one too). There may be alternative ways of doing something, where each way in turn has a number of sub-steps. In order to keep the main use case clean and focused on one problem, and in order to create reusable bits of processes, you can break out behaviour from the main use case into sub-use-cases.

#+BEGIN_SRC plantuml :file ./images/FStructuringUC1.png
scale 400 width
left to right direction

rectangle POS {
(BuyItems)
(CreditPayment)
(CashPayment)
(CheckPayment)
(CreditPayment) .> (BuyItems) : include
(CashPayment) .> (BuyItems) : include
(CheckPayment) .> (BuyItems) : include

}

Cashier -> (BuyItems)
Customer -> (BuyItems)

:Credit Authorisation Service: as CAS

CAS -> (CreditPayment)
#+END_SRC

#+CAPTION: Example of a Use Case Diagram where the BuyItems use case includes CashPayment, CheckPayment, and CreditPayment.
#+NAME: fig:UCInclude
#+RESULTS:
[[file:./images/FStructuringUC1.png]]
*** Use Case Prioritisation
    Prioritising use cases is at first no different than prioritising requirements or user stories, the difference is that it is the first UML artefact available for you to prioritise. The ground rule is:

#+BEGIN_info
    First implement use cases that /significantly influence/ the core system architecture.
#+END_info
    
   This is pretty much the same advice as you would get in Agile development methodologies, with their focus on a Minimum Viable Product (MVP). The question is, of course, what does "significantly influence" mean? Larman suggests a few guidelines for what may increase the ranking of a use case:

#+BEGIN_info
   Increase the ranking of a use case if it
   - has direct impact on architectural design
     - example: adds classes to domain layer, require persistent services
   - includes risky, time-critical, complex functions
   - involves new research or technology
   - represents primary business processes
   - directly supports revenue or decreased costs
#+END_info

   Also remember that you need not implement a use case completely in one iteration. The Minimum Viable Product in the ice cream example is, for example, to get a selection of ice creams and order one. Payment (and authentication etc. etc.) is not part of the MVP, so you can wait with this until a later iteration. If you look at the involved business requirements, this may make more sense to you.

*** Story Points
    I think it is time I introduce another agile concept, namely that of /Story Points/. You will need this because once you have ranked your use cases, user stories, or requirements, you need a way to determine how much you should commit to in the sprint you are planning for.

    Decide on a unit. This may be "hours to develop", "[[http://spacequest.wikia.com/wiki/Buckazoid][Buckazoids]]", "[[https://en.wikipedia.org/wiki/Spanish_dollar][pieces of eight]]", or just plain and simple "Story points". Take the first item to estimate from your backlog and agree how many story points it is worth. With this as a base, you then have a relative point that you can assess the remainder of your items against ("Is it more or less than item #1? How much more? Twice? Thrice?"). A common advice is to use a series of possible values for how many story points an item may get. Commonly suggested is to use the fibonacci sequence (1, 2, 3, 5, 8, 13, 21, 34, 45) since it climbs quickly.

    /You will never use the story points outside your team/, so it does not matter that they are not absolute. Inside your team, you will use them to measure /velocity/, i.e. "how many story points do you complete per week". First, you now have a nice measure of whether everything is ok in your team and in your product, if you are completing as many story points per week as you usually do (your average velocity). Second, you have a means with which to plan your iterations. If you know that your average velocity is ~X~ per week with a confidence interval of ~+/- 10%~ and your sprint is planned to last for ~Y~ weeks, then you know you will /at least/ be able to commit to ~0.9X * Y~ story points in your sprint. Your manager will probably not be happy about this because they expect more from you. So you get closer to the upper bound ~1.1X * Y~ instead, and this makes the manager unhappy when you fail to meet your goal. I can't teach you how best to placate your manager, but this will at least give you an idea of which ballpark you have to play in.

    Of course, when you split up a UML use case into parts that can be implemented in separate iterations, you need to estimate the story points for each part. Good luck!
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      4. [@4] Inception is Not the Requirements Phase	 
      5. Evolutionary Requirements
      6. Use Cases
      7. Other Requirements
      21. [@21] Test Driven Development and Refactoring
      30. [@30] Relating Use Cases
*** Screencasts
  - [[https://play.bth.se/media/Use+Cases/1_d4tqygel/41750261][Use Cases]]
  - [[https://play.bth.se/media/Structuring+Use+Cases/1_seaeffad][Structuring Use Cases]]
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[https://agilefaq.wordpress.com/2007/11/13/what-is-a-story-point/][What is a Story Point?]]
    - [[https://www.mountaingoatsoftware.com/blog/what-are-story-points][What are Story Points (M. Cohn)]]
    - [[https://www.mountaingoatsoftware.com/blog/story-points-are-still-about-effort][Story Points are Still about Effort (M. Cohn)]]
    - [[https://www.mountaingoatsoftware.com/blog/the-main-benefit-of-story-points][The Main Benefit of Story Points (M. Cohn)]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Use Case
    - Use Case Diagram
    - Sub Use Case
    - Test Case
    - Quality Attribute
      - Quality Aspect
      - Quality Requirement
      - Quality Constraint
    - Minimum Viable Product (MVP) [fn::The term "Minimum Viable Product" may be new to some of you but not all, because you may be following a different path through the sprints. You can expect more of these terms that some of you already know about.]
    - Story Points
    - Velocity

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Self-Study: Use Cases
    Take a system that you are familiar with. List the use cases in this system in a Use Case Diagram, along with the actors involved. Pick a couple of use cases that requires you to interact with the system in several steps and complete the use cases with a "main course of events". Think about alternative flows and add them too.

    Remember that all actors are not visible. For example, in a messaging application you would have both sender, recipient, and possibly forwarding agent as actors.
*** Self-Study: Planning
    Gather your team. Decide on a system that you want to plan (for example, the system that you just listed the use cases for), and engage in a game of [[https://www.crisp.se/bocker-och-produkter/planning-poker][Planning Poker]] to estimate the sizes of all the use cases.

    Give your use cases a rough priority, e.g. using the [[https://en.wikipedia.org/wiki/MoSCoW_method][MOSCoW method]], and see if you can divide your thusly created backlog into reasonably sized sprints.
*** Assignment: Use Case Overview
    *{{{pa1415}}}*: In this part of the assignment you will continue with the requirements document that you have already created and transform your user stories into UML use cases.

    *{{{pa1435}}}*: In this part of the assignment you will write UML use cases based on the system description for the assignments.

    {{{tasks}}}
    1. Create a /Use Case Diagram/
       - Identify all /actors/ that are interacting with the system.
       - Identify all /use cases/ of the system (features).
       - Identify which actors are involved in each use case.
       - Identify any other relations between the use cases.
    2. Briefly describe the actors in a dictionary.
    3. Describe the use cases in a high-level description, containing:
       - Use Case Name
       - Primary Actor
       - Brief Description
    4. For students of *{{{pa1415}}}*, link your user stories to the relevant use cases by adding an attribute:
       - Concerned User Stories
	 
#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Use Case Overview)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Use Case Diagram
4. Description of Actors
5. High-Level Use Cases
6. References
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. Size of assignment: Are there 15-25 high-level use cases?
2. Are all relevant actors identified and described?
3. Are all relevant use cases identified and briefly described?
4. For each use case, are all the relevant actors linked?
5. Is the use case diagram well formed?
6. Do all the use cases have all attributes?
7. Do all the use cases have unique and good names?
8. Do all the use cases have a sufficient and proper description?
9. (*PA1415*) Are the use cases linked to the relevant user stories?
10. (*PA1415*) Are all user stories linked in at least one use case?
#+END_tip
*** Assignment: Implementation Plan
    In this part of the assignment you will prioritise your use cases and plan your first sprints.

    {{{tasks}}}
    1. Order your UML use cases (created above) according to their importance.

       *{{{pa1415}}}* Make sure this order corresponds to the prioritised list of user stories that you have created earlier. You do not have to strictly adhere to the priorities of the user stories, but you need to document and motivate any major deviations that you do.

    2. Motivate your ordering in terms of how this allows you to build a minimum viable product first.
    3. Assign story points to each use case.
    4. Decide and motivate how many story points you will have time for in this course (=your first iteration) and per iteration. Set a MAX, a MIN, and an AVERAGE value per iteration.
    5. Assign your use cases to iterations such that you
       1. Create a minimum viable product in your first iteration (motivate why which this is the case).
       2. Have a reasonable amount of story points allocated per iteration, in relation to the MAX, MIN, and AVERAGE values defined.

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Implementation Plan)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Prioritised List of Use Cases
   1. Motivation for Priorities
   2. Use Cases
      
      Include: use case name and size in story points. Present the list ordered according to priority (most important first).
4. Estimated Velocity Per Iteration

   Here you list your MAX, MIN, and AVERAGE number of story points that you think you will have time for per iteration. Pay special attention to the first iteration since this is the one you will continue with in the rest of the course.

5. Implementation Plan
   1. Motivation for Implementation Plan
   2. Iterations and Use Cases
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. Size of assignment: Does the first iteration contain 5-10 use cases?
2. Size of (future) assignments: Does the suggested iteration velocity in relation to the size in story points per use case represent a reasonable development speed?
3. Is the relative size in story points reasonable for each use case?
4. Does the first iteration contain a workable and acceptable Minimum Viable Product?
5. Is there a reasonable amount of work (in terms of story points) assigned to each iteration.
6. (*PA1415*) Does the order of implementation of the use cases correspond to the priorities of the involved user stories?
#+END_tip

*** Assignment: Detailed Use Cases for First Iteration
    Describe in detail the use cases that you are focusing on in the first iteration.

{{{tasks}}}
1. Extend the use case descriptions for the use cases in your first iteration in your Implementation Plan so that they also contain the following attributes:
   - Preconditions
   - Main Course of Events (or Main Success Scenario)
   - Alternative Flow of Events (or Extensions)
   - Special Requirements

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Detailed Use Cases (Iteration 1))}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Detailed Use Cases
   
   List your detailed use cases here.
#+END_info

{{{commit}}}


#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. Size of assignment: Are all use cases in the first iteration from the Implementation Plan described?
2. Are the preconditions relevant?
3. Is it a reasonable main course of events?
4. Does the main course of events end successfully?
5. Does the alternative flow of events cover the obvious ways in which the use case can fail or take an alternate route?
#+END_tip

*** Assignment Submission

    {{{submit}}}
    
    Your submission shall include the following documents:
    - (*PA1415*) User Stories
    - Overview of Use Cases
    - Implementation Plan
    - Detailed Use Cases for First Iteration
*** Update Course Backlog
    How do you design a system from your use cases? What should you look for when you are trying to understand the structure of your system? What about the behaviour of the system?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have created an "Overview of Use Cases" document
   - You have created an "Implementation Plan" document
   - You have created a "Detailed Use Cases for First Iteration" document
   - You have committed/pushed these documents to your project repository
   - [[./org/checked.png]] You have submitted the documents for marking.
   - [[./org/checked.png]] *PA1415* You have also included the "User Stories" document in your submission.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Written self-study Use Cases
   - As self-study played planning poker.
* Sprint: Concepts and Events					   :noexport:
** About This Sprint
   This sprint introduces a system analysis view of the real world, and describes how to use the UML use cases as a means for finding out what is relevant to model from the real world for the system you are designing.
** User Stories covered in this Sprint
   - As a software designer I want to document my understanding of the problem domain so that I can easily transform this into an object oriented software system.
   - As a software designer I want to understand how users plan on interacting with the system so that I can design the right API endpoints.
   - As a product manager I want to make sure that fixed bugs do not re-appear so that I can build the product incrementally.
** Introduction
   A large part of the allure of object oriented programming is because it so closely mimics the real world. We are used to seeing objects around us, and are used to viewing objects in terms of what we can do to them. Another important realisation in object oriented programming is the notion that /each/ object in the real world may carry its own /state/. The state of a real world object may be many things such as its position, its owner, its colour(s), whether it is whole or broken, how it is broken, and so on. But ultimately all of these properties of one object are unique for that particular object, and we do not expect it to be in any other way. Before object oriented programming, this was quite a challenge to achieve in a programming language.

# You might, for example, have separate arrays for each property and then you might indicate one object as one particular index (so that the state of object ~obj:=4~ is ~APosition[obj]~ and ~AOwner[obj]~ and ~AColour[obj]~ and so on). A relational database is built upon the same principles even if you put all the data of one object into one row, but you focus on one column (which is of a specific type) at a time.

   Object oriented programming enabled software developers to analyse problems in terms of the involved real world entities, or /Concepts/. This shortens the gap between the software you write and the domain you are representing with this software, since concepts in the real world have a corresponding software representation. If the real world concept can do a certain thing or has a certain property, your software representation should probably also be able to do this functionality or or have this property.

   The inverse is not necessarily true, though. You will be adding stuff to your software representations just to make them work together as a /software/ system, and this stuff need not have a corresponding real world representation. A real world rucksack does for example not have any need for an ~std::set<Junk>~, and ~Swiper~ does not need to be aware that he can form a relation to the rucksack before he actually steals it.

   [[./images/IDora-Backpack.jpg]]

*** Concepts, Classes and Objects
   An important starting point for building an object oriented system is thus to look at the real world and see what objects there are. From these objects we try to find out what common types they belong to (I will refrain from an excursion to [[https://en.wikipedia.org/wiki/Theory_of_Forms][Plato and his idea-world]]). Those are the /Concepts/ that we should model.

   We then look for relations between the concepts and describe them as clearly as we can. These relations will help us later on when we see how concepts (or objects) interact with each other to solve a particular task. This also helps when we decide on the scope of the product, i.e. when we decide what is within what the system should do, and what is outside of what the system should do.

   Concepts may have attributes, or properties. For example a ~Person~ may have a ~name~, and an ~address~. We add those too.

   Concepts are /similar/ to Classes as you are used to them in programming, *but they are not the same!* As stated earlier, a class contains all sorts of methods and attributes that have to do with being a /software/ entity (such as a ~print()~ method, well defined types of all the attributes, collections of relations to other classes, etc. A Concept, on the other hand, should focus solely on the concepts, attributes, and relations that exist in the /real world/.

   Similarly to classes, a concept can be seen as the archetype of a set of objects. For example, if you have a Volvo 244, a Ford Fiesta, and a Wolkswagen Golf, these are /examples/ of the concept ~Car~. If you construct software to, say, keep track of these cars, you may also have a class ~Car~, with the /instances/ ~Volvo244:Car~, ~FordFiesta:Car~, and ~VWGolf:Car~. Of course it will be impractical to keep track of the instances, or objects, like this so you may instead have a ~carArray:Car[]~ or a ~std::set<car>~ to maintain your collection of cars. This would also mean that the car brands will need to be represented as attributes of the car instead of encoded in the name of the software variable:

#+BEGIN_SRC cpp
std::set<Car*> myCars;
myCars.insert(new Car("Volvo 244"));
myCars.insert(new Car("Ford Fiesta"));
myCars.insert(new Car("VolksWagen Golf"));
#+END_SRC

   Because of the similarities to classes there is no need to invent a new type of diagram for the conceptual model. Instead, you will re-use the notation for a /Class Diagram/ to model your concepts, their relations, and their attributes.

   As you continue with your analysis, you will learn more about the domain and the concepts in the domain, and will be adding this new knowledge into your conceptual model so that you eventually have a head start on creating your class diagram (but I get ahead of myself: We're not there yet).

*** Don't bite off more than you can chew!
    Remember that this is still early days. You have just started coming to grips with what you should be doing and, above all, /you have not produced a single thing which has any value to the customer yet!/ Therefore you should not try to model the whole world and /all/ the concepts in the world. You should stick to the immediate problem domain (which is why we also refer to the conceptual model as a /Domain Model/).

    [[./images/ILasse-Spade.jpg]]

    What's more, your requirements will change, you will change how you perceive the domain, and you will learn and want to add more as you go along. Even worse, if you try to model everything and everything perfectly, you will be bogged down in this step forever in a form of writers' block, which does not deliver value to the customer.

    The solution and the agile way is thus to /only model what is immediately useful for you/. This sounds like simple advice, but what /is/ immediately useful?

    A good starting point is your UML use cases. The use cases you have selected for the current iteration represent a subset of the complete domain, and are a reasonaby good place to start. The use cases contains plenty of information about different domain concepts and how users interact with them, and so will give you a good starting point. Going through category lists of common types of concepts you can also easily find such concepts from your use cases.

    Personally, I would also suggest that you look ahead a little so that you are at least /aware/ of what you are going to do in the coming iterations as well, so that you don't paint yourself into a corner. But that's probably just me being stuck in a plan-driven design philosophy.
*** Events and System Events
    Another thing which we get from the use cases is our API endpoints. Of all the things that a user may do around the system, what does actually the system have to react to? We call those things /System Events/. Since they may come in a particular order, we can view them as a sequence of system events, and this we model in a /System Sequence Diagram/.

    Consider the following course of events from a UML use case:

    | User                           | System                                                              |
    |--------------------------------+---------------------------------------------------------------------|
    | 1. User approaches replicator. | 2. System bleeps friendlily.                                        |
    | 3. User orders Tea.            | 4. System asks "which flavour?"                                     |
    | 5. User decides "Earl Grey"    | 6. System asks "what temperature?"                                  |
    | 7. User decides "Hot!"         | 8. System bleeps acknowledgingly and delivers the ordered beverage. |

    The system events we may generate from this are:
    - initiateTransaction()
    - orderBeverage("Tea")
    - setFlavour("Earl Grey")
    - setTemperature("Hot!")

    Notice that we express these events as method calls. Also note that the order matters. "Hot Earl Grey Tea" will, in this system, not work.

    Expressing this in a system sequence diagram:

#+BEGIN_SRC plantuml :file images/FTeaSSD.png
hide footbox
title System Sequence Diagram: User Orders Tea
actor User
participant ":System" as sys

User->sys : initiateTransaction()
sys-->User : <friendly bleep>
User->sys : orderBeverage("Tea")
sys-->User : request flavour
User->sys : setFlavour("Earl Grey")
sys-->User : request temperature
User->sys : setTemperature("Hot!")
sys-->User : <acknowledging bleep>
#+END_SRC

#+NAME: fig:SSDTea
#+CAPTION: System Sequence Diagram
#+RESULTS:
[[file:images/FTeaSSD.png]]

#+BEGIN_note
  In a System Sequence Diagram we are viewing the system as a /black box/. We put things into the box, and stuff comes out, but we have no clue what's going on inside. That's why we only model actors external to the system and the system itself. We do not open up the ~:System~ box to see what's going on inside, but are only interested in events to and from the system as a whole.
#+END_note

    We will come back to /Sequence Diagrams/ later, where we use the same notation to express what's going on /inside/ the system.
*** Attaching a User Interface
    So what's the point of expressing this as method calls? We're still just doing analysis, aren't we?
    
    First, there is no clear-cut line where we can say "this is analysis and that is design". As you learn more about the problem and the problem domain you begin to realise not only /what/ you should build but also /how/ to build it, and so you will be moving into a design space. But you will just as quickly realise that you need more information, and will go back to analysing the problem. Object-oriented software design is very much this movement back and forth between problem analysis and solution design, made easy in particular because of the intentional similarity between the real world and the paradigm of modelling the /objects/ in the real world.

    Second, by modelling the system events as method calls we are creating a powerful entry point for our system. I will need to diverge a bit into software architecture in order to explain this further. Please bear with me. Almost all applications with some form of user interaction can be split into three parts, or /layers/:

#+BEGIN_SRC ditaa :file ./images/FLayered.png
  +--------------------------+
  |  User Interface          |
  |                cBLU      |
  +--------------------------+

  +--------------------------+
  |  Application Logic       |
  |                cGRE      |
  |                          |
  +--------------------------+

  +--------------------------+
  |  Storage                 |
  |                cBLU      |
  +--------------------------+
#+END_SRC

#+NAME: fig:Layered
#+CAPTION: Layered Architecture Style
#+RESULTS:
[[file:./images/FLayered.png]]


    Each layer has an API, a set of methods which we can call to access it. In the case of the user interface, this may consist of buttons and text boxes, but if you are creating a web application, it may also include the API endpoints such as ~https://www.your.server/User/userid~ to access the User profile for ~userid~, as well as landing pages for your [[http://www.w3schools.com/ajax/][AJAX]] calls. The point is that you only focus on the interface of the layer you are going to connect to. So if you are an end-user, you only need to worry about the user interface. If you "are" a user interface, you only need to worry about the API for the Application Logic Layer.

#+BEGIN_info
    For the Application Logic layer, the methods in the API are the system events from your System Sequence Diagram.
#+END_info

    This is what makes it so useful that you have already modelled them as method calls. You have now also documented your API; the methods you may call, the system responses, and the order (if any) that the methods must be called.

    Moreover, you have done this without having decided how you are going to build your user interface. You are still free to write a desktop GUI application, a mobile phone app (where you have still left the choice open between IOS and Android -- at least in theory), or a web application. You may even write your GUI in something esoteric like [[https://unity3d.com/][Unity]], and your system sequence diagrams would still look the same.
*** Testing
    In this sprint, we have introduced two new models; domain models and system sequence diagrams. Both of these are useful for testing purposes. The domain model shows you how you think the /problem domain/ functions. When constructing your tests, this is a better starting point than what you eventually end up implementing. More importantly, the domain model divides your problem domain into smaller entities, /concepts/, that are possible to /unit test/. Later on, you can combine your already tested units and run /integration tests/ to make sure the units work together.

    Your system sequence diagrams tell you what API endpoints you have in the system. These are an excellent starting point for writing your regression tests. Consider the Layered architecture model in Figure [[fig:Layered]] once more. Remember that we specified the API for the Application Logic in the System Sequence Diagram? So why not just "push" the user interface to one side and attach a testing interface there instead? Why not indeed.

#+BEGIN_SRC ditaa :file ./images/FSSDTest.png
  +------------+--------------+
  | User  cBLU | Testing  cBLU|
  | Interface  | Interface    |
  +------------+--------------+

  +---------------------------+ 
  |System Sequence Diagram API|
  | c7CC                      |
  +---------------------------+ 
  |  Application Logic        |
  |                           |
  |                cGRE       |
  +---------------------------+
                            
  +---------------------------+
  |  Storage                  |
  |                 cBLU      |
  +---------------------------+
#+END_SRC

#+NAME: fig:SSDTest
#+CAPTION: Adding a Testing Interface to the Layered Architecture
#+RESULTS:
[[file:./images/FSSDTest.png]]

In one go you have enabled automated testing of your application. Technically, you can (and should) do this on top of the user interface too, but this is easier to get in place.

*** Summary
We are thus able to start building a chain of analysis efforts and UML diagrams, where what we learn in one diagram is put to use when creating the next one, as illustrated in Figure [[fig:DesignChainSSD]]. Of course, this chain is equally valuable going backwards: In order to find out more about a particular test case and why it is written the way it is, you go back to the UML use case. If this is not enough, you look at the involved requirements, or -- via the requirements -- contact the original source of the requirement to ask further questions.

#+BEGIN_SRC dot :file ./images/FDesignChainSSD.png
digraph {
 splines=true;
 node [style=filled,fillcolor="/greens3/2"];
 "Software Requirements" -> "UML Use Cases" [label=" Requirements in a Context"]
 "UML Use Cases" -> "UML Domain Model" [label=" Mapping of the Problem Domain"]
 "UML Use Cases" -> "UML System Sequence Diagram" [label=" System Events, in Order"]
 "UML System Sequence Diagram" -> "Test Specification" [label=" System Events to Test"]
 "UML Domain Model" -> "Test Specification" [label=" Domain Units to Test"]

// Have not yet come to these nodes, so paint them in a different colour.
// Or wait with them altogether
/*
 "UML Domain Model" -> "Class Diagram" [label=" Early Ideas of what to Implement",style=dotted]
 "UML System Sequence Diagram" -> "Interaction Diagram" [label=" Resolving System Event"]
 "Class Diagram" [fillcolor="/greens3/1"]
 "Interaction Diagram" [fillcolor="/greens3/1"]
 "Class Diagram" -> "Interaction Diagram" [label=" Involved Classes"]
*/
}
#+END_SRC

#+NAME: fig:DesignChainSSD
#+CAPTION: A Chain of Design Elements.
#+RESULTS:
[[file:./images/FDesignChainSSD.png]]

** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      8. [@8] Iteration 1 -- Basics
      9. Domain Models
      10. System Sequence Diagrams
*** Screencasts
    - [[https://play.bth.se/media/Concept+and+Classes/1_m237spjq/41750261][Concepts and Classes]]
    - [[https://play.bth.se/media/SystemSequenceDiagrams.mp4/1_99i0cfv7/41750261][System Sequence Diagrams]]
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[http://steve-yegge.blogspot.se/2006/03/execution-in-kingdom-of-nouns.html][Execution in the Kingdom of Nouns (Steve Yegge)]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Concept
    - Class
    - Instance
    - Object
    - Object state
    - Class Diagram
    - Domain Model (Also: Conceptual Model)
    - System Sequence Diagram
    - System Event
    - Black Box
    - Software Architecture
      - Layered Software Architecture
      - Model-View-Controller Software Architecture
      - Pipes-and-Filters Software Architecture
    - Unit Testing
    - Regression Testing
    - Integration Testing

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment: Domain Model
    Create a UML Domain Model from the UML Use Cases you have selected for your first iteration. Remember that those should represent a minimum viable product and so you ought to exercise the most important concepts based on these use cases.


    {{{tasks}}}
    1. Start with a domain model based on your understanding of the involved use cases.
    2. Chapters 9.5 to 9.13 in {{{larman}}} provides guidelines for how to find domain concepts. Apply each of these guidelines in turn, and /document/ what you find through each guideline.
    3. Add associations between your concepts (use the guidelines in chapters 9.14 in {{{larman}}}) with names and (where applicable) roles. Add multiplicity indicators where they are obvious, but do not go overboard with this.


#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Domain Model)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Initial Domain Model

   Your initial model before you apply the guidelines from {{{larman}}}. Use the UML Class Diagram notation for your Domain Model.

4. Guidelines Applied

   List each guideline and the concepts you identify with the help of this guideline. Keep this simple but easy to read. For example, a table may work nicely:

   Guideline:Use a Category List
   | Category              | Identified Concepts |
   |-----------------------+---------------------|
   | Business Transactions | VogonPoetry         |
   | Product or Service    | Tea, Doughnut Hole  |
   |-----------------------+---------------------|

5. Completed Domain Model

   Add the concepts identified through the guidelines to your initial domain model and present it here. Add associations, association names, association roles, and multiplicity. *Note* that you may also have attributes in your concepts.

   Use the UML Class Diagram notation for your Domain Model.
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. Size of assignment: Does the domain model contain 20-30 domain concepts
2. Are all concepts and associations modelled correctly
3. Do all associations have relevant names
4. Where applicable: Are the roles involved in associations specified and corect
5. Where applicable: Are multiplicity indicators used correctly
#+END_tip
*** Assignment: System Sequence Diagrams
    Create UML System Sequence Diagrams from your UML Use Cases in your first iteration. Create one System Sequence Diagram for each Use Case.

    {{{tasks}}}
    1. For each Use Case, create one System Sequence Diagram.
    2. Add the ~:System~, and all involved Actors.
    3. Identify the system events from the use case, name the corresponding method call, and add it to your system sequence diagram from the right actor to the ~:System~
    4. Add return messages from the ~:System~ to the actors.
    5. Add loops if applicable.

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(System Sequence Diagrams)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] System Sequence Diagrams
   - System Sequence Diagram for Use Case <name 1>
   - System Sequence Diagram for Use Case <name 2>
   - System Sequence Diagram for Use Case <name ... >
   - System Sequence Diagram for Use Case <name n>
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. size of assignment: Do all Use Cases in Iteration 1 have a corresponding System Sequence Diagram
2. Are all actors in each use case represented in the system sequece diagrams
3. Is the system treated as a black box
4. Do all system events in each use case have a corresponding system event in the same order as in the use case
5. Are the system events aptly named
6. Are the return messages from the system sufficiently descriptive
7. Is the loop construct used correctly
#+END_tip
*** Update Course Backlog
    What's the next step? What do you need to do in order to understand how to implement the system based on your system sequence diagrams?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have created the Domain Model document
   - You have created the System Sequence Diagram document
   - You have committed/pushed these documents to your project repository

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* TODO Sprint: Testing						   :noexport:
** About This Sprint
   In this sprint we momentarily pause the steady onmarch of UML and instead focus on how to test the designed software.
** User Stories covered in this Sprint
   - As a product manager I want to make sure that we are building software of high quality.
   - As a product manager I want to make sure that fixed bugs do not re-appear so that I can build the product incrementally.
** Introduction
   This introduction is partially written with the help of my honourable esteemed colleague Dr. Simon Poulding. And when I say "partially" I mean that substantial parts of this introduction consists of texts that he has written and that I have creatively borrowed, brutally slaughtered, and put back into a different order. Not necessarily better, but different.

   I guess that all of you have heard of the importance of testing your code by now. The sad story is that many professional software developers have still only heard of the importance but not seen it in practice. In many cases, testing is something you tack on at the end of a project if there is time. Of course, since there never is time left at the end of a project, you ship the code and let the customers discover the faults instead. The situation has gotten better, but it is still not good. That's why I want to raise the topic already now in the course.

   One of the reasons for why testing is considered a time consuming activity is because you are doing manual testing. You have test protocols, you have dedicated testers who follow these protocols and conduct certain actions with the application in a certain order, and document the results. Obviously, we can do better than this. If we are testing the user interface, there are test harnesses for this that simulates button clicks, enters text into text boxes, and compares the end state of the user interface with images of predefined end states, etc (Actually, you might want to study the work of another colleague of mine, Emil Alégroth, on this particular topic).

   But even if we decide not to do automated testing of the user interface, we can attach a test harness that pretends to be the user interface.

#+NAME: fig:TestInterface
#+CAPTION: A Testing Interface sitting next to the User Interface, acting like an alternative user interface.
[[./images/FSSDTest.png]]

Digging even further, we can use testing frameworks that intergate with our development environment. [[http://junit.org/][JUnit]] is one example of this when plugged in to Eclipse. You can also run JUnit as a standalone application, which may sometimes have some advantages. It's nice and all to see the results of testing directly in your IDE, but you will also want to run these tests headlessly on an automated build server.

*** Types of Testing
Which tool or method to use depends very much on what the intentions are of your testing. L. Crispin and J. Gregory [fn:Crispin] introduce four quadrants of (agile) testing that describes the types of testing that one may be doing (see Figure [[fig:TestQuadrants]]).

#+BEGIN_SRC ditaa :file ./images/FTestQuadrants.png
                            Business Facing 

             +---------------------+------------------------+
             | Functional Tests    | Exploratory Testing    |
             | Examples            | Scenarios              | 
   Supporting| Story Tests         | Usability Testing      | Critique
   the       | Prototypes          | User Acceptance Testing| Product
   Team      | Simulations         | Alpha/Beta             |
             |                cGRE | cGRE                   |
             +---------------------+------------------------+
             | Unit Tests          | Performance and Load   |
             | Component Tests     |   Testing              |
             |                     | Security Testing       |
             |                     | "ility Testing"        |
             |                     |                        |
             |                cGRE | cGRE                   |
             +---------------------+------------------------+
 
                          Technology Facing
#+END_SRC

#+NAME: fig:TestQuadrants
#+CAPTION: Agile Testing Quadrants (Adapted from Crispin & Gregory 2009)
#+RESULTS:
[[file:./images/FTestQuadrants.png]]

*Technology Facing & Supporting the Team (lower left quadrant)*
This quadrant represents testing defined by the programmers that verifies the functionality of
individual units or components in the system in order to ensure the internal code quality.
In many agile practices, this type of testing plays a central role through the technique of test-driven
development (TDD). In TDD, the developer writes a test for a piece of functionality, and then
develops the code to pass that test. More on this later.

*Business Facing & Supporting the Team (upper left quadrant)*
This quadrant considers testing that in contrast to unit/component testing considers
functionality at a higher level such that it is meaningful to the customer, and with the purpose of
demonstrating that the functional behaviour of the system is consistent with the
requirements.

The tests in this quadrant may be derived from the user stories and examples provided by the
customer team. Crispin and Gregory avoid the use of "acceptance test" that is often used for these
types of tests on the basis that tests in other quadrants may also be used for this purpose.
In addition, Crispin and Gregory consider prototypes etc. used as part of the dialogue with the
customer to belong to this quadrant -- even mock-ups of, for example, a GUI on paper.

*Business Facing & Critique Product (upper right quadrant)*
This quadrant encompasses manual testing that ensures that the system is really what the
customer wants rather than simply meeting the team’s understanding of what the customer
requires. Crispin and Gregory argue that exploratory testing -- unscripted and unconstrained
testing guided by strategy and experience -- is a core form of testing in this quadrant.

*Technology Facing & Critique Product (lower right quadrant)*
This quadrant considers types of tests related to non-functional aspects of the system such as
security, performance, ability to handle load, scalability, reliability, safety, maintainability,
interoperability etc.

We are not going to go through all of these types of testing strategies in this course, but it gives you a map to understand how your selected test strategies fit together and what you ought to do to produce a sufficient test strategy for your project.

[[./images/IUnitVsIntegration.gif]]

[fn:Crispin] Lisa Crispin, Janet Gregory, "Agile Testing -- A Practical Guide for Testers and Agile Teams", Pearson Education, 2009.

*** Regression Testing
    The lower half of Crispin & Gregory's testing quadrants are particularly interesting because we are able to introduce /regression testing/. What this means is that we have a large set of test cases that we are able to execute automatically, for example daily or after each commit. The main benefit of this is that it instills confidence in the developers that what they just produced didn't accidentally break something else.

    I once attended a seminar with Prof. Hans van Vliet where he asked us "what do you think takes the most time in software maintenance?"
    - Understanding what the problem is
    - Understanding where to fix the problem
    - Understanding how to fix the problem
    - Understanding the cascade effects of fixing the problem.

      [[./images/IRipple.jpg]]

    If you guessed "understanding the cascade effects" you guessed right, but that is slowly changing with the advent of tools for automated testing and development practices such as /Test Driven Development (TDD)/, but also by modern behaviour-driven test frameworks such as [[https://cucumber.io/][Cucumber]]. The common denominator for these frameworks is that you write your tests early, and in executable format so that you can quickly re-run them. TDD takes it one step further with its very fast red-green-refactor cycle (basically write /one/ line of tests that fails, then write the (small) code to pass, and then shape it up and put it in the right place etc.). Connect this back to Prof. van Vleet's question: You no longer need to understand the cascade effects because you have tests in place that will start failing.

*** Tools for Automated Testing
    Which tool to use for your automated testing is of course highly dependent on your choice of development platform, and you also need to work on different levels, as illustrated in Figure [[fig:TestingLevels]]. In this figure, the left-hand-side is what you would normally encounter during a build cycle, and this is also the parts where you can hope to automate. In fact, the only difference between testing "Inside the IDE" down to "Nightly Builds" is that you will run more test-cases during your nightlies than in the IDE, where you may focus only on the tests that are relevant for what you are doing right now. You will use the same testing tools.

#+BEGIN_SRC ditaa :file ./images/FTestingLevels.png
  +------------------------------+  +-------------------------------+
  | Inside the IDE               |  | Usability Testing             |
  |               c7CC           |  | Acceptance Testing            |
  +------------------------------+  |                               |
  | As part of Compile-cycle     |  |                               |
  |                         cBLU |  |                        cGRE   |
  +------------------------------+  +-------------------------------+

  +------------------------------+  +-------------------------------+
  | Regression Tests             |  | "Release Hardening"           |
  | During Commit           cBLU |  |                               |
  +------------------------------+  |                               |
  | Nightly Builds               |  |                               |
  |                         cBLU |  |                        cGRE   |
  +------------------------------+  +-------------------------------+
#+END_SRC

#+NAME: fig:TestingLevels
#+CAPTION: Testing on different Levels
#+RESULTS:
[[file:./images/FTestingLevels.png]]

What /will/ differ, however, is the framework within which your tests are running. Obviously, if your tests are run on-the-fly in your IDE, this needs to be supported. Testing as part of the compilation cycle rarely requires much in terms of extra frameworks. For example [[https://www.gnu.org/software/make/][make]], [[https://cmake.org/][cmake]], [[http://ant.apache.org/][Ant]], and [[https://maven.apache.org/][Maven]] are all capable of running your test suites according to your wishes, on your machine.

... But what if your machine environment is not the environment in which your system is intended to run? Well, then you need to set up a virtual machine (or a collection of machines if your deployment environment is more complex) to run the tests on. [[https://www.virtualbox.org/][VirtualBox]] together with [[https://www.vagrantup.com/][Vagrant]] have helped me on more than one occasion with this.

Further down the stack, you want tools that can set up these virtual machines, download your code, build it, and run tests all in one go, e.g. when you do a commit. [[https://jenkins.io/][Jenkins]] is a popular choice for this, if you have access to your own servers. For open source projects, [[https://travis-ci.org/getting_started][Travis CI]] is an ok choice. I think they have some limit to 100 builds or so before you have to start paying, though. Jenkins and Travis work on a slightly different philosophy. In Jenkins you set up the project and the build steps through an admin interface on the Jenkins server. In Travis you create a build script as part of your repository. For raisins, I am partial to the latter, and have recently been exploring [[https://drone.io/][Drone.io]] as a means to set up my own build server that works like Travis with a repository-based build script.

But I digress.

Backing up to the original topic, you will need to find an automated testing tool suitable for your programming language and your development environment. I list some tools below just to get you started.

- Java: [[http://junit.org/][JUnit]]
- Node.js (JavaScript): [[https://mochajs.org/][Mocha]] or [[http://jasmine.github.io/][Jasmine]]
- JavaScript/JQuery (client side): [[https://qunitjs.com/][QUnit]]
- C++, See e.g. the article [[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle][Exploring the C++ Unit Testing Framework Jungle]] for a good discussion of some test frameworks, and what you should require from them
- Emacs Lisp: [[https://www.gnu.org/software/emacs/manual/ert.html][ERT]]
- Or you can go to [[https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks][Wikipedia and see even more choices]]
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
        21. [@21] Test-Driven Development and Refactoring	    
*** TODO Screencasts						   :noexport:
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html][The Cycles of TDD, by R.C. Martin]]
    - [[http://www.jamesshore.com/Blog/Microsoft-Gets-TDD-Completely-Wrong.html][Microsoft Gets TDD Completely Wrong, by James Shore]] (Note: This article is not Microsoft bashing\trade -- they are only one among many to get it wrong)
    - [[https://groups.yahoo.com/neo/groups/extremeprogramming/conversations/topics/111829][Guidelines for Unit Tests, by Michael Feathers]]
    - [[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle][Exploring the C++ Unit Testing Framework Jungle, by Noel Llopis]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Unit Testing
    - Exploratory Testing
    - Automated Testing
    - Regression Testing
    - Test Driven Development (TDD)
    - Automated Test Frameworks
    - Continuous Integration

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment: Create Test Suite
      Create a regression test suite. You will continue to use and extend this test suite later in the course. At this stage, you are focussing on adding test cases for your API endpoints. Use the system events from your System Sequence Diagrams as API endpoints, and express the tests in your chosen test framework. 

      {{{tasks}}}
      1. List all the system events from all the system sequence diagrams.
      2. For each system event, identify preconditions (e.g. if the system event depends on that another event is triggered first).
      3. For each system event, identify what inputs are allowed.
      4. For each system event, identify what outputs are expected.
      5. For each system event, Write one or several test in your test framework that tests for the allowed inputs and the expected outputs.
	 
      {{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

1. size of assignment: Are there test cases for all system events from all the system sequence diagrams?
2. For each test case: Does it test normal input as well as explore boundary values?
3. For each test case: Does the test case evaluate a meaningful behaviour?
#+END_tip    
*** Update Course Backlog
    How do can you come to an understanding of what the system needs to to as a response to a system event? What will change in the system, and how?
    Are there meaningful tests you can do for your UML documentation? How would you automate this?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You bave created an automated test suite for your API endpoints
   - You have committed/pushed this suite to your project repository

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Set up a continuous integration solution to run your tests on commit   
* Sprint: State Diagram						   :noexport:
** About This Sprint
   In this sprint we study a design tool to help you understand stateful behaviour in your applications.
** User Stories covered in this Sprint
   - As a software designer I want to document the states the application can be in so that I can better design them and get an overview of permissible transitions.
** Introduction
   For some applications, or for certain parts of some applications, it is meaningful to study the /states/ your application can be in. Usually, your application may be in one state and have specific rules for when you can transition to another state.

   For example, if you come here by train, you probably have a several different states:
   - /Walking/ to the train station
   - /Waiting/ for the train
   - /Walking in the Train/ to find a seat
   - /Sitting/ in the train
   - /Walking/ from your seat, out of the train, and up the hill to the Uni.

   It was tempting to also add "Entering the train", and "Exiting the train", but this would not be a good idea since these are more akin to /Events/ than /States/. Incidentally, this is what most students get wrong in a state chart -- they mix up what is a state and what is an event.

   When you are walking to the train station, what may change your state to something else? If you see the train coming (this is an event), you may need to switch to the state

   - /Running/ to the train station

   When you are waiting for the train, you can obviously not enter the train and start looking for a seat unless the train arrives (this is also an event).

   When you are sitting on the train, /arriving at a station/ is an event that /could/ trigger a transition to the "walking from your seat and to the uni" state, but only if you have arrived at the right station. This is a /condition/ for the arrive at station event.

   Enough dry talk. Let's put this into a UML State Diagram:

#+BEGIN_SRC plantuml :file ./images/FStateTrain.png
state "Walking to Train" as wtt
state "Running to Train" as rtt
state "Waiting for Train" as wft
state "Looking for Seat" as lfs
state "Sitting in Train" as sit
state "Walking to Uni" as wtu

[*]-> wtt
wtt-->rtt : Sees Train
wtt-->wft : Arrives at Station
wft-->lfs : Train Arrives [train==right train]
rtt-->lfs : [train==right train]
lfs-->sit : Seat Found
sit-->wtu : Train Arrives at Station [station==right station]
wtu->[*]
#+END_SRC

#+NAME: fig:StateTrain
#+CAPTION: A UML State Diagram for Catching a Train
#+RESULTS:
[[file:./images/FStateTrain.png]]

You may not model your entire application as a state chart. In fact, you may not need to model it at all. Also, you may have several state charts that are not connected to each other (other than that they logically must be solvable in the same system).

State charts are tricky. On one hand, they are a useful tool to visualise dynamic behaviour and to think about your system in terms of states and events. On the other hand, they don't really fit in with the other UML diagrams. Here's a list of questions I would like you to think about for a while. We may come back to these questions during a lecture, sinnce in order to understand the answers you also need to understand a lot more about software design:

- Are state diagrams an analysis tool, or are they a design tool?
- Can you get the states from a UML use case?
- Can you express the same in a state diagram as in a (system) sequence diagram? If so, what is the added value?
- Do you learn anything about what classes or what interactions between classes you need in your system from a state diagram?

This sprint is smaller than many of the others because -- as you notice -- state diagrams are difficult to pin down. Rather than bundling State Diagrams with something else it makes more sense to keep them separate so that I may include the sprint in different parts of the course flow. Having said this, state charts are probably one of the older modelling techniques, and there is actually quite a lot written about different types of state charts and their cousin [[http://www.scholarpedia.org/article/Petri_net][Petri Nets]].
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      29. [@29] UML State Machine Diagrams
*** Screencasts
   - [[https://play.bth.se/media/StateDiagrams.mp4/1_ruht53d3][State Diagrams]]
*** TODO Lectures						   :noexport:
*** Further Reading						   :noexport:
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - State Diagram (also: State Chart)

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Self-Study: Stateful Application
    Find a software application or a software game where you can easily identify different states. Try to model this in a state diagram.
*** Assignment: Stateful Behaviour
    Is there any behaviour in your assignment system that exhibits a meaningful stateful behaviour? If so, model it in one or more UML State Diagrams.
*** Update Course Backlog
    How can you design your software such that the /states/ are the central entity as opposed to the /concepts/?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have reviewed your application for stateful behaviour
   - You have optionally created UML State Diagrams for this behaviour.
   
   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Created one or more State Diagrams for different software applications.
* Sprint: Good Interactions					   :noexport:
** About This Sprint
   This sprint focus on how to identify what is a /good/ design through the use of basic object oriented principles.
** User Stories covered in this Sprint
   - As a software designer I want to create a design that adheres to basic design principles so that I am sure that it will "hold" when I add more functionality and start maintaining the system.
   - As a software designer I want to understand how to best design the interaction between objects so that I can create a robust and maintainable system.
** Introduction
   The ordering between this sprint and the next is a bit off. In the screencast for this sprint I am discussing the dynamic behaviour in terms of UML Interaction Diagrams and the static structure in terms of UML Class Diagrams even though these aren't introduced until the next sprint. I do this because I want to save you some work, and because I think you will be able to grok this sprint anyway. The alternative would be for you to first create early versions of all your interaction diagrams and class diagrams, then learn more about design principles to make them good, and then go back and revise them. That's not how you are supposed to work with these design principles. Object Oriented design principles are so deeply ingrained in how we do OO design that we rarely even think about them once we know them -- we just do. You will not list that "you have created class X according to design principle Y" anywhere, since it is expected that you have used all principles all the time (or have had a very good reason not to use them). Therefore, let's briefly discuss them first.

*** Fundamental Design Principles
   Some design principles have fancy names (you'll find them under Further Reading (Section [[GIFurtherReading]]), and they are often described one by one as if you can first apply one, then the next, and so on. In reality you work with all of them at once, and they are essentially different aspects of a few fundamental principles:

#+NAME: tab:FundamentalDesignPrinciples
#+CAPTION: Fundamental Design Principles
   | Principle                                     | Description                                                                                                                                    |
   |-----------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------|
   | Abstraction                                   | Focus on relevant properties                                                                                                                   |
   | Coupling and Cohesion                         | Independent entities, but where the internals are strongly related                                                                             |
   | Decomposition and Modularisation              | Small entities with well defined and non-overlapping functionalities or responsibilities                                                       |
   | Encapsulation                                 | Hide the internals so they are inaccessible from outside the entity                                                                            |
   | Separation of Interface and Implementation    | Separate the public interface from implementation details                                                                                      |
   | Sufficiently, Completeness, and Primitiveness | Keep entities as small as possible, but not smaller. Entities should capture all important characteristica of an abstraction but nothing more. |
   |-----------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------|


   To put this into the context of a single class, this means that a good class has:
   - A single, well-defined abstraction and well-defined responsibilities
     - Tip: Let classes distribute work to other classes
     - Tip: avoid "God Classes" that tries to do everything
   - Has low coupling to other classes
     - Tip: Minimise fan-out in a class
   - Has a sufficient and complete public interface to be able to access the behaviour and state relevant for the abstraction that the class models
   - Has a primitive public interface that does not expose anything more than necessary to the outside.
     - Tip: All data should be hidden within the class.
     - Tip: Do not clutter the public interface with items that users of that class are not interested in or able to use.
   - Has high cohesion (the methods and attributes belong strongly together)
     - Tip: Most of the methods defined on a class should be using most of the data in the class most of the time.
   
*** Responsibility Driven Design   
    These are just some of the principles for how to define classes. Under Further Reading (Section [[GIFurtherReading]]) I have listed some more. Luckily, many of these have also been expressed in a slightly more accessible way in the course book. Larman calls them GRASP patterns, and the idea is that when you are doing your design you always try to define the responsibilities of the involved objects and classes according to these GRASP patterns. This is why he also refers to them as /Responsibility Driven Design/. The patterns are listed on the inside of the book cover:

   - Information Expert
   - Creator
   - Controller
   - Low Coupling
   - High Cohesion
   - Polymorphism
   - Pure Fabrication
   - Indirection
   - Protected Variations

Make sure you understand the principles of each one of these. Think about how you may apply them in different settings. Discuss them with your classmates, and use the course discussion forum. How might they impact your design?   
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      17. [@17] GRASP: Designing Objects with Responsibilities
      18. Object Design Examples with GRASP
      25. [@25] GRASP More Objects with Responsibilities
*** Screencasts
  - [[https://play.bth.se/media/DesignPatterns_GRASP/1_e4z8gitx][GRASP Patterns]]
*** TODO Lectures						   :noexport:
*** Further Reading <<GIFurtherReading>>
    - [[https://en.wikipedia.org/wiki/Law_of_Demeter][Law of Demeter]]: Keep entities as ignorant as possible of other entities, don't let them talk to strangers.
    - [[https://en.wikipedia.org/wiki/Liskov_substitution_principle][Liskow Substitution Principle]]: Defines how sub- and supertypes can be used in each others place.
    - [[https://en.wikipedia.org/wiki/Open/closed_principle][Open/Closed Principle]]: Software Entities should be open for extensions but closed for modifications.
    - [[https://en.wikipedia.org/wiki/Dependency_inversion_principle][Dependency Inversion Principle]]: high-level (abstract) entities should not depend on more low-level (detailed) entities. Instead, the low-level entities should depend on the abstractions.
    - [[https://en.wikipedia.org/wiki/Interface_segregation_principle][Interface Segregation Principle]]: Prefer many smaller interfaces with well-defined roles instead of one big interface.
    - [[http://www.oodesign.com/single-responsibility-principle.html][Single Responsibility Principle]]: Let each class take care of one single responsibility. Split classes that do more than one thing.
    - [[https://en.wikipedia.org/wiki/Package_principles][Common Closure Principle]]: Coupling and cohesion for packages (as opposed to individual classes)
    - [[http://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface][Program to an Interface, not an Implementation]]: Define role-based interfaces and use these instead of "direct links" to the instantiated class. NOTE: Also read the "Wizards and Warriors" rant for a counter-argument.
    - [[https://ericlippert.com/2015/04/27/wizards-and-warriors-part-one/][Wizards and Warriors Part I]] [[https://ericlippert.com/2015/04/30/wizards-and-warriors-part-two/][Part II]] [[https://ericlippert.com/2015/05/04/wizards-and-warriors-part-three/][Part III]] [[https://ericlippert.com/2015/05/07/wizards-and-warriors-part-four/][Part IV]] [[https://ericlippert.com/2015/05/11/wizards-and-warriors-part-five/][Part V]]: Introduces the need for an [[https://en.wikipedia.org/wiki/Entity_component_system][Entity Component System (ECS)]], which is a common game design pattern since the normal inheritance practices break down.
    - [[https://en.wikipedia.org/wiki/Composition_over_inheritance][Favour Object Composition over Class Inheritance]]: The same pattern, with a different name.
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Abstraction
    - Coupling and Cohesion
    - Encapsulation
    - Code Refactoring
    - Design Principles
    - Design Patterns
    - Responsibility Driven Design
    - GRASP Patterns
      - Information Expert
      - Creator
      - Controller
      - Low Coupling
      - High Cohesion
      - Polymorphism
      - Pure Fabrication
      - Indirection
      - Protected Variations

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Self-Study: GRASP Patterns
    Use a small system that you know well, for exampe a Pacman game. Think about the GRASP patterns in the context of this game. For example:
    - Who is the /information expert/ on knowing the location of pacman on the game board?
    - Who /creates/ the ghosts?
    - Who takes care of input and orchestrates navigation in the main menu (controller)?
    - How should the ghosts be made aware of pacman's position so that you maintain low coupling and information expert?
    - How do you design the game board so that it still has high cohesion?
    - How does polymorphism work with the different ghosts?
    - etc.
*** Update Course Backlog
    Are there similar principles that can help you decide how a larger collection of classes can interact? How do you find the classes in the first place? How do you explore the interactions between objects?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have studied the Fundamental Design Principles and understood them
   - You have studied the GRASP patterns and understood them

   You may also have
   - Reflected upon the GRASP patterns in the context of a small, well-known system.
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* TODO Sprint: Interactions and Structure		:noexport:submission:
** About This Sprint
   This sprint discusses how to identify and model interactions between entities in UML interaction diagrams. The sprint also covers how the interaction diagrams produce material that is used to create UML Class Diagrams.
** User Stories covered in this Sprint
   - As a software designer I want to understand how domain concepts interact so that I can select the best way to implement these interactions.
   - As a software designer I want to model both the /dynamic behaviour/ as well as the /static structure/ of the application so that I can communicate both to the developers.
   - As a software implementer I want to know which methods and attributes each class contains so that I can implement them.
** Introduction
   So you have your system events from the UML system sequence diagrams, and you have an idea of the concepts in the problem domain based on your domain model. Your next step is to figure out what should happen inside the system as a consequence of your system events. UML books like to introduce the concept of an /Operation Contract/ at this stage, and spend an impressive amount of time defining all the attributes that you should fill in for each contract. I will not go this far. I will not even require you to write any contracts. As an /analysis tool/, they are quite ok, however.

The takeaway from this sprint is, however, not the actual diagrams. What I want you to realise is that modelling the dynamic behaviour of your system is the /key/ to understanding the static structure. This is the best way to keep your system lean. Yes, you can start with the static structure and model what you /think/ will be needed. You will (a) get much of it wrong and have to go back and fix it later, and (b) add plenty of stuff that will never be used as you thought, so you will add the methods you really need when you develop, and then your design documentation is no longer up to date with what the code does.

#+BEGIN_note
*TL;DR:* Use the /dynamic behaviour/ of your system to extract the least possible amount of /static structure/, to keep your design relevant and lean.
#+END_note

*** Contracts
    An operation contract simply documents the system operations. This is ok, and you should really think of doing something like this anyway. If you use e.g. [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]] or the equivalent for your language, you document your system operations in your code so that callers of a function immediately can get an overview of the operation, its parameters, and its return values.
    
    What I would like to focus on, however, is that in this documentation you also list /preconditions/ and -- even more importantly /postconditions/. The preconditions is simply a list of conditions that must be met before this operation can be called. For example, to return change in a cash machine, there must be an ongoing sale and a payment must have been entered.

    The postconditions list what should have happened /inside/ the system as a result of the operation. This is not a narrative description of "first A happens, then B, and finally C". It is simply a description of the final state. Think of it as a stage-and-curtain model. The system is in one state. A curtain goes down and the operation executes. When the curtain is raised again, you note the changes.

[[./images/ICurtainGoat.jpg]]

   To identify /what/ may have changed, you look at your domain model. Instances of some of the concepts from your domain model are involved in the operation (if not, your domain model is incomplete and should be revised). For these instances, the following may occur:

   - an instance of a concept may be created
   - an instance of a concept may be deleted
   - an attribute of an instance may change value
   - an association betwen two instances may be formed
   - an association betwen two instances may be broken

   It is good form to write this in past tense (to remind you that you are only describing what has already happened):

   - An instance of ~Goat~ with the name ~gHarry~ was created.
   - The (x,y) position of the goat ~gHarry~ was set to (10,4).
   - An instance of ~GoatFood~ with the name ~gf~ was created.
   - ~gf~ was associated with ~gHarry~.
   - The location of ~gf:GoatFood~ was set to the location of ~gHarry:Goat~'s mouth.

   Note that we still don't know /who/ does all of this. We can guess that it is in fact ~gHarry~ that fetches the ~gf:GoatFood~ and puts it in his mouth while going to stand at position (10,4), but we do not know. We also do not know what else may have happened. Where did ~gHarry~ find the food? Was there a clown quartet that rolled a wheelbarrow full of GoatFood on stage and fed it to ~gHarry~ while riding unicycles? Or did we initially create 500 animals on stage and used genetic algorithms to grow and breed on those that most looked like a goat with food in its mouth? We do not know.

   What we /do/ know is that those concepts from the domain model that were used in this contract (and all other contracts) are those that we should model as classes. The attributes that were changed should be added to those classes with the right types. The associations formed or broken should be modelled in our class diagram. We also have an end-state that we can work towards in our interaction diagrams.

#+HTML: <small><small><small><small><small><small><small><small><small>
This here is the specific point from where I am going to get exam answers using Goats in the most horrible ways imaginable. I know this, and yet I wrote this example. What the hell is wrong with me?
#+HTML: </small></small></small></small></small></small></small></small></small>

*** Interaction Diagrams
    UML introduces two types of Interaction diagrams, namely /Sequence Diagrams/ and /Collaboration Diagrams/. These express the same thing and so you can use either one. When I was once a young and budding student we only had collaboration diagrams, and for a long while I favoured them because you are able to express more in less space. These days, however, I prefer sequence diagrams because it is easier to follow the order in which operations should be called, and are overall clearer to get an overview of.

    You have already acquainted yourself with sequence diagrams in the form of /System Sequence Diagrams/. The difference to these is that in a sequence diagram there is no restriction to view the system as a black box, as you do in a system sequence diagram. Indeed, the whole point is to now open up your black box and study what is going on /inside/ the box. Identify which entities needs to be involved to solve the system event, which methods that should be called, and in what order.

#+BEGIN_SRC plantuml :file ./images/FSequenceTheatre.png
hide footbox
[-> ":TheatreStage" : action()
activate ":TheatreStage"
":TheatreStage" -> ":EvolutionManager" : getGoat()

activate ":EvolutionManager"
loop while not true goat

create ":Goat"
":EvolutionManager" --> ":Goat" : create()
":EvolutionManager" -> ":Goat" : whosAGoodGoat()
activate ":Goat"
note right : checking all relevant parameters of "Goatiness"
":Goat" --> ":EvolutionManager" : baaa!
deactivate ":Goat"
end
":EvolutionManager" -> ":TheatreStage" : return lastGoat
deactivate ":EvolutionManager"

":TheatreStage" -> ":Goat" : setPosition(10,2)
activate ":Goat"
deactivate ":Goat"

":TheatreStage" -> ":ActorContainer" : add(a)
activate ":ActorContainer"
deactivate ":ActorContainer"
deactivate ":TheatreStage"
#+END_SRC

#+NAME: fig:SequenceTheatre
#+CAPTION: This example is officially getting silly
#+RESULTS:
[[file:./images/FSequenceTheatre.png]]

    A collaboration diagram is perhaps easier to work with on a whiteboard; you can hold more lively discussions, add an object and an interaction arrow without having to re-draw your entire model. On paper, it is less space-consuming. The cost of this is, as stated, that it is more difficult to follow the order in which methods are being called. Consider the same Goat-on-Stage example again. Note how the iteration is merely represented as an asterix ~*~ after the calls involved, and how the nested calls from within the ~EvolutionManager::getGoat()~ call have sub-numbering (1.1 and 1.2, respectively). Imagine if you have a deeper nesting, say four or five levels down, and then try to keep track of whether "1.2.0.3.2" is executed before "1.2.1.3.1" or not.

#+BEGIN_SRC plantuml :file ./images/FCollaborationTheatre.png
left to right direction
object ":TheatreStage" as ts
object ":EvolutionManager" as em
object "g:Goat" as g
object ":ActorContainer" as ac

title :TheatreStage->action()

ts --> em : 1 g=getGoat()
em --> g : 1.1 create()*
em --> g : 1.2 response=whosAGoodGoat()*
ts --> g : 2. setPosition(10,2)
ts --> ac : 3. add(g)
#+END_SRC

#+NAME: fig:CollaborationTheatre
#+CAPTION: Evolving a Goat and Putting it on Stage.
#+RESULTS:
[[file:./images/FCollaborationTheatre.png]]


    One more thing to note here is that you are dealing with /objects/, i.e. instances of your classes or concepts. You are not modelling the platonic /idea/ of a Goat; you are modelling /one specific instance/ of a goat that is interacting with other specific instances. You are not exercising all methods available in a class; you are calling those specific methods that are needed to solve one particular system event, and you are doing this with the necessary concrete parameters.

#+BEGIN_note
Interaction Diagrams model specific /objects/ and their /specific interactions/.
#+END_note    

*** Class Diagrams
    From the interaction diagrams, that describe the dynamic behaviour of specific objects, we can now start to extract how the class declarations must look like. The methods that are called on an object are placed in the corresponding class of that object. The associations formed are added to the "owner" class of the association (Usually, it is fairly obvious which class should be the owner of an association. Otherwise, decide now and refactor later). Attributes are more difficult to find, since they are not really that prominent in an interaction diagram. If you have made an operation contract, you can get the (post-operation visibly changed) attributes therefrom, but otherwise you will have to guess a bit based on the methods and the responsibilities each object seem to have.

    I am loath to continue with the previous example but, in the interest of completeness, here goes. First, create the classes used in the example, and add the methods called on each class and the attributes I can guess at. Then, add the relations between classes where the objects call each other. I like to do it in a particular order, and I am revealing the source code for the UML Class Diagram below to show you this order. You are of course free to work in any order you prefer.

#+BEGIN_SRC plantuml :file ./images/FClassTheatre1.png :exports both
' Add Classes, methods, and attributes:
' --------------------
TheatreStage : +action()
EvolutionManager : +Goat getGoat()
EvolutionManager : -lastGoat
Goat : +whosAGoodGoat()
ActorContainer : +add(Actor theActor)
ActorContainer : -list<Actor> myActors


' Relations
' --------------------
TheatreStage - "1" EvolutionManager
EvolutionManager - "*" Goat
TheatreStage -- "1" Goat
TheatreStage -- "1" ActorContainer


' I have decided that Goat needs to be a sub-type of Actor
' This simplifies the ActorContainer to not worry about Goatiness,
' but does need to have a relation to "Actor"
' --------------------
Actor <|-- Goat
ActorContainer o-- "*" Actor
#+END_SRC

#+NAME: fig:ClassTheatre
#+CAPTION: Class Diagram for the Theatre Example
#+RESULTS:
[[file:./images/FClassTheatre1.png]]

As you also may notice, I am adding the class ~Actor~ and introducing an inheritance between ~Actor~ and ~Goat~, to keep the interface of the ~ActorContainer~ class clean. I am also adding visibility to the methods and attributes. For now, all methods appear to be public, and all attributes are private.

Also note that even though in the interaction diagram I store the returned ~Goat~ in the variable ~g~, this variable is only needed for the duration of the ~action()~ method and so does not get added to the class. In general, you should try to keep variables in an as limited scope as possible. If you only need them in a block, declare them inside that block. If you only need them in a method, declare them in that method. If you /must/ have them for as long as your object exist, then add them as attributes to the class. If you need them for as long as the system lives you are most likely doing things wrong, but you might consider making them ~static~ or adopt the ~<<Singleton>>~ pattern. If you need them even longer than that, put them in a database or in a file.

*** Moar Classes
    Preferrably I would like to stop now and put the rest into a separate sprint (and kill the Goat-example once and for all). However, this bit needs to be said, and it will actually help you in your diagrams so I need to put at least a small teaser here.

    Essentially, you now have all the tools necessary to do object oriented design. What we will focus on more in later sprints is how to use pre-existing solution templates and principles to make a /good/ design using the tools you already know after this sprint. There are, however, two major obstacles that we need to address first:
   
    1. You are creating a giant ball of mud, with all your classes thrown into a -- for all intents and purposes -- random order.
    2. You will soon not be able to fit all of your design onto one single paper.

    To expand on Obstacle #1; What is the significance of that ~TheatreStage~ is in the top left corner of Figure [[fig:ClassTheatre]]? What does it mean that ~Actor~ is at the bottom of the diagram? Of course, I have made this figure in [[http://plantuml.com/][plantUML]], which lays out the diagram in an order itself sees fit (since it uses [[http://www.graphviz.org/][GraphViz]] as its backend, the strategy it uses is to minimise the number of arches that needs to cross each other). But even if you are using a CASE tool that allows you to position your classes with absolute coordinates (like a normal drawing program does), there is no inherent semantic meaning in the position of a class.

    Enter the /UML Package Diagram/. In this diagram we take a high-level view of our system and try to define our system as a set of packages, where each package has a well-defined responsibility. We then sort our classes into these packages. This solves Obstacle #2, since we can now move some of the packages to a new page according to some logical principle. If your packages are still too big to fit, you are able to nest packages so that your packages contain more packages.

    To further address Obstacle #1, you also need to define the principles according to which you divide the system into packages. Very crudely, this is what you do in your /Software Architecture/. I say crudely, because there is much more than this to software architectures. For now, let's stick to one of the more common architecture styles, namely the /Layered/ architecture style, since this fits most interactive systems. In the layered architecture style you divide your system into three parts: User Interface, Application Logic, and Storage.

#+BEGIN_SRC plantuml :file ./images/FLayeredPackage.png
package "User Interface" {
MainWindow o- Dialogue1
}

package "Application Logic" {
package "Domain Logic" {
}

package "Technical Services" {
}
}

package "Storage" {
class DBInterface
}

"User Interface" -[hidden]- "Application Logic"
"Application Logic" -[hidden]- "Storage"
#+END_SRC

#+NAME: fig:LayeredPackageDiagram
#+CAPTION: An example of a Layered Architecture, expressed in an UML Package Diagram
#+RESULTS:
[[file:./images/FLayeredPackage.png]]

   The fact that I tack this on at the end of this sprint introduction may lure you into thinking that you /first/ do your class design and /then/ divide into packages. In fact, you have the overall packages in mind already before you start with the class diagram. To be more precise, you have the "Application Logic" layer in mind. The application logic layer is the layer that mostly contain your class representation of the concepts in your domain model. Since your analysis and your interaction diagrams mostly try to express the behaviour of your system in terms of the interaction between your domain concepts, it is hardly surprising that the class diagram thus derived deals mostly with the application logic needed to represent the problem domain.

   Because the focus right now is to determine what from your domain model is relevant for you to solve in your software application, and how to do it, you are not concerned at the moment with the pure software application aspects of the system. This includes the user interface, technical services (for example a key/value store, rule engines etc.), persistent storage facilities, etc.

   "But", an astute reader may think, "does this not just put us back to square one? We still have all our classes in one big package that won't fit on a single page". Yes it does. And no it doesn't, because you can (and you should) nest packages inside your packages. What you should do is thus to think about the high-level packages you have /inside/ your application logic/domain logic package.

#+BEGIN_note
*To Summarise:*
- Right now you will be focusing mostly on the Application Logic Layer
- Start by defining the high-level packages /inside/ the application logic layer
- Then study the dynamic behaviour of your system
- Identify the involved entities (classes), and add these to your class diagram to represent the static structure of your system, along with the methods, attributes, and associations you have identified as necessary.
- Allocate the identified classes to you packages.
- ...
- profit!
#+END_note
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      11. [@11] Operation Contracts
      13. [@13] Logical Architecture and UML Package Diagrams
      14. [@14] On to Object Design	  
      15. [@15] UML Interaction Diagrams
      16. UML Class Diagrams
      31. [@31] Domain Model Refinement
*** TODO Screencasts
  - [[https://play.bth.se/media/Contracts/1_086yu2lr/41750261][Contracts]]
  - [ ] Interaction Diagrams
  - [ ] Class Diagrams
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[http://dilbert.com/strip/1997-03-09e][Dilbert solves the Software Design Problem]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Interaction Diagrams
      - Sequence Diagrams
      - Collaboration Diagrams (Also: Communication Diagram)
    - Operation Contracts (Also: Design Contracts)
    - Class Diagrams
      - Associations
      - Aggregation
      - Composition
      - Class Roles
      - Multiplicity
    - Dynamic Behaviour
    - Static Structure
    - Package Diagram
    - Software Architecture
    - Architecture Style
      - Layered Architecture Style

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment: Package Diagram
    List and describe the high-level packages in your system.

    {{{tasks}}}
    - Break down your system into logically coherent packages.
    - Briefly describe each package, and its responsibilities.
    - Model your system in a UML Package Diagram.

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Package Diagram)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Overall Packages
   List your packages and briefly describe their responsibilities.
4. Package Diagram
   Represent your packages as a UML Package Diagram.
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Does the package model contain 5 to 10 packages?
2. Do the packages represent a logical division of the system?
3. Is each package described in an understandable way?
4. Are the responsibilities of each package clearly described?
#+END_tip

*** Assignment: Interaction Diagrams
    Describe what will happen inside the system for your system events in terms of UML Interaction Diagrams. You may choose yourself whether you prefer UML Sequence Diagrams or UML Collaboration Diagrams. You may wish to try using both to get a feel of which one you prefer.

    {{{tasks}}}
    - Go back to your list of UML Use Cases and their corresponding UML System Sequence Diagrams, and extract the System Events therefrom.
    - Starting with your most important Use Case, create UML Interaction Diagrams for all the System Events.
    - Continue until you have created /no fewer than 10 UML Interaction Diagrams/ and have completed a full Use Case. I.e., if you are in the middle of a use case with your tenth interaction diagram, you complete the use case and create slightly more than ten interaction diagrams.

#+BEGIN_info
{{{docstructure}}}

{{{assignment(Interaction Diagrams)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Prioritised List of Use Cases

   Repeat your prioritised list of Use Cases.

4. System Events

   List the System Events you have extracted from your UML System Sequence Diagrams:

   1. System Events for Use Case <name 1>
   2. System Events for Use Case <name 2>
   3. ...
   4. System Events for Use Case <name N>

5. Interaction Diagrams

   Your UML Interaction Diagrams, organised per use case and titled with the system event.

   1. Interaction Diagrams for Use Case <name 1>
   2. Interaction Diagrams for Use Case <name 2>
   3. ...
   4. Interaction Diagrams for Use Case <name N>
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Are there at least 10 interaction diagrams?
2. Are all relevant objects (and only objects) involved in the interaction diagrams?
3. Are all methods (messages) suitably named?
4. Are returned objects and objects passed as parameters also represented in the interaction diagram?
5. Will the interaction diagram actually sufficiently address the system event?
6. Are there interactions that are missing to fully satisfy the system event?
#+END_tip
*** Assignment: Class and Package Diagram
    In this assignment you use your UML Interaction Diagrams and extract the static structure necessary in the form of a UML Class Diagram. Furthermore, you divide your classes into the packages that you have previously identified.

    {{{tasks}}}
    - For each object in each interaction diagram, create a corresponding class in a UML Class Diagram.
    - Put your classes into the package from your Package Diagram you think is most suitable for each class.
    - Add all methods that are being called on each object in your interaction diagram to the corresponding class.
    - If two objects are interacting in your interaction diagrams, add an association between the corresponding classes.
    - Identify attributes that each object must have, and add these to the corresponding class.
    - Refine the associations in your UML Class Diagram and consider whether they should be simple associations, aggregations, or compositions.
    - Refine the associations in your UML Class Diagram with respect to multiplicity
    - Refine the attributes in each class in your UML Class Diagram and add types and visibility.
    - Refine the methods in each class in your UML Class Diagram and add return types, parameter types, and visibility.

#+BEGIN_info
{{{docStructure}}}

{{{assignment(Class and Package Diagram)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Class and Package Diagram
   
   Present the final UML Class Diagram (divided into Packages).
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Does the UML Class Diagram contain 15-30 Classes?
2. Do all objects from the interaction diagrams in the previous assignment have a corresponding class?
3. Are the classes placed into relevant packages?
4. Do all method calls from the interaction diagrams in the previous assignment have a corresponding method in the right class?
5. Are all interactions in the interaction diagrams accurately represented as associations between classes?
6. Where applicable, are associations between classes modelled as aggregations or compositions?
7. Are there multiplicity indicators on associations? Are they used correctly?
8. Do all methods have a visibility indicator, a return type, types for all parameters, and a relevant name?
9. Do all attributes have a visibility indicator, a type, and a relevant name?
10. Are there any missing attributes?
#+END_tip

*** Assignment Submission    

    {{{submit}}}
    
    Your submission shall include the following documents:
    - Interaction Diagrams
    - Class and Package Diagram
*** Update Course Backlog
    When deciding how to solve a system event in terms of interacting objects, are there better ways for the objects to interact, and are there worse ways? With respect to what?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have an understanding of how the dynamic behaviour of the system is used to identify the static structure
   - You have an understanding of how you may use your previous analysis, in terms of Use Cases, System Sequence Diagrams, and Domain Model to initiate your design of the dynamic behaviour.
   - You have created a Package Diagram document.
   - You have created an Interaction Diagrams document.
   - You have created a Class and Package Diagrams document.
   - You have committed/pushed these documents to your project repository.
   - [[./org/checked.png]] You have submitted the Interaction Diagrams document and Class and Package Diagrams document for marking.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* Sprint: Design Patterns					   :noexport:
** About This Sprint
   This sprint extends upon the previous sprints on constructing a /good/ design with the help of previously tried and tested solutions, so called /Design Patterns/.
** User Stories covered in this Sprint
   - As a software designer I want to create a design that adheres to basic design principles so that I am sure that it will "hold" when I add more functionality and start maintaining the system.
   - As a software desginer I want to be able to use previously tested solutions where applicable so that I do not have to reinvent the wheel for every problem.
** Introduction
   Object Oriented software design has been around for some time now. Over the years, certain problem types have appeared again and again, and over time common solutions to these problems evolved under the name /Design Patterns/. A design pattern is a tried and tested solution for a recurring design problem, that assigns roles and responsibilities to each class in a group of collaborating classes.

   A currently common philosophy for software construction is "Get the functionality right first, design support for your quality requirements later". While I am not sure I fully agree with this, this is the mentality that e.g. test-driven development leads to (even if it may not be explicitly said). Jan Bosch [[http://www.pearsoned.co.uk/bookshop/detail.asp?affid=gbs&t=683&item=100000000004774][suggests something similar]] when it comes to software architecture design. I think this is a useful philosophy, but only to a certain extent. I think that unless you have created your design with /some/ awareness of the quality requirements you have, and with /some/ awareness and control over how to create a design that can meet these requirements, the necessary refactoring is going to be very difficult if not impossible. This is why it is important to be aware of common design principles and design patterns.

   You have already studied the first building block to achieve good designs with the GRASP patterns from {{{larman}}}. These basic design principles do not target any specific quality attribute or any specific problem or problem type, but are generic principles in order to set a good foundation for your design. The next building block is to look at groups of interacting classes, and good design principles for getting these groups of classes to work together to solve specific problems. The last building block is the software architecture, which is discussed in other sprints.

   The design patterns discussed in {{{larman}}} is a subset of the ones in the so-called "Gang of Four"-book [fn:GoFBook:E. Gamma, R. Helm, R. Johnson, and J. Vlissides. /Design Patterns: Elements of Reusable Object-Oriented Languages and Systems./ Addison-Wesley, Reading MA, 1994.] (Listed in Table [[tab:GoFPatterns]]). These are a good starting point. I warmly recommend you to buy the GoF book as well and glance through the patterns so you have a rough idea of all the patterns in this book. This will help you to quickly recognise when you can solve a problem with a particular design pattern.

#+NAME: tab:GoFPatterns
#+CAPTION: GoF Patterns in {{{larman}}}
   | Pattern          | Brief Problem Description                                                                                                                                                                        |
   |------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
   | Adapter          | You want to use one interface, but your code provides another, or another version.                                                                                                               |
   | Factory          | You need a transparent way to create objects of the right type.                                                                                                                                  |
   | Singleton        | You have a resource that is shared across your entire application and which must be kept unique, but can not/do not want/your software design teacher has told you not to/ use a global variable |
   |                  | (Note, a global variable would not solve the "unique access" problem anyway)                                                                                                                     |
   | Strategy         | You need a way to (possibly at runtime) change an algorithm depending on some circumstances.                                                                                                     |
   | Composite        | In your system, the same strategies should be applied to individual entities as to some, defined, groupings of entities.                                                                         |
   | Facade           | You have different implementations or interfaces that you wish to hide from the users of your API.                                                                                               |
   | Observer         | You want to be able to add new parts to your system that should be notified of changes in another part, without having to go in there and hard-code the notification all the time.               |
   | Proxy            | You do not want to directly access a resource, for a number of reasons.                                                                                                                          |
   | Abstract Factory | Your homegrown Factory pattern just blew up in your face and you need a more scalable solution.                                                                                                  |
   |------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

   The thing with design patterns, which I cannot stress enough, is that they are /proven/ solutions to /common/ problems. It's not just "I googled for this problem, and a random dude at StackOverflow got lots of votes for this solution, so I am going to cargo-cult it into my own application without understanding the consequences of solving my problem in this way". Each solution has /known/ consequences in terms of the effect on a number of quality attributes (modifiability in particular).

   Moreover, once you decide to solve your problem using a particular design pattern, you can annotate your design to say that you are indeed using Design Pattern X. You may even use UML Stereotypes to annotate your individual classes in your design with both the pattern name as well as each class' role in the pattern. The benefit of this is that other software developers will recognise what pattern you are using, will understand the roles and responsibilities, and will know how to extend or modify it. Even if you do not explicitly annotate your design the role-names tend to become embedded into the class names such that a good designer will recognise the design patterns anyway.

#+BEGIN_info
*TL;DR:* Design Patterns help you re-use proven solutions to commonly recurring problems. It also helps you and other developers to understand the design.
#+END_info

    I would also like to point out that you normally do not use design patterns in isolation. Rather, you nest usage of design patterns inside each other, and you typically even use some design patterns to construct others (the /Observer/ pattern is notoriously used as a building block of other patterns, as is the /Facade/ and /Proxy/ patterns depending on how you look at things). There are also some patterns which are very similar in nature (for example, the /Strategy/ pattern and the /State/ pattern). 

*** When to apply Design Patterns
    The next question is /when/ should you start thinking of design patterns? I have partially answered this by saying that you should always be aware of common design patterns so that they become a natural way to think of roles and responsibilities when designing.

    The next point is when you are creating your UML interaction diagrams, and are deciding how a certain interaction should "play out". The problem is that it is rather difficult to recognise design patterns here, so I would suggest that you back up a bit first. Go back to your UML Domain Model. Reflect upon the feature you are currently trying to design, and which concepts from your domain model might be involved.

    - Are there any shared resources (might /Singleton/ be a good idea)?
    - Do you need to shelter yourself e.g. from an external party or resource (can you hide this behind an /Adapter/ or a /Proxy/)?
    - Can you structure the data hierarchically (Would /Composite/ help)?
    - Do you need to create new objects according to some business rule (can you encode this in a /Factory/ or an /Abstract Factory/)?

    This will at least put the embryos for design patterns in place. However, this will probably also require you to think slightly further than just the UML interaction diagram you are currently designing, or the UML use case you are currently working on, or even the current sprint. Most design patterns are solutions to how to seamlessly add new or alternative functionality, and when you are designing one particular use case or interaction diagram you should first be focusing on creating /one/ functional flow without any concern for alternative flows (Yes, they are there in the UML use case description, and you should take care of them in your interaction diagrams too, but the workflow is to "do the main flow first, /then/ do the alternative flows"), so you may not see the need for a design pattern when you are designing for the first iteration.
    
    The benefit of at least spending some thought about design patterns early on is that it will make your life easier later, because you already have the scaffolding in place to extend with more functionality.

    The /danger/ is that you add structure that may not be required. It certainly is not required for your current iteration. In the eyes of Lean software development, this is a /waste/, and just helps to create a technical debt. You have added structure that needs to be maintained, and needs to be understood before any maintenance is done, but which is not used to deliver any actual value to your customers.

    So a better approach is to /plunge on/ instead of backing up. Do your interaction diagrams. Extract a minimum viable class diagram therefrom, and /only then/ think about what commonalities and variations you have between different interaction diagrams and how you may resolve these commonalities and variations with the help of design patterns.

    Then you go back and revise your interaction diagrams accordingly. Remember that at this stage refactoring is cheap since you only have "paper products" to work with.

#+NAME: fig:DPIterations
#+CAPTION: Designing the dynamic behaviour together with the static behaviour and applying design patterns is an iterative process.
[[./images/IDPIterations.png]]

*** A Word of Warning
    I would like to end this section with a word of warning: It is easy to go overboard with design patterns.

    [[./images/IDPAllthethings.jpg]]


    Some colleagues of mine once took a small system that consisted of a handful of classes and started refactoring with the help of design patterns. They stopped when they had 30-odd classes, and I am not sure that any of the qualities they had started out optimising for could be detected in the system anymore (I don't think this was a major concern for them, though, since the primary goal of the exercise was to see how many classes you would get if you kept on adding design patterns).

    First of all, many design patterns solve similar problems so if you have one design pattern in place, chances are that you have at least partially addressed many of the concerns you had. Second, you will not resolve any underlying problems just by throwing more design patterns at your system. If the system is broken, more design patterns will not help.

    Third, this is why you should start out lean. Only address your immediate concerns. Refactor later if you still have unsolved issues.

    However, in order to decide which design patterns are /minimally/ necessary, you need to know about /many/ design patterns so you can make an informed decision between them.
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      26. [@26] Applying GoF Design Patterns
      36. [@36] More Object Design with GoF Patterns
      37. Designing a Persistence Framework with Patterns
*** Screencasts
  - [[https://play.bth.se/media/DesignPatterns_GoF/1_xdlww0y6][GoF Design Patterns]]    
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[http://steve-yegge.blogspot.se/2006/03/execution-in-kingdom-of-nouns.html][Execution in the Kingdom of Nouns (Steve Yegge)]]
    - [[http://stackoverflow.com/questions/383947/what-does-it-mean-to-program-to-an-interface][Program to an Interface, not an Implementation]]: Define role-based interfaces and use these instead of "direct links" to the instantiated class. NOTE: Also read the "Wizards and Warriors" rant for a counter-argument.
    - [[https://ericlippert.com/2015/04/27/wizards-and-warriors-part-one/][Wizards and Warriors Part I]] [[https://ericlippert.com/2015/04/30/wizards-and-warriors-part-two/][Part II]] [[https://ericlippert.com/2015/05/04/wizards-and-warriors-part-three/][Part III]] [[https://ericlippert.com/2015/05/07/wizards-and-warriors-part-four/][Part IV]] [[https://ericlippert.com/2015/05/11/wizards-and-warriors-part-five/][Part V]]: Introduces the need for an [[https://en.wikipedia.org/wiki/Entity_component_system][Entity Component System (ECS)]], which is a common game design pattern since the normal inheritance practices break down.
    - [[https://en.wikipedia.org/wiki/Composition_over_inheritance][Favour Object Composition over Class Inheritance]]: The same pattern, with a different name.
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Design Pattern
      - Adapter
      - Factory
      - Singleton
      - Strategy
      - State
      - Composite
      - Facade
      - Observer
      - Proxy
      - Abstract Factory
    - Stereotypes
    - Interface, and Abstract Class

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment: Identify Design Patterns
    Revisit the material you have produced until now and identify if you may use any design patterns.

    {{{tasks}}}
    - Go through your UML Use Cases, your UML Interaction Diagrams, and your UML Class Diagrams.
    - Identify where there are challenges such as (but not limited to) shared resources, external interfaces, or context dependent strategies.
    - For each challenge:
      - Identify a suitable design pattern.
      - Identify the involved classes in your current solution
      - Identify which roles they would have according to the design pattern.
      - Briefly describe:
	- What was your challenge?
	- Which design pattern(s) may address it? Why?
	- Which classes are involved? What are their roles?
	- What did you gain by applying this design pattern?
	- What did you lose by applying this design pattern?
      - IMPORTANT: Refactor your class diagrams and your interaction diagrams to use the design pattern. Rename classes or use stereotypes so that the applied design patterns become clear in your design.
      - Review your new design according to the GRASP patterns to make sure you still have a good object-oriented design. Refactor otherwise.
    - Iterate 1-2 times to make sure you have covered 
#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Applying Design Patterns)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Challenges
   Briefly describe your challenges according to the task description above:
   - What was your challenge? How (and in wich diagrams) was it identified?
   - Which design pattern(s) may address it? Why?
   - Which classes are involved? What are their roles?
   - What did you gain by applying this design pattern?
   - What did you lose by applying this design pattern?
   - Refactorings
     - A partial class diagram with your refactored classes
     - Relevant Interaction diagrams refactored to use the new class diagram.
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Are there between 3 and 10 challenges that are solved with design patterns?
2. Consistency: Are the associated diagrams (UML Class Diagrams, UML Interaction Diagrams) updated to reflect the application of the design patterns?
3. Are the most obvious challenges where design patterns may be applied identified?
4. For each challenge: Is the challenge well described?
5. For each challenge: Is the most suitable design pattern selected? Does the motivation make sense?
6. For each challenge: Is the design pattern properly applied?
7. For each challenge: Are the benefits and liabilities well explored?
#+END_tip    
*** Update Course Backlog
    As the system grows, is there a way to structure the bigger building blocks of a system? Package diagrams show how the implementation artefacts are structured, but how would you express the dynamic behaviour on a package level? What about exploring high-level concepts of a large software system? Are there patterns similar to design patterns that deal with systems and sub-systems?
    
    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have reviewed the Design Patterns in {{{larman}}} and have a general understanding of which problems they try to solve, and how to structure a solution in accordance with each design pattern.
   - You have considered your current design and identified design patterns that may be useful to you.
   - You have refactored your current design to make use of the identified design patterns.
   - You have reviewed your design to make sure all diagrams are fully consistent with each other after your refactoring.
   - You have created an "Applying Design Patterns" document.
   - You have committed/pushed this document to your project repository.

   you may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* TODO Sprint: Introduction to Software Architectures		   :noexport:
** About This Sprint
   This sprint reviews how to describe a non-trivial software system in the form of a software architecture.

   For more information on this topic, see e.g. the course ~PA1410 Software Architecture and Quality~.
** User Stories covered in this Sprint
   - As a software designer I want to be able to divide my design into manageable chunks so that I can get a better overview.
   - As a software designer I want to address the quality requirements of the software system early on so that they are not missed.
   - As a software designer I want to address the quality requirements of the software system in the most appropriate way to facilitate the rest of the development project.
** Introduction
   When developing software there are a number of challenges to keep in mind. For example, the project manager want to /reduce the development costs/, your marketing department will want to /reduce time-to market/, considering that your application is going to spend 90% of its lifespan in maintenance, your company will want to /decrease the maintenance costs/, and your product managers want to /increase system quality/. We can summarise these needs in what is known as the [[https://en.wikipedia.org/wiki/Project_management_triangle][Iron Triangle]]. Ignoring Euclidean geometry, this can be [[http://paulhammant.com/2015/12/19/the-iron-triangle-is-actually-a-square-and-not-particularly-iron/][summarised as]]: 

#+BEGIN_SRC ditaa :file ./images/FIronTriangle.png
  The Right
  Functionality                     On Time
            +----------------------+
            | cGRE                 |
            |                      |
            |                      |
            |       Deliver        |
            |                      |
            |                      |
            |                      |
            |                      |
            +----------------------+
  On Budget                         The Right
                                    Quality
#+END_SRC   

#+NAME: fig:IronTriangle
#+CAPTION: The Iron Triangle of Software Development
#+RESULTS:
[[file:./images/FIronTriangle.png]]

In order to balance these requests (and many more) you, as software developers, take decisions (Note how only one of the challenges appear to be about software. I won't say any more about this for now, but I encourage you to think about how you would address the other challenges in your software). Software architecting is about identifying /which/ business and technical decisions are necessary, and /finding solutions/ that satisfy all stakeholders.

The software architecture is a tool for /understanding/ which decisions are necessary, for /planning/ how to instantiate these decisions in your software, and for /communicating/ your decisions to the rest of the development team. You also use them to /predict/ quality, and identify opportunities for /reuse/.

Going back to the iron triangle. Jan Bosch once said "Functionality is easy." Anyone can implement functionality. It's just a matter of hacking away until you have the right functionality. It is the other three corners that require planning, and where a software architecture may help. Let's review each of the corners:

- On Time :: What features are most important to deliver first? How much time do you have? How can you structure the system so that you can develop features in parallel?
- On Budget :: What resources do you have available? How do you structure the software to make best use of the available expertise? What can you buy? What must you build?
- On Quality :: The obvious bit here is how you structure the software so that you can test it properly, but there is more to say here. The software architecture defines a /potential/ to achieve certain quality attributes (for example, one structure may be good for reliability, another for modifiability, and a third for throughput). We may, in fact, define "on time" and "on budget" to also be specific quality requirements, that should be balanced alongside with performance, maintainability, reliability etc. [[https://en.wikipedia.org/wiki/ISO/IEC_9126][ISO9126]] (and it's successor ISO 25010) goes one step further and also includes functionality as one quality attribute among the rest.

*** Architecture as Decisions
The first thing of a software architecture is thus that it consists of /conscious decisions/ on how to address different concerns from different stakeholders. This includes decisions on concerns where you do not have the right competence available in-house, decisions on concerns where you need to deliver parts of the system in a certain order, decisions on concerns about how to achieve different quality requirements, and decisions on how to /balance/ all these different concerns such that you focus on the most important concerns (side note: how do you prioritise your concerns?).

I will even go so far as to say that the decisions /are/ the software architecture. The rest is just instantiations of these decisions. The instantiation is important, since this brings together all of your decisions into one coherent system that you are able to communicate to others, and to evaluate to ensure that you actually satisfy the right balance of quality requirements.

A more traditional definition is provided by the [[http://www.sei.cmu.edu/architecture/][Software Engineering Institute]] (The definition below is from their book /Software Architecture in Practice/ (Bass et al. 2012)):

#+BEGIN_QUOTE
The software architecture of a program or computing system
is the structure or structures of the system, which comprise
software elements, the externally visible properties of those
elements, and the relationships among them.
#+END_QUOTE
*** Architecture Views
    If you've payed attention to the other sprints in this course, it should not come as a surprise to you that the software archtiecture is documented in a number of different ways, depending on what you are focusing on. Consider the maps below. All three represent London, but from different perspectives.

    [[./images/ILondon_AZMap.jpg]]
    [[./images/ILondon_Tube.png]]
    [[./images/ILondon_River.jpg]]

    (There are also [[http://mappinglondon.co.uk/][Other maps of London]] that are equally valid representations of the city. For example, there are sewage maps, electricity maps, gas maps, etc.)

    If you are sightseeing, you might use the river map and take a boat. If you are walking or driving, the A-Z map is probably your best friend. If you just want to get from point A to point B, you use the tube map.

    In the same way, you express your software architecture using different types of "maps" depending on what you intend to do.  Philippe Kruchten expressed this in 1994 as the "4+1 view of architecture":

    [[./images/IKruchten.png]]

    This has influenced many design methodologies, including UML. The current best practice is to define a set of views (possibly from a suggested superset of potential views) that are relevant for your system. I am a bit old-fasioned, so I usually stick with a subset of Hofmeister et al. (2000)'s views:

    - A Conceptual View :: describing the system as a series of collaborating conceptual "logical" components.
    - A Module View :: describing the system as implementable modules corresponding to UML packages.
    - An Execution View :: studying the runtime behaviour of the modules.
    - A Code View :: focusing on the development and build environment.

*** Working with the Views
    In UML, the "Scenarios" that Kruchten describes are your use cases. In Hofmeister et al. (2000), it corresponds to your decisions. In Bass et al. (2012) it is your architectural drivers. You use these scenarios (use cases, decisions, architectural drivers, etc.) to define /what/ you need to model on an architecture level, and then you focus on different engineering concerns of these "whats" in each of the viewpoints. 

#+BEGIN_info
*Engineering Concerns*

- Conceptual View
  - How does the system fulfill the requirements?
  - How are COTS components to be integrated? How do they interact with the rest of the system?	
  - How is domain specific hardware and/or software incorporated into the system?	
  - How is functionality partitioned into product releases?	
  - How does the system incorporate portions of the prior generations of the product and how will it support future generations?	
  - How are product lines supported?	
  - How can the impact of changes in requirements or the domain be minimized?	
- Module View
  - How is the product mapped to the software platform?	
  - What system support/services does it use, and exactly where?	
  - How can testing be supported?	
  - How can dependencies between modules be minimised?	
  - How can reuse of modules and subsystems be maximised?	
  - What techniques can be used to insulate the product from changes in COTS software, in the software platform, or changes to standards?
- Execution View
  - How does the system meet its performance, recovery and reconfiguration requirements?	
  - How can one balance resource usage (for example, load balancing)?	
  - How can one achieve the necessary concurrency, replication and distribution without adding too much complexity to the control algorithms?	
  - How can the impact of changes in the runtime platform be minimised?	
- Code View
  - How can the time and effort for product upgrades be reduced?	
  - How should product versions and releases be managed?	
  - How can build time be reduced?	
  - What tools are needed to support the development environment?	
  - How are integration and testing supported?	
#+END_info

Once you have the scenarios (decisions) for your first iteration ready, you basically work your way through the different views. There is an implicit order between them, because you need a conceptual overview before you can start defining modules, and you need the modules before you can start allocating these to your runtime platform. You also need the modules and the runtime overview before you start planning how to build, test, and integrate your system. However, it is also important to know that the decisions you take in the process of creating one view will impact the views you have already done, so you need to go back and revise in a highly iterative process.

[[./images/IArchDesign.png]]

*** Architecture Evaluation
    You set out in your quest for architecture design with a well defined set of intentions; your (and your stakeholders) primary concerns. You have balanced these intentions against each other and the importance of each stakeholder, you have taken decisions on how to realise a system that satisfies these intentions, and you have instantiated your decisions in a number of different views of your system. 

    As a good engineer, you should not be satisfied here. The software architecture is a relatively cheap artefact to produce, and it has a considerable impact on your quality requirements. Your architecture is also expressed in several different views, and you need to integrate these views into a whole. Lindvall et al. (2003) distinguishes between /Early Architecture Evaluation/ and /Late Architecture Evaluation/:

#+BEGIN_info
*Early Architecture Evaluation*
  - Do we meet the quality requirements on the system?
  - Do all stakeholders share a common understanding of the system?
  - Are all requirements accounted for?
  - Are there any weak spots in ther architecture?
  - Can the system (and/or the architecture) be improved?
  - Does the development team have all the necessary resources?
  - Should we let this project continue?

*Late Architecture Evaluation*
- Hard metrics.
- How did we do? What needs to be improved for the next release?
#+END_info

There is a range of different evaluation methodologies available, from ad-hoc based "looking at the architecture and trying to find challenges based on past experiences and logical reasoning", via more structured versions of this, up to simulation-based and mathematical models. The most commonly used is what is called /scenario-based/, which is a way to structure your experiences and focus your analysis into one scenario at a time.

    Once you have evaluated your architecture, you need to decide whether you satisfy your quality requirements (and your other engineering concerns) or not. If you do, then you are done and can continue building your system. If not, you transform the architecture. This means that you change the architecture in one or several ways in order to improve those qualities that were lacking in your evaluation. Then you re-evaluate to see whether your transformations meet their goal and that they did not negatively effect any other of your qualities.
    
#+NAME: fig:ArchEvalCycle
#+CAPTION: The Architecture Evaluation Cycle
[[./images/IArchEval.png]]    

#+BEGIN_tip
*A Good Software Architecture*
- Is based on conscious decisions
- Is evaluated to ensure that it satisfies the specific goals for the system
- Pays attention to current and future quality attributes
- Is well documented, with traceability to the architecture decisions
- Features well defined modules(components), with well defined interfaces and well defined responsibilities
- Is restricted to a small set of interaction patterns that are consistently used
#+END_tip
*** Architecture Tactics
    Bass et al. introduces one more crucial aid for designing your architecture, namely /Architecture Tactics/. When you have your architectural drivers and need to decide how to actually adress these in your software architecture, architectural tactics suggest solutions on an architectural level for different quality requirements. The tactics are described on a high level, so you need to work with them quite extensively in order to actually fit them into your system.
    
    For example, if /performance/  is a concern for you, Bass et al. suggest that you can focus on managing the resource demand (e.g. by reducing overhead, rate limit the incoming data, or be more efficient in your computations), you may manage the resources smarter (e.g. by introducing concurency), or you may divide the work better (e.g. with a different scheduling policy). Of course, you may decide to use several of these tactics at once. Which tactic to use depends on your system and your data.

    I suggest that you have a look in the Software Architecture in Practice book by Bass et al. and get an overview of the available tactics. These are good engineering principles that help you achieve your quality requirements in a more repeatable way.
*** TODO Summary						   :noexport:
** TODO Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      33. [@33] Architecture Analysis
      34. Logical Architecture Refinement
      38. [@38] UML Deployment and Component Diagrams
      39. Documenting Architecture: UML & the N+1 View Model
*** TODO Screencasts						   :noexport:
*** TODO Lectures						   :noexport:
*** Books and Articles
    - L. Bass, P. Clements, and R. Kazman. /Software Architecture in Practice, Third Edition./ Addison-Wesley Publishing Co., Reading MA, 2012.
    - C. Hofmeister, R. Nord, and D. Soni. /Applied Software Architecture./ Addison-Wesley, Reading MA, 2000.
    - R. Kazman, L. Bass, M. Webb, and G. Abowd. /SAAM: A method for analyzing the properties of software architectures./ In Proceedings of the 16th international conference on Software engineering, pages 81–90. IEEE Computer Society Press, 1994.
    - P.B. Kruchten, "The 4+ 1 view model of architecture." /IEEE software/ 12.6 (1995): 42-50.
    - M. Lindvall, R. T. Tvedt, and P. Costa. An empirically-based process for software architecture evaluation. /Empirical Software Engineering/, 8:83–108, 2003.
    - M. Svahnberg and F. Mårtensson. Six years of evaluating software architectures in student projects. /Journal of Systems & Software/, 80(11):1893–1901, 2007.
*** Further Reading						   :noexport:
** TODO Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Software Architecture
    - The 4+1 Views of Architecture
    - Architecture Viewpoints
      - Conceptual View
      - Module View
      - Execution View
      - Code View
    - Quality Aspects
      - Quality Attribute
      - Quality Requirement
    - Architecture Evaluation
      - Early Architecture Evaluation
      - Late Architecture Evaluation
      - SAAM/ATAM
    - Architecture Tactics

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** TODO Assignment						   :noexport:
*** Update Course Backlog
    Are there any common architecture styles? What are their qualities?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** TODO Sprint Acceptance Tests
   You are done with this sprint when:
   - You have 

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* TODO Sprint: Software Architecture Patterns
** About This Sprint
   This sprint covers different patterns that are useful for getting started with a software architecture.
** User Stories covered in this Sprint
   - As a software architect I want to start my design with a well known structure so that I can be sure that I am addressing my quality requirements in the best way.
** Introduction
   I am going to address the user stories in this sprint from two different perspectives. Both of them backs up to how [[https://www.wikipedia.org/wiki/Christopher_Alexander][Christopher Alexander]] described a pattern language for architectures (as used e.g. by Gamma et al. in the Design Pattern book). The first perspective is the common and widely used idea of architectural styles and architectural patterns as a design template. For example, if I describe a system as having a "Layered Architecture", being a "Pipes and Filters system", or a "Model-View-Controller" architecture, this means that the basic structure of the architecture is done according to these patterns. They can be described as ready-made solutions that describe the overall structure of your system, along with the roles and responsibilities of each component. This is the approach taken e.g. by Buschmann et al. (1996)

   The /second/ perspective is the one that Bass et al. (2012) uses, where they describe patterns as specific building blocks that you use for specific purposes, and thus your overall architecture is composed by these smaller building blocks. They refer to these blocks as /Architecture Tactics/. The two perspectives are not mutually exclusive. You are likely to start with an overall architecture pattern to setup a /potential/ for achieving a certain blend of quality requirements. As you continue to design your architecture, you will then encounter specific challenges that you need to design an architectural solution for, where you will apply architectural tactics to address the challenge.

*** Architecture Patterns
   I will not go through all of the architectural patterns or the tactics; there are simply too may of them, it will simply be a boring enumeration, and it does not help you understand them. It /is/, however, good to have an overview of the architectural styles, since these will be your starting point when creating (or approaching an existing) new system. Just as with design patterns, it is good to know their names, roughly how they organise your system, and what problem(s) they address, since this means that you will share a vocabulary with other software developers.

#+BEGIN_tip
Study the Architectural Patterns in Buschmann et al. so you have a broad overview of the problems they address and how they are structured.
#+END_tip

#+NAME: tab:BuschmannPatterns
#+CAPTION: Architectural Patterns in Buschmann et al.
| Pattern                          | Brief Summary                                      |
|----------------------------------+----------------------------------------------------|
|                                  | <50>                                               |
| Layered                          | Decompose system into groups of subtasks that are on different levels of abstraction (such as closer to the user interface or closer to the metal) |
| Pipes and Filters                | Process a data stream in a series of different steps |
| Blackboard                       | Several "workers" collaborating over a shared data set |
| Broker                           | Decouple distributed components                    |
| Model-View-Controller            | Separate data and rules for data consistency from presentation and user input |
| Presentation-Abstraction-Control | Separate viewing and manipulating data into independent but cooperating agents |
| Microkernel                      | Support a minimal core where it is easy to plug in new components |
| Reflection                       | Separate the software into a self-aware "knows how to configure and run jobs" part and a "knows how to do the job" part |
|----------------------------------+----------------------------------------------------|

*** Architecture Tactics
The architecture tactics are organised in a different way. The classic design patterns and architecture patterns are described with a generic problem, an example, a solution, and a discussion of the solution. Tactics start from the notion of /quality attribute scenarios/, which is a way to define the parameters of a quality requirement. Consider the example in Figure [[fig:QAScenario]]. In this scenario a user starts a transaction when the system is running as normal. The user expects the transaction to be processed within two seconds on average.

#+NAME: fig:QAScenario
#+CAPTION: An example of a Quality Attribute Scenario
[[./images/IQAScenarioExample.png]]

The next step is to find a tactic that can control the response such that the response measure is achieved. In the example in Figure [[fig:QAScenario]], how may we ensure that transactions are processed within an average of two seconds? This is a performance issue, so we look in Bass et al. under Chapter 8, "Performance" and find the tactics listed in Table [[tab:PerfTactics]]. We then choose the tactic(s) that best suit our particular problem.

#+NAME: tab:PerfTactics
#+CAPTION: Performance Tactics from Bass et al.
| Control Resource Demand      | Manage Resources                         |
|------------------------------+------------------------------------------|
| Manage Sampling Rate         | Increase Resources                       |
| Limit Event Response         | Introduce Concurrency                    |
| Prioritise Events            | Maintain Multiple Copies of Computations |
| Reduce Overhead              | Maintain Multiple Copies of Data         |
| Bound Execution Times        | Bound Queue Sizes                        |
| Increase Resource Efficiency | Schedule Resources                       |
|------------------------------+------------------------------------------|

Notice that tactics do not tell you exactly which components are needed, or what responsibilities they should have. Instead they merely discuss the solution, and things to consider when using this particular solution. It is then up to you to define which components you will need to implement the tactic, and where in your overall architecture (e.g. which layers) they fit. Not only does this give you a freedom as software designer, it enabled Bass and his colleagues to discuss and categorise architecture solutions for quality requirements that were traditionally "ignored" because they could not be expressed as a set of interacting components.

*** One More Thing...
    One part of architecture patterns which I have not mentioned yet is that just as there are basic design principles for object oriented designs, there are also good practices for architectures. {{{larman}}} summarises a set of these with respect to package design (which is as close to architectures as the Larman book goes). These principles should be applied even when working within a particular architecture pattern or when designing in a particular architecture tactic.
** Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      35. [@35] Package Design
*** TODO Screencasts						   :noexport:
    - Chapter 35 (Package design)
    - Go through a chapter in the AOSA-book and evaluate its use of tactics
    - [[http://resources.sei.cmu.edu/library/asset-view.cfm?assetid=31149][Len Bass on Architectural Tactics]]
*** TODO Lectures						   :noexport:
*** Articles							   :noexport:
*** Further Reading
    - F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stahl. /Pattern-Oriented Software Architecture - A System of Patterns./ John Wiley & Sons, Chichester UK, 1996.
    - L. Bass, P. Clements, and R. Kazman. /Software Architecture in Practice, Third Edition./ Addison-Wesley Publishing Co., Reading MA, 2012.
    - A. Brown, G. Wilson, /The Architecture of Open Source Applications/, available online at: http://www.aosabook.org/en/index.html .
    - [[http://www.ece.ubc.ca/~matei/EECE417/BASS/ch05.html][The chapter on architectural tactics (Chapter 5) from the Second Edition of Bass, Clements, and Kazman]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Architecture Pattern (also the individual architecture patterns mentioned above)
    - Architecture Tactic (also the individual tactics for different quality attributes)
    - Quality Attribute Scenario

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Self-Study: Architecture Tactics
    Study the architecture of a couple of open-source systems in the AOSA-book (http://www.aosabook.org/en/index.html). Identify the main challenges they have with respect to:
   
    - Modifiability
    - Performance
    - Testability

    (You may of course look at the other tactics as well.) Unless you have access to the third edition, use [[http://www.ece.ubc.ca/~matei/EECE417/BASS/ch05.html][The chapter on architectural tactics (Chapter 5) from the Second Edition of Bass, Clements, and Kazman]].

    You are free to study any of the systems, but you should be warned that not all of these texts actually describe the architecture of the applications or, if they do, in a way that enables evaluation with respect to quality attributes or tactics. I have previously used the following chapters for similar purposes in software architecture courses:

    - [[http://www.aosabook.org/en/nginx.html][Nginx]]
    - [[http://www.aosabook.org/en/audacity.html][Audacity]]
    - [[http://www.aosabook.org/en/graphite.html][Graphite]]    
*** Assignment: Quality Attribute Scenarios
    
*** Assignment: Architecture Tactics
*** Update Course Backlog

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   

* WAIT Sprint: Package Design (chapter 35) 			   :noexport:
  Maybe make this into a small vid instead.
* Sprint: From UML to Architecture				   :noexport:
* WAIT Sprint: Scaling up Classes 				   :noexport:
** notes							   :noexport:
   - Class Diagram
   - Packages
   - Architectures (Layered, MVC)
   - GRASP?
* Sprint: Design the User Interface				   :noexport:
** notes

* Sprint: Implementation				:noexport:submission:
* WAIT Sprint: Quality Attributes 				   :noexport:
* Sprint: Preparing for the Exam				   :noexport:
* Sprint 99: Finalising the Course				   :noexport:

* Working Material						   :noexport:
** Don't Forget
   - [X] Use Cases: connect back to requirements (annotate Main Course of Events with links to Business Requirements).
   - [X] Requirements Engineering: Three parallel and different ways of writing requirments: Old (Reqs), Agile (User stories), UML (Use Cases): Add a picture of this...
   - [ ] GRASP: Responsibility-driven design

   | PA1415            | PA1435              | PA1443          | PAxxxx          |
   |-------------------+---------------------+-----------------+-----------------|
   | Exam, 3hp         | Exam, 2hp           | Exam 1hp        | Exam 1hp        |
   | Assignment, 4.5hp |                     | Assignments 4hp | Assignments 3hp |
   |                   | Assignment 1, 1.5hp |                 |                 |
   |                   | Assignment 2, 0.5hp |                 |                 |
   |                   | Assignment 3, 2hp   |                 |                 |
   |                   |                     |                 |                 |
   | SUM: 7.5hp        | SUM: 6hp            | SUM: 5hp        | SUM: 4hp        |
   |-------------------+---------------------+-----------------+-----------------|

   Assignment Submissions:
   - Use Cases and Use Case Diagrams
   - Interaction Diagrams and Classes ??
   - Improved Classes and Interactions
   - Design Patterns
   - Implementation/Testing

   Assignments!
   - How many
   - Flow
   - Topic
** TODO Work in "The Design Pattern Way" into all sprints.
   For example: The DP way to design interactions
** TODO Review Assignments.
   - Is it necessary to do all of this?
   - Can there be a "Design Pattern" way here too
   - What about a Lean way?
** TODO Move Submissions from Interactions and Structure into Good Interactions ?? 
** DONE Find a cleaner way to include Title Page and System Description in assignments.
   CLOSED: [2016-09-30 Fri 09:03]
   The MACRO for assignment title DO NOT WORK; on export it only has the latest set value, which does not work if you have more than one assignment in an export unit (a sprint.)
** DONE Fix Links in Test Sprint
   CLOSED: [2016-09-28 Wed 10:07]
   - Emil - link to his work
   - JUnit
   - Testing Tools
     - unit testing (Grunt, Junit, CPPTest, etc.)
     - Continuous Integration Tools (Jenkins, Drone.io, Travis.io, ...)
** TODO Map for different Courses   
** TODO System Descriptions for Assignments
** TODO Add "Select System for Assignments" in Sprint 0
** TODO Tie in Lectures into Sprints, with preparations I want them to do first
** DONE State Diagrams
   CLOSED: [2016-09-28 Wed 10:07]
** TODO Revisit all sprints with submissions and make sure the sprint test plan is up to date
** TODO Re-do video "Concepts and Classes": Move Objects into a different sheet
** TODO Video: Interaction Diagrams
** TODO Video: Class Diagrams
** TODO Videos: Software Architectures
   - SA Intro
   - Tactics
   - Views
   - Notation
** TODO Assignments in Architecture sprints
** Chapters Used
   | Chapter | Sprint |                                   |
   |---------+--------+-----------------------------------|
   |       1 |      1 |                                   |
   |       2 |      1 |                                   |
   |       3 |      1 |                                   |
   |       4 |    2,3 |                                   |
   |       5 |    2,3 |                                   |
   |       6 |    2,3 |                                   |
   |       7 |    2,3 |                                   |
   |       8 |      4 |                                   |
   |       9 |      4 |                                   |
   |      10 |      4 |                                   |
   |      11 |      8 |                                   |
   |      12 |        | () Req to Design                  |
   |      13 |      8 |                                   |
   |      14 |      8 |                                   |
   |      15 |      8 |                                   |
   |      16 |      8 |                                   |
   |      17 |      7 |                                   |
   |      18 |      7 |                                   |
   |      19 |        | Visibility                        |
   |      20 |        | Design to Code                    |
   |      21 |  1,3,5 |                                   |
   |      22 |        | () Tools                          |
   |      23 |        | () Iteration II                   |
   |      24 |        | () Analysis Update                |
   |      25 |      7 |                                   |
   |      26 |      9 | GoF DP                            |
   |      27 |        | () Iteration III                  |
   |      28 |        | () Activity Digrams               |
   |      29 |      6 |                                   |
   |      30 |      3 |                                   |
   |      31 |      8 | Domain Model Refinement           |
   |      32 |        | () More SSD and Contracts         |
   |      33 |     10 | Arch. Analysis                    |
   |      34 |     10 | Log. Arch. Refinement             |
   |      35 |     11 | Package Design                    |
   |      36 |      9 | More GoF DP                       |
   |      37 |        | DP Example                        |
   |      38 |     10 | Deployment and Component Diagrams |
   |      39 |     10 | Architecture Documenting 4+1      |
   |      40 |      1 |                                   |
** Backlog
 | Sprint                    | Topic     | Contents                                  | User Story                                                                                                                                                                                     |   |
 |---------------------------+-----------+-------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---|
 | Intro                     | Intro     | Student                                   | As a student I want to pass this course.                                                                                                                                                       |   |
 |                           | Intro     | Student                                   | As a student I want to understand how this course is structured so that I can quickly find the information I need to learn the subject.                                                        |   |
 |                           | Intro     | Student                                   | As a student I want to know why this topic is important so that I can be properly motivated.                                                                                                   |   |
 | Development Methodologies | DevMeth   | UML                                       | As a software designer I want to document my design in a standardised format so that I can communicate it to other software engineers.                                                         |   |
 |                           | DevMeth   | Development Methodologies, GANTT          | As a project manager I want to plan the project so that I can make the best use of my resources.                                                                                               |   |
 |                           | DevMeth   | WBS                                       | As a project manager I want to track the project so that I can see what the current status is.                                                                                                 |   |
 |                           | DevMeth   | Project Estimations                       | As a project manager I want to track the project so that I can forecast whether we will deliver on time or not.                                                                                |   |
 | Requirements Engineering  | RE        | Requirements                              | As a software engineer I want to get an overview of all sources of requirments that may influence which system I build.                                                                        |   |
 |                           | RE        | Requirements                              | - As a requirements engineer I want to know who may have requirements on the system we are building so that I can make sure that all needs are met.                                            |   |
 |                           | RE        | Requirements                              | As a software engineer I want to be able to extract all requirements on the system I build so that I know that I am not missing anything important.                                            |   |
 |                           | RE        | Requirements                              | - As a requirements engineer I want to have a range of methods for finding requirements so that I can choose the best method for each customer.                                                |   |
 |                           | RE        | Backlog, Iterations, Prioritization       | As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.                                                                  |   |
 | Object Oriented Analysis  | OOA       | Use Cases                                 | As a software designer I want to document what the customer is telling me so that I can discuss my understanding of their requirements with them.                                              |   |
 |                           | OOA       | Use Cases                                 | As a software designer I want to document what the customer is telling me so that I can easily continue designing based on a joint understanding.                                              |   |
 |                           | OOA       | Conceptual Model                          | As a software designer I want to document my understanding of the problem domain so that I can easily transform this into an object oriented software system.                                  |   |
 |                           | OOA       | System Sequence Diagram                   | As a software designer I want to understand how users plan on interacting with the system so that I can design the right API endpoints.                                                        |   |
 |                           | OOA       | State Diagrams                            | As a software designer I want to document the states the application can be in so that I can better design them and get an overview of permissible transitions.                                |   |
 |                           | OOA       | Use Cases - Structuring                   | As a software designer I want to be able to reuse common proceduresbetween my use cases so that I only have to maintain them in one place.                                                     |   |
 | Object Oriented Design    | OOD       | Sequence/Collaboration Diagrams           | As a software designer I want to understand how domain concepts interact so that I can select the best way to implement these interactions.                                                    |   |
 |                           | OOA       | Dynamic vs Static                         | As a software designer I want to model both the /dynamic behaviour/ as well as the /static structure/ of the application so that I can communicate both to the developers.                     |   |
 |                           | OOD       | Class Diagrams (also Transition into)     | As a software implementer I want to know which methods and attributes each class contains so that I can implement them.                                                                        |   |
 |                           | OOD       | Package Diagrams / Architecture           | As a software designer I want to be able to divide my design into manageable chunks so that I can get a better overview.                                                                       |   |
 |                           | OOD       | GRASP Patterns                            | As a software designer I want to create a design that adheres to basic design principles so that I am sure that it will "hold" when I add more functionality and start maintaining the system. |   |
 | Design Patterns           | OOD/DP    | Design Patterns                           | As a software desginer I want to be able to use appropriate design patterns where applicable so that I do not have to reinvent the wheel for every problem.                                    |   |
 | Testing                   | Testing   | Testing, Testing Methodologies, Test Plan | As a product manager I want to make sure that we are building software of high quality.                                                                                                        |   |
 |                           | Testing   | Regression Testing, TDD                   | As a product manager I want to make sure that fixed bugs do not re-appear so that I can build the product incrementally.                                                                       |   |
 | Implementation            | Impl      | From Design to Code                       | As a software designer I want to understand how my design will be implemented so that I can facilitate the transition into code.                                                               |   |
 | Extra: Security           | OOD/DP/SE | Security Design Patterns                  | As a security engineer I want to use "secure" design patterns so that I can make sure that the product is secure by design.                                                                    |   |
 | Extra: Games              | OOD/DP/GE | Games Design Patterns                     | As a games developer I want to use commonly accepted game design solutions so that I can be reasonably sure it works within my quality constraints.                                            |   |
 | Extra: Web                | OOD/DP/WE | Web Engineering Patterns                  | As a web developer I want to be able to use design patterns especially suitable for web engineering so that I make the best use of my platform                                                 |   |
 | Extra: More Analysis Help | OOA       | Contracts                                 | As a software designer I want to have a way of thinking about what happens in a system event so that I do not miss any important effects on the system state.                                  |   |
** Goals
  | Course Code   | Course Goal                                                                                                                        |
  |---------------+------------------------------------------------------------------------------------------------------------------------------------|
  | PA1415        | - på en grundläggande nivå i grupp kunna ta fram krav på en programvara och uttrycka dem i en kravspecifikation                    |
  | PA1415        | - i grupp producera en översiktlig utvecklingsprojektplan baserat på en kravspecifikation                                          |
  | PA1415/PA1435 | - i grupp kunna skapa en detaljerad objektorienterad design för ett mjukvaruprogram                                                |
  | PA1415        | - i grupp kunna implementera ett mjukvaruprogram inom rimlig tid, baserat på en kravspecifikation och en objektorienterad design   |
  | PA1415        | - på en grundläggande nivå i grupp kunna planera och genomföra testning av producerad programvara, baserat på en kravspecifikation |
  | PA1415/PA1435 | - skapa och analysera objektorienterade artefakter uttryckta i UML                                                                 |
  | PA1415/PA1435 | - kunna motivera och använda designmönster i utvecklingen av mjukvarusystem                                                        |
  |               |                                                                                                                                    |
  | PA1435        | *Kunskap och förståelse* Efter genomförd kurs ska studenten:                                                                       |
  | PA1435        | - kunna visa förståelse för grundläggande principer i objektorienterad programvaruutveckling.                                      |
  | PA1435        | - kunna visa förståelse för UML som modelleringsspråk.                                                                             |
  | PA1435        | - kunna visa kunskap om grundläggande designprinciper.                                                                             |
  | PA1435        | - kunna visa kunskap om grundläggande designmönster.                                                                               |
  |               |                                                                                                                                    |
  | PA1435        | *Färdigheter och förmåga* Efter genomförd kurs ska studenten:                                                                      |
  | PA1435        | - kunna uttrycka strukturen och beteendet hos ett system i termer av objektorienterade koncept.                                    |
  | PA1435        | - kunna korrekt använda UML för att uttrycka struktur och beteende hos ett system.                                                 |
  | PA1435        | - kunna korrekt transformera en objektorienterad design till källkod.                                                              |
  | PA1435        | - kunna tillämpa designprinciper och designmönster i allmänhet och inom en särskild domän.                                         |
  |               |                                                                                                                                    |
  | PA1435        | *Värderingsförmåga och förhållningssätt* Efter genomförd kurs ska studenten:                                                       |
  | PA1435        | - kunna analysera källkod för eventuella förbättringar.                                                                            |
  | PA1435        | - kunna analysera och kritiskt diskutera en design för eventuella förbättringar.                                                   |
  |---------------+------------------------------------------------------------------------------------------------------------------------------------|

** Topics
  | PA1415 | PA1435 | Topic                                            |
  |--------+--------+--------------------------------------------------|
  | PA1415 |        | Development Methodologies (Waterfall/Agile/Lean) |
  | PA1415 |        | Requirements Engineering                         |
  | PA1415 |        | Project Planning                                 |
  | PA1415 |        | Work Breakdown Structures                        |
  | PA1415 |        | Project Estimations                              |
  | PA1415 |        | Testing, Different Levels                        |
  | PA1415 |        | Test Driven Development                          |
  | PA1415 |        | Test Plan                                        |
  |        | PA1435 | Basic Design Methodology (OOA, OOD)              |
  | PA1415 | PA1435 | UML - overview                                   |
  | PA1415 | PA1435 | UML Analysis                                     |
  | PA1415 | PA1435 | UML Design                                       |
  | PA1415 | PA1435 | Basic Design Patterns (GRASP)                    |
  | PA1415 | PA1435 | Design Patterns (GoF)                            |
  | PA1415 | PA1435 | From Design to Code                              |
  | PA1415 | PA1435 | Good vs Bad Design                               |
  |--------+--------+--------------------------------------------------|

** Sprints						       :OLD:noexport:
   0. [@0] Introduction/Formalia
   1. Overview of Development Methodologies
      - Waterfall
      - Agile/Lean
      - RUP
   2. Requirements Engineering
      - Requirement Elicitation
      - Requirements, User Stories, Use Cases
      - Backlog
      - Working with requirements in a Sprint
      - Requirements and Testing
   3. Planning and Estimations
      - Requirements and Prioritisations
      - Requirements for Planning
      - WBS
      - Estimations
      - Project Tracking
   4. Testing
      - Levels of Testing
      - TDD
      - Test plan
   5. Introduction to RUP/UML
      - OOA
      - OOD
      - RUP
      - UML Diagrams
      - UML Dictionary
   6. OO Analysis
      - Use Case Diagrams
      - Use Cases
      - System Sequence Diagrams
      - Conceptual Model
      - State Diagrams
      - Worked Example from Use Case to SSD and Conceptual Model
   7. OO Design
      - Interaction Diagrams
	- Sequence Diagrams
	- Collaboration Diagrams
      - Class Diagrams
   8. Basic Design Patterns
      - GRASP
   9. Common Design Patterns
   10. From Design to Code
       - Java / C++ Quirks
       - OOP in JavaScript
** Lecture Outline					       :OLD:noexport:
*** DONE Introduction (01)
    CLOSED: [2016-03-09 Wed 11:44]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-09 Wed 11:44]
    :END:      
    Classroom only

    - Course Intro
      - About MSV
      - Course Structure
      - Lecture Structure
      - Literature
      - Tools
    - Modelling why care
      - Gorschek paper
      - Sell it anyway
    - Overall OOD Development Methodology
      - Reason: Traceability
      - Reason for all the models: Analysis triangulation
    - Modelling at large
    - OO Analysis
    - OO Design
    - UML
      - Sell UML (Abstract, Precise, Pictoral)
      - UML as a collection of models
      - UML as a methodology
      - UML wankery
    - Design / Design Patterns
    - Exercise in Scale??
*** DONE Development Process (02)
    CLOSED: [2016-03-09 Wed 14:35]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-09 Wed 14:35]
    :END:      
    Upload: Methodologies
    - Waterfall
    - Iterative/Incremental
    - Kanban
    - SCRUM

    Classroom:
    - Process
      - Systematic
      - Disciplined
      - Quantifiable (!)
    - Process vs Project vs Product
    - Discuss:
      - What's good with waterfall?
      - Where would you do design in Scrum?
      - Where would you do design in Kanban?
    - Example: UML Process (Work through an example)
      - Use Case Diagrams
      - Use Cases
      - Conceptual Model
      - Class Diagram
      - Collaboration Diagram
      - Interaction Diagram
      - ?? Flowcharts 
*** DONE Requirements (03)
    CLOSED: [2016-03-17 Thu 09:59]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-17 Thu 09:59]
    :END:      
    Upload: Requirements Specifications
    - ISO 830
    - RFC 2119
    - Standard Templates for Requirements "The system must do X"
    - Standard Template for User Stories
    - Use Cases
      - Use Case Diagrams
      - High Level Use Case
      - Fully Dressed (Expanded) Use Case
    - Prioritising Requirements

    Classroom:	
    - Discuss:
      - How to Find Requirements
      - Goals, Features, Functions, Components (RAM Model)
      - Good and Bad Requirements
      - Black box vs White Box
    - Basic RE process
      - (Re-use old slides)
    - Example
      - Use Case Diagram
      - High Level Use Case
      - Fully Dressed Use Case
*** DONE Modelling Structure (04)
    CLOSED: [2016-03-22 Tue 11:15]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-22 Tue 11:15]
    :END:      
    Upload:
    - Conceptual Model Notation
      - Concept
      - Attributes
      - Associations
      - Multiplicity
      - Data Dictionary (Definition/Intention/_Glossary_)
      - Examples (Instantiated Objects)
    - Class Diagrams
      - Concept vs Class
      - Associations
      - Roles
      - Role Multiplicity
      - Attributes
      - Attribtue Types

    Classroom:
    - Discuss:
      - How to find Concepts/Attributes/Associations?
      - Difference between Attribute and Concept?
      - Multiplicity -- how to think?
    - Slides on Concept Identification
    - How to find Attributes
    - How to find Associations
    - Example:
      - Conceptual Model
      - Class Diagram
*** DONE Modelling Structure II (04)
    CLOSED: [2016-04-13 Wed 11:00]
    :LOGBOOK:  
    - State "DONE"       from "WAIT"       [2016-04-13 Wed 11:00]
    - State "WAIT"       from ""           [2016-04-13 Wed 11:00]
    - State "WAIT"       from ""           [2016-03-22 Tue 14:34]
    :END:      
    - [X] Structuring Use Cases (From Modelling Behaviour Lecture)
*** DONE Modelling Behaviour (05)
    CLOSED: [2016-04-06 Wed 14:28]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-04-06 Wed 14:28]
    :END:      
    Upload:
    - Sequence Diagram
      - Actor
      - Lifeline
      - Event
    - Contract
      - Name
      - Responsibilities
      - Preconditions
      - Postconditions
    - Extended Contract
      - Name
      - Responsibilities
      - Type
      - Cross-References
      - Notes
      - Exceptions
      - Output
      - Preconditions
      - Postconditions
    - State Diagrams
      - State / Event / Transition
      - Notation
	- Nested States
	- Activity in a State
	- Actions on Transitions

    Classroom:
    - Going from Use Case to Sequence Diagram
    - System Sequence Diagram vs regular Sequence Diagram
    - System as a modelling concept
    - Contracts
      - What are they?
      - How should you interpret preconditions?
      - How to interpret postconditions?
      - Stage-and-Curtain execution
    - Discuss:
      - What are extended contracts good for?
    - State Diagrams
      - Examples + Discussion: Common Pitfalls
      - What types of Events can there be in a state diagram?
    - Discuss:
      - How do we fit state diagrams into the UML process?
*** TODO Design -- Collaboration and Responsibilities
    Upload:      
    - [ ] Interaction Diagrams, Collaboration Diagrams
      - Classes and Instances
      - Sequence Numbering
      - ...
    - [ ] Conditions, etc.
    - [ ] Real Use Cases

    Classroom:
    - [-] Discuss
      - What is the difference between Sequence diagrams and Collaboration Diagrams
    - [-] Example:
      - Go from Class Diagram to Sequence Diagram
*** DONE Design Patterns I/II (06) (08, 09)
    CLOSED: [2016-04-21 Thu 14:25]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2016-04-21 Thu 14:25]
    :END:
    Upload:
    - GRASP Patterns
      - Expert
      - Creator
      - Low Coupling
      - High Cohesion
	- Don't talk to strangers
      - Controller
      - Polymorphism
    - Design Patterns
      - Observer
      - Singleton
      - Strategy
      - State
      - Abstract Factory
    - Architecture
      - Layered
      - MVC

    Classroom:
    - Design Patterns Background
    - Levels of Patterns
      - Architecture
      - Design
      - Idioms
      - GRASP
    - Discuss:
      - Design Patterns:
	- Domain Modelling or Development tricks
	- What are they good for?
	- Limitations?
    - Example:
      - How to apply GRASP
      - How to apply DP
      - How to apply AP
    - Example:
      - How to Implement DP's
*** TODO Mapping Design to Code (07)
    Classroom:
    - Implementation Order
    - Class Creation
      - (Why bother, it's done by the tool anyway)
      - Attributes, Methods, etc.
    - Code from Sequence Diagrams
      - This is not automatic, because crappy tools.
    - Language Differences
      - Multiple Inheritance vs Inner Classes vs Anonymous Classes
      - Pointers vs References
      - Aggregation vs Strong Aggregation
      - Callback Programming (Event-Driven Arch.) (Node.js and its ilks)
	- https://blog.risingstack.com/fundamental-node-js-design-patterns/
      - Stateful EDA's??
      - Dependency Injection (Might hold a discussion on this one)
      - NULL as return values
      - Defensive Programming
	- http://c.learncodethehardway.org/book/ex27.html
	- Discuss: Good or Bad? Better to Fail Early?
** Links							   :noexport:
   IEEE 829-2008: http://www.fit.vutbr.cz/study/courses/ITS/public/ieee829.html
