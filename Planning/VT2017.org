#+Title: Software Design Courses
#+INCLUDE: "../Site/org/header.org-in" org



* Sprint Structure						   :noexport:
** About This Sprint
** User Stories covered in this Sprint
** Introduction
** Learning Material
*** Book Chapters
*** Screencasts
*** Lectures
*** Articles
*** Further Reading
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - 

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment Submission
*** Update Course Backlog

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* Sprint Map							   :noexport:

 old
 :NOTES:
 | Topic                    | Sprint                                 | Delivery     | PA1415 | PA1435 | PA1443 |
 |                          |                                        |              | 7.5 hp | 6 hp   | 5 hp   |
 |--------------------------+----------------------------------------+--------------+--------+--------+--------|
 | Course Intro             | Sprint 0: Course Introduction          |              | Yes    | Yes    | Yes    |
 | Software Development     | Development Methodologies              |              | Yes    |        |        |
 |                          | Requirements Engineering               |              | Yes    |        |        |
 | Object Oriented Analysis | Use Cases and Use Case Diagrams        | Submission 1 | Yes    | Yes    | Yes    |
 |                          | Concepts and Events                    |              | Yes    | Yes    | Yes    |
 |                          | State Diagram                          |              | Yes    |        |        |
 | Quality Assurance        | Testing                                |              | Yes    | Yes    |        |
 | Object Oriented Design   | Good Interactions                      |              | Yes    | Yes    | Yes    |
 |                          | Interactions and Structure             | Submission 2 | Yes    | Yes    | Yes    |
 |                          | Design Patterns                        |              | Yes    | Yes    | Yes    |
 | Software Architecture    | Introduction to Software Architectures |              |        |        | Yes    |
 |                          | Software Architecture Patterns         |              | Yes    | Yes    | Yes    |
 | From Design to Code      | Designing the User Interface           |              | Yes    |        |        |
 |                          | Implementation                         | Submission 3 | Yes    | Yes    |        |
 | Course Wrap-up           | Preparing for Exam                     |              | Yes    | Yes    | Yes    |
 |                          | Sprint 99: Finalising the Course       |              | Yes    | Yes    | Yes    |
 |--------------------------+----------------------------------------+--------------+--------+--------+--------|
 :END:


 Connection between Lectures and Sprints, and which courses should follow what lectures/Sprints
 | Offset week | Week | Lecture                        | Seminar                       | Sprint                                          | PA1415 | PA1434 | PA1435 | PA1443 |                                            |
 |             |      |                                |                               |                                                 | 7.5 hp | 4 hp   | 6 hp   | 5 hp   |                                            |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |           1 |   13 | Introduction                   |                               | Course Introduction                             | X      | X      | X      |        |                                            |
 |           1 |   13 | Development Process            |                               | Development Methodologies                       | X      |        |        |        |                                            |
 |           2 |   14 | Requirements Engineering       |                               | Requirements Engineering                        | X      |        |        |        |                                            |
 |       mid 2 |   14 | Introduction (rep)             |                               | Course Introduction                             |        |        |        | X      |                                            |
 |      late 2 |   14 | User Stories and UML Use Cases |                               | Use Cases and Use Case Diagrams                 | X      | X      | X      | X      | x2                                         |
 |      late 2 |   14 |                                | Req, Use Case, Planning       |                                                 | S      | S      | S      | S      |                                            |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |       mid 3 |   15 |                                |                               | Release Sprints A1v1 (Req & UC)                 | A1v1   |        |        |        |                                            |
 |       mid 3 |   15 |                                |                               | A1v2 (UC)                                       |        | A1v2   | A1v2   |        |                                            |
 |     early 5 |   17 |                                |                               | A1v2 (UC)                                       |        |        |        | A1v2   |                                            |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |           3 |   15 | Structure                      |                               | Concepts and Events                             | X      | X      | X      | X      | x2                                         |
 |           3 |   15 | Testing                        |                               | Testing                                         | X      |        |        | X      |                                            |
 |     early 4 |   16 |                                | Discuss A1                    |                                                 | AS     | AS     | AS     |        |                                            |
 |           4 |   16 | Behaviour                      |                               | State Diagram                                   | X      |        |        |        | x2                                         |
 |           " |    " | "                              |                               | Good Interactions                               | X      | X      | X      | X      | "                                          |
 |           " |    " | "                              |                               | Interactions and Structure                      | X      | X      | X      | X      | "                                          |
 |           4 |   16 | Design Patterns                |                               | Design Patterns                                 | X      | X      | X      | X      | x2                                         |
 |           5 |   17 |                                | Structure and Design Patterns |                                                 | S      | S      | S      | S      |                                            |
 |      late 5 |   17 |                                | Discuss A1                    |                                                 |        |        |        | AS     |                                            |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |           6 |   18 |                                |                               | Release Sprints A2v1 (OODesign)                 | A2v1   | A2v1   | A2v1   |        |                                            |
 |           7 |   19 |                                |                               |                                                 |        |        |        | A2v1   |                                            |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |           5 |   17 | Software Architectures         |                               | Introduction to Software Architectures          |        |        |        | X      |                                            |
 |           " |    " | "                              |                               | Software Architecture Patterns                  |        |        |        | X      |                                            |
 |           5 |   17 | Quality Attributes             |                               | Introduction to Software Architectures          |        |        |        | X      |                                            |
 |           5 |   17 | From Design to Code            |                               | Implementation and Designing the User Interface | X      | X      | X      | X      | x2                                         |
 |           6 |   18 |                                | Software Architectures        |                                                 |        |        |        | S      |                                            |
 |           6 |   18 |                                | Open Discussion               |                                                 | S      | S      | S      | S      |                                            |
 |           7 |   19 |                                | Discuss A2                    |                                                 | AS     | AS     | AS     | AS     |                                            |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |           8 |   20 |                                |                               | Release Sprint A3v1 (Testing, Implementation)   | A3v1   |        | A3v1   |        |                                            |
 |      late 8 |   20 |                                |                               | A3v2 (Testing)                                  |        |        |        | A3v2   | Merge A3v2 and A4v1?                       |
 |           9 |   21 |                                |                               | Release Sprint A4v1 (Architecture)              |        |        |        | A4v1   |                                            |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |           7 |   19 | Questions and Answers          |                               | Preparing for the Exam                          | X      | X      | X      | X      | x2                                         |
 |           " |    " | "                              |                               | Finalising the Course                           | X      | X      | X      | X      | "                                          |
 |           9 |   21 |                                | Demo & Discuss A3             |                                                 | AS     | AS     | AS     | AS     | Possible? Exam weeks? Book times per group |
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |-------------+------+--------------------------------+-------------------------------+-------------------------------------------------+--------+--------+--------+--------+--------------------------------------------|
 |             |      | # Lectures                     |                               |                                                 | 10     | 7      | 7      | 11     |                                            |

 Note: Academic year 2017 lp4: week 13-22. Assuming exam weeks last two or three weeks.
* TODO Course PM
* TODO Resubmissions
* TODO Group and Team Instructions
* TODO Lectures
 Lectures
 1. [ ] Introduction
    - Course Intro
    - Modelling Why care
    - Overall OOD Development Methodology
    - Modelling at large?
    - OO Analysis
    - OO Design
    - Sell UML
    - Design /Design Patterns
    - Exercise in Scale
 2. [ ] Development Process
    - Process
    - Process vs Project vs Product
    - Waterfall vs Iterative
    - UML Process
    - [ ] Process planning
      - [ ] Story Points
      - [ ] Burndown
      - [ ] GANTT
      - [ ] WBS
 3. [ ] Requirements Engineering
    - Elicitation
    - Goals, Features, Functions, Components
    - Good and Bad
    - Black Box vs White Box
    - Basic RE Process
    - User Stories
 4. [ ] User Stories and UML Use Cases
    - Use Cases
    - Use Case Diagrams
 5. [ ] Stucture
    - Concepts and Events
    - Class Diagrams
    - Packages
      - Use ch35
 6. [ ] Testing
 7. [ ] Behaviour
    - From Use Cases to System Sequence Diagram to Interaction Diagram
    - Contracts?
    - State Diagrams
    - From Interaction Diagrams to Class Diagrams
 8. [ ] Design Patterns
    - Background
    - Levels
    - Example Apply GRASP
    - Example Apply DP
    - Example Apply AP
    - [ ] Discuss how this influences Design and assignments.
 9. [ ] Software Architectures
 10. [ ] Quality Attributes
     - Importance of attributes and architecture
     - Different Attributes
     - Stimulus-response model
     - Tactics
 11. [ ] From Design to Code
 12. [ ] Q&A
* DONE 3 week roll call
  CLOSED: [2017-02-17 Fri 14:09]
* DONE Pick System!
  CLOSED: [2017-02-17 Fri 13:30]
  TwitterNethack
  Busstop(Ewan) ? Not many use cases here...
* DONE Deadlines
  CLOSED: [2017-02-17 Fri 10:28]
  | Assignment | Course         | Date                   |
  |------------+----------------+------------------------|
  | Release 1  | PA1415, PA1435 | <2017-04-12 Wed 08:00> |
  | Release 1  | PA1443         | <2017-04-24 Mon 08:00> |
  |            |                |                        |
  | Release 2  | PA1415, PA1435 | <2017-05-03 Wed 08:00> |
  | Release 2  | PA1443         | <2017-05-08 Mon 08:00> |
  |            |                |                        |
  | Release 3  | PA1415, PA1435 | <2017-05-17 Wed 08:00> |
  | Release 3  | PA1443         | <2017-05-19 Fri 08:00> |
  |------------+----------------+------------------------|
* DONE PA1443 Assigment 3/4
  CLOSED: [2017-02-17 Fri 10:11]
* DONE Make sure that acceptance tests include commit/push
  CLOSED: [2017-02-17 Fri 10:11]
* DONE Seminars [7/7]
  CLOSED: [2017-02-15 Wed 13:37]
** DONE Requirements Use Cases Project Planning
   CLOSED: [2017-02-15 Wed 13:37]
** DONE Discuss Assignment 1
   CLOSED: [2017-02-14 Tue 14:56]
** DONE Structure and Design Patterns
   CLOSED: [2017-02-14 Tue 14:56]
** DONE Software Architectures
   CLOSED: [2017-02-15 Wed 13:37]
** DONE Open Discussion
   CLOSED: [2017-02-14 Tue 14:56]
** DONE Discuss Assignment 2
   CLOSED: [2017-02-14 Tue 14:56]
** DONE Demo and Discuss Assignment 3
   CLOSED: [2017-02-14 Tue 14:56]
** Booking Instructions

Hi,

Today I have scheduled the lectures. It turns out that many of the parallel courses have already placed their schedules, so there is not much wiggle-room left for us.

Therefore I would like you to schedule the seminars as quickly as possible.

The seminars are supposed to be run in groups of 25-30 people. This means the following:

| PA1415 | 73 students in total | 3 groups |
| PA1435 | 51 students in total | 2 groups |
| PA1443 | 44 students in total | 2 groups |

And I would like you to place the seminars /around/ the following times. It is not critical that they end up exactly at these times, but I would prefer them to be as close as possible.

- Seminar 1: Requirements Use Cases and Project Planning
  - PA1415 and PA1435: First half of Week 14
  - PA1443: Second half of Week 14.

- Seminar 2: Discuss Release 1
  - PA1415, PA1435: Early Week 16
  - PA1443: Late Week 17

- Seminar 3: Structure and Design Patterns
  - PA1415, PA1435, PA1443: Early Week 17

- Seminar 4: Software Architectures
  - PA1443: Week 18
  - (PA1415, PA1435: Not applicable)

- Seminar 5: Open Discussion
  - PA1415, PA1435, PA1443: Week 18

- Seminar 6: Discuss Release 2
  - PA1415, PA1435, PA1443: Week 19 

- Seminar(ish) 7: Demo and Discuss Release 3
  - Book individual times (15-20 min) with each team to demo and discuss their system, sometime during weeks 20.

I remind you that the courses are live at: https://mickesv.github.io/OODesign/ . Follow the links to each course and seminar to see instructions for the seminar. I have kept them fairly high-level at the moment -- feel free to ask if you need more information.

As I said to Raquel, if you want to divide your hours differently from what is already planned so that one of you do more "front-end" work and the other do more "back-end" work, I am fine with this. The "Discuss Assignment X" seminars may need more coordination if you choose such a model, though.

/Mikael
* DONE Sprint 0: Course Introduction
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* DONE Sprint: Development Methodologies
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* TODO Sprint: Requirements Engineering
** About This Sprint
   This sprint briefly introduces the topic requirements engineering. It is primarily targeted at {{{pa1415}}}.
   
   For more information on this topic, see e.g. the course ~PA1412 Praktisk Kravhantering~.

#+BEGIN_note
   *Note:* In this sprint you will begin with what will eventually be delivered as a part of Assignment 1. In subsequent sprints you will continue with what you produce here and dive deeper into UML. You will thus only produce a partial delivery in this sprint.
#+END_note
** User Stories covered in this Sprint
   - As a requirements engineer I want to know who may have requirements on the system we are building so that I can make sure that all needs are met.
   - As a requirements engineer I want to have a range of methods for finding requirements so that I can choose the best method for each person or source of requirements.
   - As a requirements engineer I want to document the found requirements so that I can discuss them with the customer.
   - As a requirements engineer I want to document the found requirements so that I can communicate them to the developers.
   - As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.
** Introduction
   Before you start designing your system, you need to find out /what/ to design and build. There are of course different ways of doing this. The traditional way advocates that you need to fully understand the entire system before you go ahead with the design (cf. /waterfall development/), whereas at the other end the agile approach (e.g. as advocated by [[http://www.extremeprogramming.org/][eXtreme Programming]] and the [[http://agilemanifesto.org/][Agile Manifesto]]) is that you should only do as much requirements engineering up front as is necessary to understand how to start building, since the requirements are going to change anyway. Note that they do not say "Don't do it!"; they say "Do as little as possible, but not less".

   It is thus important to decide early how much requirements engineering you should do before you start with the project. Incidentally, there is a difference between the traditional, so called /bespoke/ requirements engineering where you start a project when a customer knocks on the door and then you do requirements engineering as part of that project, and the /continuous/ requirements engineering where you always do requirements engineering and spawn new development projects as a result of the requirements engineering process. The latter suits the type of products that you develop and sell to more than one customer, while the former is more suitable for one-off projects. For this course, I would suggest a pragmatic approach (akin to the agile way): Do as much requirements engineering so that you have a rough overview of what the system should do, and do proper requirements engineering on what you need to know do make a Minimum Viable Product. 

   There are many sources and techniques for doing requirements elicitation (i.e., finding the requirements), from reading the old documentation, analysing competitor's products, interviewing users, running surveys among user groups, or simply inventing the requirements yourself. If you do requirements engineering you will be using a mixture of these. Typically, you will start by doing an unstructured interview with a manager to get a broad overview of what they want the system to do. You will then try to define end user groups and find a couple of representative persons from each user group and conduct further interviews with them. At first, these interviews will be exploratory and unstructured, but will pretty soon become semi-structured as you learn about the major features of the system, so that you will be getting further details about each of these major features.

   Finding out who may have an interest in the system (a /stakeholder/) is so important that I have even added a separate user story for it in this sprint. This is not limited to end-users. Other stakeholders may include (but is not limited to): the organisation that is going to maintain and continue development of the system, system service technicians that will be doing backups and adding users and other running maintenance, external parties that you may connect to (for example banks to deal with payments), legal texts (that's right: a text can be a stakeholder), other departments in the organisation you build for that require your system to jack in with their processes, and so on.

#+CAPTION: Requirements Engineering Overview (Simplified)
#+NAME: fig:REProcess
[[./images/FRE_Process.png]]

*** Interviews
I've already touched upon elicitation techniques. The one you are likely to use the most is /Interviews/. "Interview" is actually a cover-all phrase that encompasses a whole range of different techniques that involves two people or more with (at least) voice contact. You /may/ thus do interviews over phone, but I would not recommend it since you loose a lot of nuances that can be learnt by observing body language. Video conference or face-to-face meetings IRL are the most common interview settings. You can be one person interviewing one other person, or there can be more people either doing the interview or being interviewed (although at some point it is perhaps better to run the meeting as a [[https://en.wikipedia.org/wiki/Focus_group][focus group]]).

In its most simple form, you conduct the interview as an /open interview/ with /open answers/. In this setting, you basically just talk, and together explore what the application should do. You rarely have the luxury to be this unstructured, even in the first interview. I would recommend you to do as much homework as possible beforehand so that you have at least a small set of starting questions that you can use to get the interview going and to get back on track when you feel that you have diverged too far from the interview goals. Having a set of questions moves the interview into a /semi-structured/ format, where you are able to follow up on the answers given with further impromptu questions. The extreme is a /structured/ interview where you have a specific set of questions that you want answered in a particular order without room for any further probing. This is typically only used in research contexts.

Similarly, you can allow /open answers/, typically early on when you want to explore and look for new information, or you can restrict the answers to a /closed answer/ space, where each question can e.g. be answered with one of four alternatives. This is good for confirming what you have previously learnt; you can collect answers from larger groups of people and quickly analyse them, and the idea is that at that stage you should not expect to find any new information.

Thus, a requirements engineer will probably use semi-structured open answered interviews. In this course, however, this will not be the case as it would be out of scope for the course. You will instead have to create the requirements yourself (more on this under the Experiential Learning in this sprint).

How you behave during an interview influences the results, because your behaviour can make the interview subjects more or less prone to answer your questions. In Table [[tab:InterviewsDnD]] I have compiled a list of do's and don'ts in interview situations (we have actually used this list to assess requirements elicitation interviews in the requirements engineering courses at BTH).

#+CAPTION: Do and Don't in an Interview Situation
#+NAME: tab:InterviewsDnD
| Do                                                       | Don't                                                                    |
|----------------------------------------------------------+--------------------------------------------------------------------------|
| Do    prepare thoroughly for the meeting                 | Don't put your laptop on the table as a wall between you and your client |
| Do    prepare a checklist for the meeting                | Don't keep your cap on your head                                         |
| Do    introduce yourself properly                        | Don't interrupt the customer                                             |
| Do    ask about access to stakeholders                   | Don't interrupt each other                                               |
| Do    ask about access to previous systems               | Don't take no notes                                                      |
| Do    book the next meeting                              | Don't record the interview without asking                                |
| Do    ask about quality requirements                     | Don't assume stuff                                                       |
| Do    make sure you know who you are talking to, and why | Don't provide requirements                                               |
| Do    ask about deadlines                                | Don't provide goldplating                                                |
|                                                          | Don't technobabble                                                       |
|                                                          | Don't sit quiet                                                          |
|                                                          | Don't kiss up (too much)                                                 |
|                                                          | Don't follow your meeting checklist manically                            |
|                                                          | Don't share war-stories about other customers and systems                |
|                                                          | Don't ask about the budget at the first meeting                          |
|                                                          | Don't argue among yourselves                                             |
*** Specification
    Once you have found the requirements, your next step (after analysing them and negotiating them with the customer, but that is also outside the scope of this course) is to /Specify/ the requirements. There is an IEEE standard, [[fig:SRS][IEEE 830]], for how to structure your requirements document, assuming you specify requirements in the traditional way. The good thing about this is that it has existed for many years, and people are used to seeing it and signing contract based on it. The bad thing about it is that it is not as well known or easy to understand as requirements engineering researchers would like to think it is, and with a few moments of education I am certain that you will be able to educate your customers on any document and requirements format you choose.

#+NAME: fig:SRS
#+BEGIN_info
*IEEE 830 Standard for Software Requirements Specifications*
   1. Introduction
      1. Purpose of the Requirements Document
      2. Scope of the Product
      3. Definitions, Acronyms, and Abbreviations
      4. References
      5. Overview of the Remainder of the Document
   2. General Description
      1. Product Perspective
      2. Product Functions
      3. User Characteristics
      4. General Constraints
      5. Assumptions and Dependencies
   3. Specific Requirements
      Functional, non-functional, and interface requirements
   4. Appendices
   5. Index
#+END_info

To simplify, there are two plus one ways of writing requirements. The two ways are traditional requirements and user stories. The plus one way is UML use cases. UML:ists themselves claim that use cases are not requirments, they are merely scenarios where one or several requirements are "exercised". I would rather avoid re-formatting the requirements once more and just add more documentation that will only be used once, so I would try very hard to get away with only documenting the requirements within the context of a use case if I must use them.

#+BEGIN_SRC ditaa :file ./images/FRESpecification.png
        +------------------+  +-----------+
        | Requirements     |  | UML       |
        | cGRE             |  | Use Cases |
        |                  |  | cBLU      |
        +------------------+  |           |
                              |           |
        +------------------+  |           |
        | User Stories     |  |           |
        | cGRE             |  |           |
        |                  |  |           |
        +------------------+  +-----------+
#+END_SRC

#+CAPTION: Two plus one way of specifying requirements
#+NAME: fig:REtwoplusone
#+RESULTS:
[[file:./images/FRESpecification.png]]

Traditional requirements may be specified as figures, tables, sketches, or plaintext, with the plaintext version being the one most commonly discussed. They usually follow a standardised format with a number of attributes per requirement (title, description, source, date, etc.), and a standardised template for the actual requirement. User Stories are supposed to be less documentation so they try to include the most relevant of all of this information into a single one-liner. Shorter iterations, a more direct path from inception to implementation, and closer collaboration with the customer makes it easier to do away with a lot of the information considered necessary in traditional requirements.

UML use cases are covered in a different course sprint, so I will only briefly mention them here. With a use case, you are attempting to put the requirements into a context. Of course, this means that you need to write more, since you also need to add information about the context. This is one of the reasons why they are not considered requirements -- they are simply too verbose. This verbosity also means that a developer is unlikely to do use cases for every requirement and every part of the system; but will rather do them for those parts of the system where there is a usage flow that is difficult to grasp in one sentence, and where you are likely to hold a "conversation" with the system to fulfill a higher need. For example, searching for a hotel room is a one-liner. /Booking/ a room on the other hand may involve
- a search
- a narrowing of the results to specific types of rooms
- a check whether the room is available
- a selection of the room
- input of information about the person booking the room, and
- a confirmation that the room is booked.

Each of these items may, in turn, comprise more than several requirements, including at least one requirement that restricts the order in which these actions must be performed.

*** Prioritisation
[[./images/I0Programmer.jpg]]

So, which requirement should you focus on developing first?

In traditional requirements engineering, there is a whole phase solely dedicated to requirements prioritisation. Agile software development methodologies (such as Scrum) also assumes that you always have your user stories prioritised in your backlog. Essentially, you are doing insertion sort whenever you add a new user story, while also checking that the priority of the existing items do not change as a result of adding the new user story. Each sprint begins with a review of the backlog, before you select among the top prioritised user stories which you should develop in the sprint. If the user story is really big (called an /epic/), one of the actions you may do is to break it down into more manageable user stories and put these into the backlog.

This, of course, does not answer the question since it only explains /how/ you decide, but not /on what grounds/. Also here, you can probably build a research career on deciding which factors should influence your prioritisation (see, for example, Ruhe and Saliu's paper "The art and Science of Release Planning" [fn:Ruhe]), but a few good starting points are:

- Value for the customer
- Cost of implementation (Cost and Value can be nicely combined as e.g. Karlsson and Ryan [fn:CostValue] shows).
- Penalty for not implementing

UML/RUP would advocate that you wait with prioritising your requirements and instead prioritise the UML use cases, so that you deliver the most important features first. This does not mean that you need to implement the full flow of events in one go; always keep the Minimum Viable Product in mind.

[fn:Ruhe] G. Ruhe and M. O. Saliu. /The art and science of software release planning/. IEEE Software, 22(6):47–53, 2005.
[fn:CostValue] J. Karlsson and K. Ryan. A cost-value approach for prioritizing requirements. IEEE Software, 14(5):67– 74, 1997.

*** Summary
Requirements Engineering is a big topic, and can be quite complex. The introduction above is just meant to get you started. I have, for example, only touched upon the difference between bespoke and market-driven requirements engineering. I have not mentioned any of the challenges involved when you do large scale requirements engineering or very large scale requirements engineering. Nor have I gone through all the different techniques available for eliciting requirements, checklists for analysis, requirements verification, etc. etc. You will get some more information about some of these things in the screencast "Requirements Engineering", and for the rest I direct you towards one of the requirements engineering courses offered at BTH.

I include some of the UML Use Case learning material in this sprint which will give you a head start for the next sprint, but the focus on what you are expected to do is "traditional" requirements engineering.

A note also about elicitation techniques: I say earlier that you are most likely going to use interviews. Well... In this course that's not quite true. In this course you are going to create the requirements yourself, based on a brief system description.
** TODO Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      4. [@4] Inception is Not the Requirements Phase
      5. Evolutionary Requirements
      6. Use Cases
      7. Other Requirements
*** Screencasts
      - [[https://play.bth.se/media/Requirements+Engineering/1_epma2li8/41750261][Requirements Engineering]]
      - [[https://play.bth.se/media/Use+Cases/1_d4tqygel/41750261][Use Cases]]
*** TODO Lectures						   :noexport:
    Ideas:
    - Requirements Elicitation Roleplay?
    - Good and Bad Requirements?
*** Further Reading						   :noexport:
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Requirements Engineering
      - Requirements Elicitation
      - Stakeholders
      - Software Requirements Specification (SRS)
      - RFC 2119
      - Requirements Prioritisation
    - Quality Attribute (Also: Non-functional Requirement)
    - User Story
    - Epic
    - Backlog
    - Acceptance Test
    - Use Case

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.
*** Self-Study: Requirements Interview
    Let's say you are going to build a student simulator. As a part of this you need to find out the morning practices of a typical student.
    
    Interiew a couple of student colleagues on what they do in the mornings. Try to plan beforehand, and have your colleague assess what you do good and what you can improve during the interview.
*** Self-Study: Requirements Specification
     Try to write down a common process for what you elicited above, i.e. the "getting up, getting ready, and getting to uni in the morning"-process.

     Express this process as:
    - regular requirements (consider their apartment, their mother, the bus, etc. as part of "the system")
    - user stories (think about the role they have for each part, and the motivation for why they want something done)
    - use cases  (consider their apartment, their mother, the bus, etc. as part of "the system")
*** Assignment: Requirements Document
    Your main task is to write user stories based on the system description for the assignments.

    *Tasks*
    1. Describe the system in terms of the most important workflows, as "epics". Add conditions of satisfaction to each epic.
    2. List the epics in order of importance, and add a brief motivation for why you have ordered them the way you have.
    3. Take the three most important epics, and break them down to more manageable user stories. Add conditions of satisfaction to the user stories. Order them according to priority, and add a brief motivation.

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(User Stories)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] High-level Epics
   1. Motivation for Priority
   2. Epics (ordered most important first)
4. User Stories
   1. Motivation for Priority
   2. User Stories and Epics (ordered most important first)
5. References
#+END_info    

#+BEGIN_note
*Please note* that the "User Stories and Epics" shall include /both/ the remaining epics from section 3 in the document /and/ the broken down user stories.

*Please also note* that the user stories from the epics that you break down will probably be interlaced; the least important user stories from the top-most epic need not be more important than the most important user stories from the second epic. You will thus have to review the priorities of /all/ user stories against all other user stories and epics.

*Please also also note*, when you go forward you will want each user story to have a unique ID so that you can refer back to them.
#+END_note

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution 
1. Size of assignment: Are there 5-10 epics and 10-30 user stories?
2. Is there a significant difference in scope between the epics and the user stories?
3. Are the epics and user stories well formed (including actor, goal, and reason)?
4. Are there relevant conditions of satisfaction for each user story/epic?
5. Is there a reasonable motivation for the priorities of the epics and user stories?
6. Does the prioritisation actually follow the motivation?
#+END_tip

*** Update Course Backlog
    How do you translate your user stories into UML use cases? How do you use the prioritised order to decide on a development schedule? Why are you specifying your requirements first as user stories if you are then going to re-specify them as UML use cases immediately afterwards?

    What other means are there for eliciting requirements? How may you gain experience in using them?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have read the Learning Materials.
   - You have created the "User Stories" document and committed/pushed it to your project repository.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Performed self-study requirements interviews
   - Documented the results from the self-study interviews in different formats.
* DONE Sprint: Use Cases and Use Case Diagrams
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* DONE Release Sprint: User Stories and Use Cases		  :A1:PA1415:
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* DONE Release Sprint: Use Cases		    :A1:PA1435:PA1434:PA1443:
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* DONE Sprint: Concepts and Events
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* TODO Sprint: Testing
** About This Sprint
   In this sprint we momentarily pause the steady onmarch of UML and instead focus on how to test the designed software.
** User Stories covered in this Sprint
   - As a product manager I want to make sure that we are building software of high quality.
   - As a product manager I want to make sure that fixed bugs do not re-appear so that I can build the product incrementally.
** Introduction
   This introduction is partially written with the help of my honourable esteemed colleague Dr. Simon Poulding. And when I say "partially" I mean that substantial parts of this introduction consists of texts that he has written and that I have creatively borrowed, brutally slaughtered, and put back into a different order. Not necessarily better, but different.

   I guess that all of you have heard of the importance of testing your code by now. The sad story is that many professional software developers have still only heard of the importance but not seen it in practice. In many cases, testing is something you tack on at the end of a project if there is time. Of course, since there never is time left at the end of a project, you ship the code and let the customers discover the faults instead. The situation has gotten better, but it is still not good. That's why I want to raise the topic already now in the course.

   One of the reasons for why testing is considered a time consuming activity is because you are doing manual testing. You have test protocols, you have dedicated testers who follow these protocols and conduct certain actions with the application in a certain order, and document the results. Obviously, we can do better than this. If we are testing the user interface, there are test harnesses for this that simulates button clicks, enters text into text boxes, and compares the end state of the user interface with images of predefined end states, etc (Actually, you might want to study the work of another colleague of mine, Emil Alégroth, on this particular topic).

   But even if we decide not to do automated testing of the user interface, we can attach a test harness that pretends to be the user interface.

#+NAME: fig:TestInterface
#+CAPTION: A Testing Interface sitting next to the User Interface, acting like an alternative user interface.
[[./images/FSSDTest.png]]

Digging even further, we can use testing frameworks that intergate with our development environment. [[http://junit.org/][JUnit]] is one example of this when plugged in to Eclipse. You can also run JUnit as a standalone application, which may sometimes have some advantages. It's nice and all to see the results of testing directly in your IDE, but you will also want to run these tests headlessly on an automated build server.

*** Types of Testing
Which tool or method to use depends very much on what the intentions are of your testing. L. Crispin and J. Gregory [fn:Crispin] introduce four quadrants of (agile) testing that describes the types of testing that one may be doing (see Figure [[fig:TestQuadrants]]).

#+BEGIN_SRC ditaa :file ./images/FTestQuadrants.png
                            Business Facing 

             +---------------------+------------------------+
             | Functional Tests    | Exploratory Testing    |
             | Examples            | Scenarios              | 
   Supporting| Story Tests         | Usability Testing      | Critique
   the       | Prototypes          | User Acceptance Testing| Product
   Team      | Simulations         | Alpha/Beta             |
             |                cGRE | cGRE                   |
             +---------------------+------------------------+
             | Unit Tests          | Performance and Load   |
             | Component Tests     |   Testing              |
             |                     | Security Testing       |
             |                     | "ility Testing"        |
             |                     |                        |
             |                cGRE | cGRE                   |
             +---------------------+------------------------+
 
                          Technology Facing
#+END_SRC

#+NAME: fig:TestQuadrants
#+CAPTION: Agile Testing Quadrants (Adapted from Crispin & Gregory 2009)
#+RESULTS:
[[file:./images/FTestQuadrants.png]]

*Technology Facing & Supporting the Team (lower left quadrant)*
This quadrant represents testing defined by the programmers that verifies the functionality of
individual units or components in the system in order to ensure the internal code quality.
In many agile practices, this type of testing plays a central role through the technique of test-driven
development (TDD). In TDD, the developer writes a test for a piece of functionality, and then
develops the code to pass that test. More on this later.

*Business Facing & Supporting the Team (upper left quadrant)*
This quadrant considers testing that in contrast to unit/component testing considers
functionality at a higher level such that it is meaningful to the customer, and with the purpose of
demonstrating that the functional behaviour of the system is consistent with the
requirements.

The tests in this quadrant may be derived from the user stories and examples provided by the
customer team. Crispin and Gregory avoid the use of "acceptance test" that is often used for these
types of tests on the basis that tests in other quadrants may also be used for this purpose.
In addition, Crispin and Gregory consider prototypes etc. used as part of the dialogue with the
customer to belong to this quadrant -- even mock-ups of, for example, a GUI on paper.

*Business Facing & Critique Product (upper right quadrant)*
This quadrant encompasses manual testing that ensures that the system is really what the
customer wants rather than simply meeting the team’s understanding of what the customer
requires. Crispin and Gregory argue that exploratory testing -- unscripted and unconstrained
testing guided by strategy and experience -- is a core form of testing in this quadrant.

*Technology Facing & Critique Product (lower right quadrant)*
This quadrant considers types of tests related to non-functional aspects of the system such as
security, performance, ability to handle load, scalability, reliability, safety, maintainability,
interoperability etc.

We are not going to go through all of these types of testing strategies in this course, but it gives you a map to understand how your selected test strategies fit together and what you ought to do to produce a sufficient test strategy for your project.

[[./images/IUnitVsIntegration.gif]]

[fn:Crispin] Lisa Crispin, Janet Gregory, "Agile Testing -- A Practical Guide for Testers and Agile Teams", Pearson Education, 2009.

*** Regression Testing
    The lower half of Crispin & Gregory's testing quadrants are particularly interesting because we are able to introduce /regression testing/. What this means is that we have a large set of test cases that we are able to execute automatically, for example daily or after each commit. The main benefit of this is that it instills confidence in the developers that what they just produced didn't accidentally break something else.

    I once attended a seminar with Prof. Hans van Vliet where he asked us "what do you think takes the most time in software maintenance?"
    - Understanding what the problem is
    - Understanding where to fix the problem
    - Understanding how to fix the problem
    - Understanding the cascade effects of fixing the problem.

      [[./images/IRipple.jpg]]

    If you guessed "understanding the cascade effects" you guessed right, but that is slowly changing with the advent of tools for automated testing and development practices such as /Test Driven Development (TDD)/, but also by modern behaviour-driven test frameworks such as [[https://cucumber.io/][Cucumber]]. The common denominator for these frameworks is that you write your tests early, and in executable format so that you can quickly re-run them. TDD takes it one step further with its very fast red-green-refactor cycle (basically write /one/ line of tests that fails, then write the (small) code to pass, and then shape it up and put it in the right place etc.). Connect this back to Prof. van Vleet's question: You no longer need to understand the cascade effects because you have tests in place that will start failing.

*** Tools for Automated Testing
    Which tool to use for your automated testing is of course highly dependent on your choice of development platform, and you also need to work on different levels, as illustrated in Figure [[fig:TestingLevels]]. In this figure, the left-hand-side is what you would normally encounter during a build cycle, and this is also the parts where you can hope to automate. In fact, the only difference between testing "Inside the IDE" down to "Nightly Builds" is that you will run more test-cases during your nightlies than in the IDE, where you may focus only on the tests that are relevant for what you are doing right now. You will use the same testing tools.

#+BEGIN_SRC ditaa :file ./images/FTestingLevels.png
  +------------------------------+  +-------------------------------+
  | Inside the IDE               |  | Usability Testing             |
  |               c7CC           |  | Acceptance Testing            |
  +------------------------------+  |                               |
  | As part of Compile-cycle     |  |                               |
  |                         cBLU |  |                        cGRE   |
  +------------------------------+  +-------------------------------+

  +------------------------------+  +-------------------------------+
  | Regression Tests             |  | "Release Hardening"           |
  | During Commit           cBLU |  |                               |
  +------------------------------+  |                               |
  | Nightly Builds               |  |                               |
  |                         cBLU |  |                        cGRE   |
  +------------------------------+  +-------------------------------+
#+END_SRC

#+NAME: fig:TestingLevels
#+CAPTION: Testing on different Levels
#+RESULTS:
[[file:./images/FTestingLevels.png]]

What /will/ differ, however, is the framework within which your tests are running. Obviously, if your tests are run on-the-fly in your IDE, this needs to be supported. Testing as part of the compilation cycle rarely requires much in terms of extra frameworks. For example [[https://www.gnu.org/software/make/][make]], [[https://cmake.org/][cmake]], [[http://ant.apache.org/][Ant]], and [[https://maven.apache.org/][Maven]] are all capable of running your test suites according to your wishes, on your machine.

... But what if your machine environment is not the environment in which your system is intended to run? Well, then you need to set up a virtual machine (or a collection of machines if your deployment environment is more complex) to run the tests on. [[https://www.virtualbox.org/][VirtualBox]] together with [[https://www.vagrantup.com/][Vagrant]] have helped me on more than one occasion with this.

Further down the stack, you want tools that can set up these virtual machines, download your code, build it, and run tests all in one go, e.g. when you do a commit. [[https://jenkins.io/][Jenkins]] is a popular choice for this, if you have access to your own servers. For open source projects, [[https://travis-ci.org/getting_started][Travis CI]] is an ok choice. I think they have some limit to 100 builds or so before you have to start paying, though. Jenkins and Travis work on a slightly different philosophy. In Jenkins you set up the project and the build steps through an admin interface on the Jenkins server. In Travis you create a build script as part of your repository. For raisins, I am partial to the latter, and have recently been exploring [[https://drone.io/][Drone.io]] as a means to set up my own build server that works like Travis with a repository-based build script.

But I digress.

Backing up to the original topic, you will need to find an automated testing tool suitable for your programming language and your development environment. I list some tools below just to get you started.

- Java: [[http://junit.org/][JUnit]]
- Node.js (JavaScript): [[https://mochajs.org/][Mocha]] or [[http://jasmine.github.io/][Jasmine]]
- JavaScript/JQuery (client side): [[https://qunitjs.com/][QUnit]]
- C++, See e.g. the article [[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle][Exploring the C++ Unit Testing Framework Jungle]] for a good discussion of some test frameworks, and what you should require from them
- Emacs Lisp: [[https://www.gnu.org/software/emacs/manual/ert.html][ERT]]
- Or you can go to [[https://en.wikipedia.org/wiki/List_of_unit_testing_frameworks][Wikipedia and see even more choices]]
** TODO Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
        21. [@21] Test-Driven Development and Refactoring	    
*** TODO Screencasts						   :noexport:
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[http://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html][The Cycles of TDD, by R.C. Martin]]
    - [[http://www.jamesshore.com/Blog/Microsoft-Gets-TDD-Completely-Wrong.html][Microsoft Gets TDD Completely Wrong, by James Shore]] (Note: This article is not Microsoft bashing\trade -- they are only one among many to get it wrong)
    - [[https://groups.yahoo.com/neo/groups/extremeprogramming/conversations/topics/111829][Guidelines for Unit Tests, by Michael Feathers]]
    - [[http://gamesfromwithin.com/exploring-the-c-unit-testing-framework-jungle][Exploring the C++ Unit Testing Framework Jungle, by Noel Llopis]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Unit Testing
    - Exploratory Testing
    - Automated Testing
    - Regression Testing
    - Test Driven Development (TDD)
    - Automated Test Frameworks
    - Continuous Integration

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment: Create Test Suite
      Create a regression test suite. You will continue to use and extend this test suite later in the course. At this stage, you are focussing on adding test cases for your API endpoints. Use the system events from your System Sequence Diagrams as API endpoints, and express the tests in your chosen test framework. 

      {{{tasks}}}
      1. List all the system events from all the system sequence diagrams.
      2. For each system event, identify preconditions (e.g. if the system event depends on that another event is triggered first).
      3. For each system event, identify what inputs are allowed.
      4. For each system event, identify what outputs are expected.
      5. For each system event, Write one or several test in your test framework that tests for the allowed inputs and the expected outputs.
	 
      {{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

1. size of assignment: Are there test cases for all system events from all the system sequence diagrams?
2. For each test case: Does it test normal input as well as explore boundary values?
3. For each test case: Does the test case evaluate a meaningful behaviour?
#+END_tip    
*** Update Course Backlog
    How do can you come to an understanding of what the system needs to to as a response to a system event? What will change in the system, and how?
    Are there meaningful tests you can do for your UML documentation? How would you automate this?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You bave created an automated test suite for your API endpoints
   - You have committed/pushed this suite to your project repository

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Set up a continuous integration solution to run your tests on commit   
* DONE Sprint: State Diagram
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* DONE Sprint: Good Interactions
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* TODO Sprint: Interactions and Structure
** About This Sprint
   This sprint discusses how to identify and model interactions between entities in UML interaction diagrams. The sprint also covers how the interaction diagrams produce material that is used to create UML Class Diagrams.
** User Stories covered in this Sprint
   - As a software designer I want to understand how domain concepts interact so that I can select the best way to implement these interactions.
   - As a software designer I want to model both the /dynamic behaviour/ as well as the /static structure/ of the application so that I can communicate both to the developers.
   - As a software implementer I want to know which methods and attributes each class contains so that I can implement them.
** Introduction
   So you have your system events from the UML system sequence diagrams, and you have an idea of the concepts in the problem domain based on your domain model. Your next step is to figure out what should happen inside the system as a consequence of your system events. UML books like to introduce the concept of an /Operation Contract/ at this stage, and spend an impressive amount of time defining all the attributes that you should fill in for each contract. I will not go this far. I will not even require you to write any contracts. As an /analysis tool/, they are quite ok, however.

The takeaway from this sprint is, however, not the actual diagrams. What I want you to realise is that modelling the dynamic behaviour of your system is the /key/ to understanding the static structure. This is the best way to keep your system lean. Yes, you can start with the static structure and model what you /think/ will be needed. You will (a) get much of it wrong and have to go back and fix it later, and (b) add plenty of stuff that will never be used as you thought, so you will add the methods you really need when you develop, and then your design documentation is no longer up to date with what the code does.

#+BEGIN_note
*TL;DR:* Use the /dynamic behaviour/ of your system to extract the least possible amount of /static structure/, to keep your design relevant and lean.
#+END_note

*** Contracts
    An operation contract simply documents the system operations. This is ok, and you should really think of doing something like this anyway. If you use e.g. [[http://www.stack.nl/~dimitri/doxygen/][Doxygen]] or the equivalent for your language, you document your system operations in your code so that callers of a function immediately can get an overview of the operation, its parameters, and its return values.
    
    What I would like to focus on, however, is that in this documentation you also list /preconditions/ and -- even more importantly /postconditions/. The preconditions is simply a list of conditions that must be met before this operation can be called. For example, to return change in a cash machine, there must be an ongoing sale and a payment must have been entered.

    The postconditions list what should have happened /inside/ the system as a result of the operation. This is not a narrative description of "first A happens, then B, and finally C". It is simply a description of the final state. Think of it as a stage-and-curtain model. The system is in one state. A curtain goes down and the operation executes. When the curtain is raised again, you note the changes.

[[./images/ICurtainGoat.jpg]]

   To identify /what/ may have changed, you look at your domain model. Instances of some of the concepts from your domain model are involved in the operation (if not, your domain model is incomplete and should be revised). For these instances, the following may occur:

   - an instance of a concept may be created
   - an instance of a concept may be deleted
   - an attribute of an instance may change value
   - an association betwen two instances may be formed
   - an association betwen two instances may be broken

   It is good form to write this in past tense (to remind you that you are only describing what has already happened):

   - An instance of ~Goat~ with the name ~gHarry~ was created.
   - The (x,y) position of the goat ~gHarry~ was set to (10,4).
   - An instance of ~GoatFood~ with the name ~gf~ was created.
   - ~gf~ was associated with ~gHarry~.
   - The location of ~gf:GoatFood~ was set to the location of ~gHarry:Goat~'s mouth.

   Note that we still don't know /who/ does all of this. We can guess that it is in fact ~gHarry~ that fetches the ~gf:GoatFood~ and puts it in his mouth while going to stand at position (10,4), but we do not know. We also do not know what else may have happened. Where did ~gHarry~ find the food? Was there a clown quartet that rolled a wheelbarrow full of GoatFood on stage and fed it to ~gHarry~ while riding unicycles? Or did we initially create 500 animals on stage and used genetic algorithms to grow and breed on those that most looked like a goat with food in its mouth? We do not know.

   What we /do/ know is that those concepts from the domain model that were used in this contract (and all other contracts) are those that we should model as classes. The attributes that were changed should be added to those classes with the right types. The associations formed or broken should be modelled in our class diagram. We also have an end-state that we can work towards in our interaction diagrams.

#+HTML: <small><small><small><small><small><small><small><small><small>
This here is the specific point from where I am going to get exam answers using Goats in the most horrible ways imaginable. I know this, and yet I wrote this example. What the hell is wrong with me?
#+HTML: </small></small></small></small></small></small></small></small></small>

*** Interaction Diagrams
    UML introduces two types of Interaction diagrams, namely /Sequence Diagrams/ and /Collaboration Diagrams/. These express the same thing and so you can use either one. When I was once a young and budding student we only had collaboration diagrams, and for a long while I favoured them because you are able to express more in less space. These days, however, I prefer sequence diagrams because it is easier to follow the order in which operations should be called, and are overall clearer to get an overview of.

    You have already acquainted yourself with sequence diagrams in the form of /System Sequence Diagrams/. The difference to these is that in a sequence diagram there is no restriction to view the system as a black box, as you do in a system sequence diagram. Indeed, the whole point is to now open up your black box and study what is going on /inside/ the box. Identify which entities needs to be involved to solve the system event, which methods that should be called, and in what order.

#+BEGIN_SRC plantuml :file ./images/FSequenceTheatre.png
hide footbox
[-> ":TheatreStage" : action()
activate ":TheatreStage"
":TheatreStage" -> ":EvolutionManager" : getGoat()

activate ":EvolutionManager"
loop while not true goat

create ":Goat"
":EvolutionManager" --> ":Goat" : create()
":EvolutionManager" -> ":Goat" : whosAGoodGoat()
activate ":Goat"
note right : checking all relevant parameters of "Goatiness"
":Goat" --> ":EvolutionManager" : baaa!
deactivate ":Goat"
end
":EvolutionManager" -> ":TheatreStage" : return lastGoat
deactivate ":EvolutionManager"

":TheatreStage" -> ":Goat" : setPosition(10,2)
activate ":Goat"
deactivate ":Goat"

":TheatreStage" -> ":ActorContainer" : add(a)
activate ":ActorContainer"
deactivate ":ActorContainer"
deactivate ":TheatreStage"
#+END_SRC

#+NAME: fig:SequenceTheatre
#+CAPTION: This example is officially getting silly
#+RESULTS:
[[file:./images/FSequenceTheatre.png]]

    A collaboration diagram is perhaps easier to work with on a whiteboard; you can hold more lively discussions, add an object and an interaction arrow without having to re-draw your entire model. On paper, it is less space-consuming. The cost of this is, as stated, that it is more difficult to follow the order in which methods are being called. Consider the same Goat-on-Stage example again. Note how the iteration is merely represented as an asterix ~*~ after the calls involved, and how the nested calls from within the ~EvolutionManager::getGoat()~ call have sub-numbering (1.1 and 1.2, respectively). Imagine if you have a deeper nesting, say four or five levels down, and then try to keep track of whether "1.2.0.3.2" is executed before "1.2.1.3.1" or not.

#+BEGIN_SRC plantuml :file ./images/FCollaborationTheatre.png
left to right direction
object ":TheatreStage" as ts
object ":EvolutionManager" as em
object "g:Goat" as g
object ":ActorContainer" as ac

title :TheatreStage->action()

ts --> em : 1 g=getGoat()
em --> g : 1.1 create()*
em --> g : 1.2 response=whosAGoodGoat()*
ts --> g : 2. setPosition(10,2)
ts --> ac : 3. add(g)
#+END_SRC

#+NAME: fig:CollaborationTheatre
#+CAPTION: Evolving a Goat and Putting it on Stage.
#+RESULTS:
[[file:./images/FCollaborationTheatre.png]]


    One more thing to note here is that you are dealing with /objects/, i.e. instances of your classes or concepts. You are not modelling the platonic /idea/ of a Goat; you are modelling /one specific instance/ of a goat that is interacting with other specific instances. You are not exercising all methods available in a class; you are calling those specific methods that are needed to solve one particular system event, and you are doing this with the necessary concrete parameters.

#+BEGIN_note
Interaction Diagrams model specific /objects/ and their /specific interactions/.
#+END_note    

*** Class Diagrams
    From the interaction diagrams, that describe the dynamic behaviour of specific objects, we can now start to extract how the class declarations must look like. The methods that are called on an object are placed in the corresponding class of that object. The associations formed are added to the "owner" class of the association (Usually, it is fairly obvious which class should be the owner of an association. Otherwise, decide now and refactor later). Attributes are more difficult to find, since they are not really that prominent in an interaction diagram. If you have made an operation contract, you can get the (post-operation visibly changed) attributes therefrom, but otherwise you will have to guess a bit based on the methods and the responsibilities each object seem to have.

    I am loath to continue with the previous example but, in the interest of completeness, here goes. First, create the classes used in the example, and add the methods called on each class and the attributes I can guess at. Then, add the relations between classes where the objects call each other. I like to do it in a particular order, and I am revealing the source code for the UML Class Diagram below to show you this order. You are of course free to work in any order you prefer.

#+BEGIN_SRC plantuml :file ./images/FClassTheatre1.png :exports both
' Add Classes, methods, and attributes:
' --------------------
TheatreStage : +action()
EvolutionManager : +Goat getGoat()
EvolutionManager : -lastGoat
Goat : +whosAGoodGoat()
ActorContainer : +add(Actor theActor)
ActorContainer : -list<Actor> myActors


' Relations
' --------------------
TheatreStage - "1" EvolutionManager
EvolutionManager - "*" Goat
TheatreStage -- "1" Goat
TheatreStage -- "1" ActorContainer


' I have decided that Goat needs to be a sub-type of Actor
' This simplifies the ActorContainer to not worry about Goatiness,
' but does need to have a relation to "Actor"
' --------------------
Actor <|-- Goat
ActorContainer o-- "*" Actor
#+END_SRC

#+NAME: fig:ClassTheatre
#+CAPTION: Class Diagram for the Theatre Example
#+RESULTS:
[[file:./images/FClassTheatre1.png]]

As you also may notice, I am adding the class ~Actor~ and introducing an inheritance between ~Actor~ and ~Goat~, to keep the interface of the ~ActorContainer~ class clean. I am also adding visibility to the methods and attributes. For now, all methods appear to be public, and all attributes are private.

Also note that even though in the interaction diagram I store the returned ~Goat~ in the variable ~g~, this variable is only needed for the duration of the ~action()~ method and so does not get added to the class. In general, you should try to keep variables in an as limited scope as possible. If you only need them in a block, declare them inside that block. If you only need them in a method, declare them in that method. If you /must/ have them for as long as your object exist, then add them as attributes to the class. If you need them for as long as the system lives you are most likely doing things wrong, but you might consider making them ~static~ or adopt the ~<<Singleton>>~ pattern. If you need them even longer than that, put them in a database or in a file.

*** Moar Classes: Packages
    Preferrably I would like to stop now and put the rest into a separate sprint (and kill the Goat-example once and for all). However, this bit needs to be said, and it will actually help you in your diagrams so I need to put at least a small teaser here.

    Essentially, you now have all the tools necessary to do object oriented design. What we will focus on more in later sprints is how to use pre-existing solution templates and principles to make a /good/ design using the tools you already know after this sprint. There are, however, two major obstacles that we need to address first:
   
    1. You are creating a giant ball of mud, with all your classes thrown into a -- for all intents and purposes -- random order.
    2. You will soon not be able to fit all of your design onto one single paper.

    To expand on Obstacle #1; What is the significance of that ~TheatreStage~ is in the top left corner of Figure [[fig:ClassTheatre]]? What does it mean that ~Actor~ is at the bottom of the diagram? Of course, I have made this figure in [[http://plantuml.com/][plantUML]], which lays out the diagram in an order itself sees fit (since it uses [[http://www.graphviz.org/][GraphViz]] as its backend, the strategy it uses is to minimise the number of arches that needs to cross each other). But even if you are using a CASE tool that allows you to position your classes with absolute coordinates (like a normal drawing program does), there is no inherent semantic meaning in the position of a class.

    Enter the /UML Package Diagram/. In this diagram we take a high-level view of our system and try to define our system as a set of packages, where each package has a well-defined responsibility. We then sort our classes into these packages. This solves Obstacle #2, since we can now move some of the packages to a new page according to some logical principle. If your packages are still too big to fit, you are able to nest packages so that your packages contain more packages.

    To further address Obstacle #1, you also need to define the principles according to which you divide the system into packages. Very crudely, this is what you do in your /Software Architecture/. I say crudely, because there is much more than this to software architectures. For now, let's stick to one of the more common architecture styles, namely the /Layered/ architecture style, since this fits most interactive systems. In the layered architecture style you divide your system into three parts: User Interface, Application Logic, and Storage.

#+BEGIN_SRC plantuml :file ./images/FLayeredPackage.png
package "User Interface" {
MainWindow o- Dialogue1
}

package "Application Logic" {
package "Domain Logic" {
}

package "Technical Services" {
}
}

package "Storage" {
class DBInterface
}

"User Interface" -[hidden]- "Application Logic"
"Application Logic" -[hidden]- "Storage"
#+END_SRC

#+NAME: fig:LayeredPackageDiagram
#+CAPTION: An example of a Layered Architecture, expressed in an UML Package Diagram
#+RESULTS:
[[file:./images/FLayeredPackage.png]]

   The fact that I tack this on at the end of this sprint introduction may lure you into thinking that you /first/ do your class design and /then/ divide into packages. In fact, you have the overall packages in mind already before you start with the class diagram. To be more precise, you have the "Application Logic" layer in mind. The application logic layer is the layer that mostly contain your class representation of the concepts in your domain model. Since your analysis and your interaction diagrams mostly try to express the behaviour of your system in terms of the interaction between your domain concepts, it is hardly surprising that the class diagram thus derived deals mostly with the application logic needed to represent the problem domain.

   Because the focus right now is to determine what from your domain model is relevant for you to solve in your software application, and how to do it, you are not concerned at the moment with the pure software application aspects of the system. This includes the user interface, technical services (for example a key/value store, rule engines etc.), persistent storage facilities, etc.

   "But", an astute reader may think, "does this not just put us back to square one? We still have all our classes in one big package that won't fit on a single page". Yes it does. And no it doesn't, because you can (and you should) nest packages inside your packages. What you should do is thus to think about the high-level packages you have /inside/ your application logic/domain logic package.
   
#+BEGIN_note
*To Summarise:*
- Right now you will be focusing mostly on the Application Logic Layer
- Start by defining the high-level packages /inside/ the application logic layer
- Then study the dynamic behaviour of your system
- Identify the involved entities (classes), and add these to your class diagram to represent the static structure of your system, along with the methods, attributes, and associations you have identified as necessary.
- Allocate the identified classes to you packages.
- ...
- profit!
#+END_note
*** Moar Packages!
    As your system grows, you will get an increasing number of packages, and you will pretty soon need to worry about how you assign responsibilities and classes to different packages. Chapter 35 in {{{larman}}} covers some guidelines for this. Remember that they are /guidelines/ and not set in stone. Glancing through the list there are one or two that I disagree with, and we will discuss this in the appropriate lecture.
** TODO Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      11. [@11] Operation Contracts
      13. [@13] Logical Architecture and UML Package Diagrams
      14. [@14] On to Object Design	  
      15. [@15] UML Interaction Diagrams
      16. UML Class Diagrams
      31. [@31] Domain Model Refinement
      35. [@35] Package Design
*** TODO Screencasts
  - [[https://play.bth.se/media/Contracts/1_086yu2lr/41750261][Contracts]]
  - [ ] Interaction Diagrams
  - [ ] Class Diagrams
  - [ ] Package Diagrams
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[http://dilbert.com/strip/1997-03-09e][Dilbert solves the Software Design Problem]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Interaction Diagrams
      - Sequence Diagrams
      - Collaboration Diagrams (Also: Communication Diagram)
    - Operation Contracts (Also: Design Contracts)
    - Class Diagrams
      - Associations
      - Aggregation
      - Composition
      - Class Roles
      - Multiplicity
    - Dynamic Behaviour
    - Static Structure
    - Package Diagram
    - Software Architecture
    - Architecture Style
      - Layered Architecture Style

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Assignment: Package Diagram
    List and describe the high-level packages in your system.

    {{{tasks}}}
    - Break down your system into logically coherent packages.
    - Briefly describe each package, and its responsibilities.
    - Model your system in a UML Package Diagram.

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Package Diagram)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Overall Packages

   List your packages and briefly describe their responsibilities.
4. Package Diagram

   Represent your packages as a UML Package Diagram.
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Does the package model contain 5 to 10 packages?
2. Do the packages represent a logical division of the system?
3. Is each package described in an understandable way?
4. Are the responsibilities of each package clearly described?
#+END_tip

*** Assignment: Interaction Diagrams
    Describe what will happen inside the system for your system events in terms of UML Interaction Diagrams. You may choose yourself whether you prefer UML Sequence Diagrams or UML Collaboration Diagrams. You may wish to try using both to get a feel of which one you prefer.

    {{{tasks}}}
    - Go back to your list of UML Use Cases and their corresponding UML System Sequence Diagrams, and extract the System Events therefrom.
    - Starting with your most important Use Case, create UML Interaction Diagrams for all the System Events.
    - Continue until you have created /no fewer than 10 UML Interaction Diagrams/ and have completed a full Use Case. I.e., if you are in the middle of a use case with your tenth interaction diagram, you complete the use case and create slightly more than ten interaction diagrams.

#+BEGIN_info
{{{docstructure}}}

{{{assignment(Interaction Diagrams)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Prioritised List of Use Cases

   Repeat your prioritised list of Use Cases.

4. System Events

   List the System Events you have extracted from your UML System Sequence Diagrams:

   1. System Events for Use Case <name 1>
   2. System Events for Use Case <name 2>
   3. ...
   4. System Events for Use Case <name N>

5. Interaction Diagrams

   Your UML Interaction Diagrams, organised per use case and titled with the system event.

   1. Interaction Diagrams for Use Case <name 1>
   2. Interaction Diagrams for Use Case <name 2>
   3. ...
   4. Interaction Diagrams for Use Case <name N>
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Are there at least 10 interaction diagrams?
2. Are all relevant objects (and only objects) involved in the interaction diagrams?
3. Are all methods (messages) suitably named?
4. Are returned objects and objects passed as parameters also represented in the interaction diagram?
5. Will the interaction diagram actually sufficiently address the system event?
6. Are there interactions that are missing to fully satisfy the system event?
#+END_tip
*** Assignment: Class and Package Diagram
    In this assignment you use your UML Interaction Diagrams and extract the static structure necessary in the form of a UML Class Diagram. Furthermore, you divide your classes into the packages that you have previously identified. This assignment builds upon the previously created package diagram.

    {{{tasks}}}
    - For each object in each interaction diagram, create a corresponding class in a UML Class Diagram.
    - Put your classes into the package from your Package Diagram you think is most suitable for each class.
    - Add all methods that are being called on each object in your interaction diagram to the corresponding class.
    - If two objects are interacting in your interaction diagrams, add an association between the corresponding classes.
    - Identify attributes that each object must have, and add these to the corresponding class.
    - Refine the associations in your UML Class Diagram and consider whether they should be simple associations, aggregations, or compositions.
    - Refine the associations in your UML Class Diagram with respect to multiplicity
    - Refine the attributes in each class in your UML Class Diagram and add types and visibility.
    - Refine the methods in each class in your UML Class Diagram and add return types, parameter types, and visibility.

#+BEGIN_info
{{{docStructure}}}

{{{assignment(Class and Package Diagram)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Class and Package Diagram
   
   Present the final UML Class Diagram (divided into Packages).

   Briefly describe each package and its responsibilities.
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Does the UML Class Diagram contain 15-30 Classes?
2. Do all objects from the interaction diagrams in the previous assignment have a corresponding class?
3. Are the classes placed into relevant packages?
4. Do all method calls from the interaction diagrams in the previous assignment have a corresponding method in the right class?
5. Are all interactions in the interaction diagrams accurately represented as associations between classes?
6. Where applicable, are associations between classes modelled as aggregations or compositions?
7. Are there multiplicity indicators on associations? Are they used correctly?
8. Do all methods have a visibility indicator, a return type, types for all parameters, and a relevant name?
9. Do all attributes have a visibility indicator, a type, and a relevant name?
10. Are there any missing attributes?
#+END_tip

*** Assignment Submission    

    {{{submit}}}
    
    Your submission shall include the following documents:
    - Interaction Diagrams
    - Class and Package Diagram
*** Update Course Backlog
    When deciding how to solve a system event in terms of interacting objects, are there better ways for the objects to interact, and are there worse ways? With respect to what?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have an understanding of how the dynamic behaviour of the system is used to identify the static structure
   - You have an understanding of how you may use your previous analysis, in terms of Use Cases, System Sequence Diagrams, and Domain Model to initiate your design of the dynamic behaviour.
   - You have created a Package Diagram document.
   - You have created an Interaction Diagrams document.
   - You have created a Class and Package Diagrams document.
   - You have committed/pushed these documents to your project repository.
   - [[./org/checked.png]] You have submitted the Interaction Diagrams document and Class and Package Diagrams document for marking.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* DONE Sprint: Design Patterns
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* DONE Release Sprint: Object Oriented Design :A2:PA1415:PA1435:PA1435:PA1443:
  CLOSED: [2017-02-08 Wed 14:34]
  :LOGBOOK:  
  - State "DONE"       from "TODO"       [2017-02-08 Wed 14:34]
  :END:      
* TODO Sprint: Introduction to Software Architectures
** About This Sprint
   This sprint reviews how to describe a non-trivial software system in the form of a software architecture.

   For more information on this topic, see e.g. the course ~PA1410 Software Architecture and Quality~.
** User Stories covered in this Sprint
   - As a software designer I want to be able to divide my design into manageable chunks so that I can get a better overview.
   - As a software designer I want to address the quality requirements of the software system early on so that they are not missed.
   - As a software designer I want to address the quality requirements of the software system in the most appropriate way to facilitate the rest of the development project.
** Introduction
   When developing software there are a number of challenges to keep in mind. For example, the project manager want to /reduce the development costs/, your marketing department will want to /reduce time-to market/, considering that your application is going to spend 90% of its lifespan in maintenance, your company will want to /decrease the maintenance costs/, and your product managers want to /increase system quality/. We can summarise these needs in what is known as the [[https://en.wikipedia.org/wiki/Project_management_triangle][Iron Triangle]]. Ignoring Euclidean geometry, this can be [[http://paulhammant.com/2015/12/19/the-iron-triangle-is-actually-a-square-and-not-particularly-iron/][summarised as]]: 

#+BEGIN_SRC ditaa :file ./images/FIronTriangle.png
  The Right
  Functionality                     On Time
            +----------------------+
            | cGRE                 |
            |                      |
            |                      |
            |       Deliver        |
            |                      |
            |                      |
            |                      |
            |                      |
            +----------------------+
  On Budget                         The Right
                                    Quality
#+END_SRC   

#+NAME: fig:IronTriangle
#+CAPTION: The Iron Triangle of Software Development
#+RESULTS:
[[file:./images/FIronTriangle.png]]

In order to balance these requests (and many more) you, as software developers, take decisions (Note how only one of the challenges appear to be about software. I won't say any more about this for now, but I encourage you to think about how you would address the other challenges in your software). Software architecting is about identifying /which/ business and technical decisions are necessary, and /finding solutions/ that satisfy all stakeholders.

The software architecture is a tool for /understanding/ which decisions are necessary, for /planning/ how to instantiate these decisions in your software, and for /communicating/ your decisions to the rest of the development team. You also use them to /predict/ quality, and identify opportunities for /reuse/.

Going back to the iron triangle. Jan Bosch once said "Functionality is easy." Anyone can implement functionality. It's just a matter of hacking away until you have the right functionality. It is the other three corners that require planning, and where a software architecture may help. Let's review each of the corners:

- On Time :: What features are most important to deliver first? How much time do you have? How can you structure the system so that you can develop features in parallel?
- On Budget :: What resources do you have available? How do you structure the software to make best use of the available expertise? What can you buy? What must you build?
- On Quality :: The obvious bit here is how you structure the software so that you can test it properly, but there is more to say here. The software architecture defines a /potential/ to achieve certain quality attributes (for example, one structure may be good for reliability, another for modifiability, and a third for throughput). We may, in fact, define "on time" and "on budget" to also be specific quality requirements, that should be balanced alongside with performance, maintainability, reliability etc. [[https://en.wikipedia.org/wiki/ISO/IEC_9126][ISO9126]] (and it's successor ISO 25010) goes one step further and also includes functionality as one quality attribute among the rest.

*** Architecture as Decisions
The first thing of a software architecture is thus that it consists of /conscious decisions/ on how to address different concerns from different stakeholders. This includes decisions on concerns where you do not have the right competence available in-house, decisions on concerns where you need to deliver parts of the system in a certain order, decisions on concerns about how to achieve different quality requirements, and decisions on how to /balance/ all these different concerns such that you focus on the most important concerns (side note: how do you prioritise your concerns?).

I will even go so far as to say that the decisions /are/ the software architecture. The rest is just instantiations of these decisions. The instantiation is important, since this brings together all of your decisions into one coherent system that you are able to communicate to others, and to evaluate to ensure that you actually satisfy the right balance of quality requirements.

A more traditional definition is provided by the [[http://www.sei.cmu.edu/architecture/][Software Engineering Institute]] (The definition below is from their book /Software Architecture in Practice/ (Bass et al. 2012)):

#+BEGIN_QUOTE
The software architecture of a program or computing system
is the structure or structures of the system, which comprise
software elements, the externally visible properties of those
elements, and the relationships among them.
#+END_QUOTE
*** Architecture Views
    If you've payed attention to the other sprints in this course, it should not come as a surprise to you that the software archtiecture is documented in a number of different ways, depending on what you are focusing on. Consider the maps below. All three represent London, but from different perspectives.

    [[./images/ILondon_AZMap.jpg]]
    [[./images/ILondon_Tube.png]]
    [[./images/ILondon_River.jpg]]

    (There are also [[http://mappinglondon.co.uk/][Other maps of London]] that are equally valid representations of the city. For example, there are sewage maps, electricity maps, gas maps, etc.)

    If you are sightseeing, you might use the river map and take a boat. If you are walking or driving, the A-Z map is probably your best friend. If you just want to get from point A to point B, you use the tube map.

    In the same way, you express your software architecture using different types of "maps" depending on what you intend to do.  Philippe Kruchten expressed this in 1994 as the "4+1 view of architecture":

    [[./images/IKruchten.png]]

    This has influenced many design methodologies, including UML. The current best practice is to define a set of views (possibly from a suggested superset of potential views) that are relevant for your system. I am a bit old-fasioned, so I usually stick with a subset of Hofmeister et al. (2000)'s views:

    - A Conceptual View :: describing the system as a series of collaborating conceptual "logical" components.
    - A Module View :: describing the system as implementable modules corresponding to UML packages.
    - An Execution View :: studying the runtime behaviour of the modules.
    - A Code View :: focusing on the development and build environment.

*** Working with the Views
    In UML, the "Scenarios" that Kruchten describes are your use cases. In Hofmeister et al. (2000), it corresponds to your decisions. In Bass et al. (2012) it is your architectural drivers. You use these scenarios (use cases, decisions, architectural drivers, etc.) to define /what/ you need to model on an architecture level, and then you focus on different engineering concerns of these "whats" in each of the viewpoints. 

#+BEGIN_info
*Engineering Concerns*

- Conceptual View
  - How does the system fulfill the requirements?
  - How are COTS components to be integrated? How do they interact with the rest of the system?	
  - How is domain specific hardware and/or software incorporated into the system?	
  - How is functionality partitioned into product releases?	
  - How does the system incorporate portions of the prior generations of the product and how will it support future generations?	
  - How are product lines supported?	
  - How can the impact of changes in requirements or the domain be minimized?	
- Module View
  - How is the product mapped to the software platform?	
  - What system support/services does it use, and exactly where?	
  - How can testing be supported?	
  - How can dependencies between modules be minimised?	
  - How can reuse of modules and subsystems be maximised?	
  - What techniques can be used to insulate the product from changes in COTS software, in the software platform, or changes to standards?
- Execution View
  - How does the system meet its performance, recovery and reconfiguration requirements?	
  - How can one balance resource usage (for example, load balancing)?	
  - How can one achieve the necessary concurrency, replication and distribution without adding too much complexity to the control algorithms?	
  - How can the impact of changes in the runtime platform be minimised?	
- Code View
  - How can the time and effort for product upgrades be reduced?	
  - How should product versions and releases be managed?	
  - How can build time be reduced?	
  - What tools are needed to support the development environment?	
  - How are integration and testing supported?	
#+END_info

Once you have the scenarios (decisions) for your first iteration ready, you basically work your way through the different views. There is an implicit order between them, because you need a conceptual overview before you can start defining modules, and you need the modules before you can start allocating these to your runtime platform. You also need the modules and the runtime overview before you start planning how to build, test, and integrate your system. However, it is also important to know that the decisions you take in the process of creating one view will impact the views you have already done, so you need to go back and revise in a highly iterative process.

[[./images/IArchDesign.png]]

*** Architecture Evaluation
    You set out in your quest for architecture design with a well defined set of intentions; your (and your stakeholders) primary concerns. You have balanced these intentions against each other and the importance of each stakeholder, you have taken decisions on how to realise a system that satisfies these intentions, and you have instantiated your decisions in a number of different views of your system. 

    As a good engineer, you should not be satisfied here. The software architecture is a relatively cheap artefact to produce, and it has a considerable impact on your quality requirements. Your architecture is also expressed in several different views, and you need to integrate these views into a whole. Lindvall et al. (2003) distinguishes between /Early Architecture Evaluation/ and /Late Architecture Evaluation/:

#+BEGIN_info
*Early Architecture Evaluation*
  - Do we meet the quality requirements on the system?
  - Do all stakeholders share a common understanding of the system?
  - Are all requirements accounted for?
  - Are there any weak spots in ther architecture?
  - Can the system (and/or the architecture) be improved?
  - Does the development team have all the necessary resources?
  - Should we let this project continue?

*Late Architecture Evaluation*
- Hard metrics.
- How did we do? What needs to be improved for the next release?
#+END_info

There is a range of different evaluation methodologies available, from ad-hoc based "looking at the architecture and trying to find challenges based on past experiences and logical reasoning", via more structured versions of this, up to simulation-based and mathematical models. The most commonly used is what is called /scenario-based/, which is a way to structure your experiences and focus your analysis into one scenario at a time.

    Once you have evaluated your architecture, you need to decide whether you satisfy your quality requirements (and your other engineering concerns) or not. If you do, then you are done and can continue building your system. If not, you transform the architecture. This means that you change the architecture in one or several ways in order to improve those qualities that were lacking in your evaluation. Then you re-evaluate to see whether your transformations meet their goal and that they did not negatively effect any other of your qualities.
    
#+NAME: fig:ArchEvalCycle
#+CAPTION: The Architecture Evaluation Cycle
[[./images/IArchEval.png]]    

#+BEGIN_tip
*A Good Software Architecture*
- Is based on conscious decisions
- Is evaluated to ensure that it satisfies the specific goals for the system
- Pays attention to current and future quality attributes
- Is well documented, with traceability to the architecture decisions
- Features well defined modules(components), with well defined interfaces and well defined responsibilities
- Is restricted to a small set of interaction patterns that are consistently used
#+END_tip
*** Architecture Tactics
    Bass et al. introduces one more crucial aid for designing your architecture, namely /Architecture Tactics/. When you have your architectural drivers and need to decide how to actually adress these in your software architecture, architectural tactics suggest solutions on an architectural level for different quality requirements. The tactics are described on a high level, so you need to work with them quite extensively in order to actually fit them into your system.
    
    For example, if /performance/  is a concern for you, Bass et al. suggest that you can focus on managing the resource demand (e.g. by reducing overhead, rate limit the incoming data, or be more efficient in your computations), you may manage the resources smarter (e.g. by introducing concurency), or you may divide the work better (e.g. with a different scheduling policy). Of course, you may decide to use several of these tactics at once. Which tactic to use depends on your system and your data.

    I suggest that you have a look in the Software Architecture in Practice book by Bass et al. and get an overview of the available tactics. These are good engineering principles that help you achieve your quality requirements in a more repeatable way.
*** TODO Summary						   :noexport:
** TODO Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      33. [@33] Architecture Analysis
      34. Logical Architecture Refinement
      38. [@38] UML Deployment and Component Diagrams
      39. Documenting Architecture: UML & the N+1 View Model
*** TODO Screencasts						   :noexport:
*** TODO Lectures						   :noexport:
*** Books and Articles
    - L. Bass, P. Clements, and R. Kazman. /Software Architecture in Practice, Third Edition./ Addison-Wesley Publishing Co., Reading MA, 2012.
    - C. Hofmeister, R. Nord, and D. Soni. /Applied Software Architecture./ Addison-Wesley, Reading MA, 2000.
    - R. Kazman, L. Bass, M. Webb, and G. Abowd. /SAAM: A method for analyzing the properties of software architectures./ In Proceedings of the 16th international conference on Software engineering, pages 81–90. IEEE Computer Society Press, 1994.
    - P.B. Kruchten, "The 4+ 1 view model of architecture." /IEEE software/ 12.6 (1995): 42-50.
    - M. Lindvall, R. T. Tvedt, and P. Costa. An empirically-based process for software architecture evaluation. /Empirical Software Engineering/, 8:83–108, 2003.
    - M. Svahnberg and F. Mårtensson. Six years of evaluating software architectures in student projects. /Journal of Systems & Software/, 80(11):1893–1901, 2007.
*** Further Reading						   :noexport:
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Software Architecture
    - The 4+1 Views of Architecture
    - Architecture Viewpoints
      - Conceptual View
      - Module View
      - Execution View
      - Code View
    - Quality Aspects
      - Quality Attribute
      - Quality Requirement
    - Architecture Evaluation
      - Early Architecture Evaluation
      - Late Architecture Evaluation
      - SAAM/ATAM
    - Architecture Tactics

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** TODO Assignment						   :noexport:
*** Update Course Backlog
    Are there any common architecture styles? What are their qualities?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have 

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* TODO Sprint: Software Architecture Patterns
** About This Sprint
   This sprint covers different patterns that are useful for getting started with a software architecture.
** User Stories covered in this Sprint
   - As a software architect I want to start my design with a well known structure so that I can be sure that I am addressing my quality requirements in the best way.
** Introduction
   I am going to address the user stories in this sprint from two different perspectives. Both of them backs up to how [[https://www.wikipedia.org/wiki/Christopher_Alexander][Christopher Alexander]] described a pattern language for architectures (as used e.g. by Gamma et al. in the Design Pattern book). The first perspective is the common and widely used idea of architectural styles and architectural patterns as a design template. For example, if I describe a system as having a "Layered Architecture", being a "Pipes and Filters system", or a "Model-View-Controller" architecture, this means that the basic structure of the architecture is done according to these patterns. They can be described as ready-made solutions that describe the overall structure of your system, along with the roles and responsibilities of each component. This is the approach taken e.g. by Buschmann et al. (1996)

   The /second/ perspective is the one that Bass et al. (2012) uses, where they describe patterns as specific building blocks that you use for specific purposes, and thus your overall architecture is composed by these smaller building blocks. They refer to these blocks as /Architecture Tactics/. The two perspectives are not mutually exclusive. You are likely to start with an overall architecture pattern to setup a /potential/ for achieving a certain blend of quality requirements. As you continue to design your architecture, you will then encounter specific challenges that you need to design an architectural solution for, where you will apply architectural tactics to address the challenge.

*** Architecture Patterns
   I will not go through all of the architectural patterns or the tactics; there are simply too may of them, it will simply be a boring enumeration, and it does not help you understand them. It /is/, however, good to have an overview of the architectural styles, since these will be your starting point when creating (or approaching an existing) new system. Just as with design patterns, it is good to know their names, roughly how they organise your system, and what problem(s) they address, since this means that you will share a vocabulary with other software developers.

#+BEGIN_tip
Study the Architectural Patterns in Buschmann et al. so you have a broad overview of the problems they address and how they are structured.
#+END_tip

#+NAME: tab:BuschmannPatterns
#+CAPTION: Architectural Patterns in Buschmann et al.
| Pattern                          | Brief Summary                                      |
|----------------------------------+----------------------------------------------------|
|                                  | <50>                                               |
| Layered                          | Decompose system into groups of subtasks that are on different levels of abstraction (such as closer to the user interface or closer to the metal) |
| Pipes and Filters                | Process a data stream in a series of different steps |
| Blackboard                       | Several "workers" collaborating over a shared data set |
| Broker                           | Decouple distributed components                    |
| Model-View-Controller            | Separate data and rules for data consistency from presentation and user input |
| Presentation-Abstraction-Control | Separate viewing and manipulating data into independent but cooperating agents |
| Microkernel                      | Support a minimal core where it is easy to plug in new components |
| Reflection                       | Separate the software into a self-aware "knows how to configure and run jobs" part and a "knows how to do the job" part |
|----------------------------------+----------------------------------------------------|

*** Architecture Tactics
The architecture tactics are organised in a different way. The classic design patterns and architecture patterns are described with a generic problem, an example, a solution, and a discussion of the solution. Tactics start from the notion of /quality attribute scenarios/, which is a way to define the parameters of a quality requirement. Consider the example in Figure [[fig:QAScenario]]. In this scenario a user starts a transaction when the system is running as normal. The user expects the transaction to be processed within two seconds on average.

#+NAME: fig:QAScenario
#+CAPTION: An example of a Quality Attribute Scenario
[[./images/IQAScenarioExample.png]]

The next step is to find a tactic that can control the response such that the response measure is achieved. In the example in Figure [[fig:QAScenario]], how may we ensure that transactions are processed within an average of two seconds? This is a performance issue, so we look in Bass et al. under Chapter 8, "Performance" and find the tactics listed in Table [[tab:PerfTactics]]. We then choose the tactic(s) that best suit our particular problem.

#+NAME: tab:PerfTactics
#+CAPTION: Performance Tactics from Bass et al.
| Overall Strategy        | Specific Tactics                         |
|-------------------------+------------------------------------------|
| Control Resource Demand | Manage Sampling Rate                     |
|                         | Limit Event Response                     |
|                         | Prioritise Events                        |
|                         | Reduce Overhead                          |
|                         | Bound Execution Times                    |
|                         | Increase Resource Efficiency             |
|-------------------------+------------------------------------------|
| Manage Resources        | Increase Resources                       |
|                         | Introduce Concurrency                    |
|                         | Maintain Multiple Copies of Computations |
|                         | Maintain Multiple Copies of Data         |
|                         | Bound Queue Sizes                        |
|                         | Schedule Resources                       |
|-------------------------+------------------------------------------|


Notice that tactics do not tell you exactly which components are needed, or what responsibilities they should have. Instead they merely discuss the solution, and things to consider when using this particular solution. It is then up to you to define which components you will need to implement the tactic, and where in your overall architecture (e.g. which layers) they fit. Not only does this give you a freedom as software designer, it enabled Bass and his colleagues to discuss and categorise architecture solutions for quality requirements that were traditionally "ignored" because they could not be expressed as a set of interacting components.

*** One More Thing...
    One part of architecture patterns which I have not mentioned yet is that just as there are basic design principles for object oriented designs, there are also good practices for architectures. {{{larman}}} summarises a set of these with respect to package design (which is as close to architectures as the Larman book goes). These principles should be applied even when working within a particular architecture pattern or when designing in a particular architecture tactic.
** TODO Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      35. [@35] Package Design
*** TODO Screencasts						   :noexport:
    - Chapter 35 (Package design)
    - Go through a chapter in the AOSA-book and evaluate its use of tactics
    - [[http://resources.sei.cmu.edu/library/asset-view.cfm?assetid=31149][Len Bass on Architectural Tactics]]
*** TODO Lectures						   :noexport:
*** Articles							   :noexport:
*** Further Reading
    - F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stahl. /Pattern-Oriented Software Architecture - A System of Patterns./ John Wiley & Sons, Chichester UK, 1996.
    - L. Bass, P. Clements, and R. Kazman. /Software Architecture in Practice, Third Edition./ Addison-Wesley Publishing Co., Reading MA, 2012.
    - A. Brown, G. Wilson, /The Architecture of Open Source Applications/, available online at: http://www.aosabook.org/en/index.html .
    - [[http://www.ece.ubc.ca/~matei/EECE417/BASS/ch05.html][The chapter on architectural tactics (Chapter 5) from the Second Edition of Bass, Clements, and Kazman]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Architecture Pattern (also the individual architecture patterns mentioned above)
    - Architecture Tactic (also the individual tactics for different quality attributes)
    - Quality Attribute Scenario

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Self-Study: Architecture Challenges and Tactics
    Study the architecture of a couple of open-source systems in the AOSA-book (http://www.aosabook.org/en/index.html). Identify the main challenges they have with respect to:
   
    - Modifiability
    - Performance
    - Testability

    You are free to study any of the systems, but you should be warned that not all of these texts actually describe the architecture of the applications or, if they do, in a way that enables evaluation with respect to quality attributes or tactics. I have previously used the following chapters for similar purposes in software architecture courses:

    - [[http://www.aosabook.org/en/nginx.html][Nginx]]
    - [[http://www.aosabook.org/en/audacity.html][Audacity]]
    - [[http://www.aosabook.org/en/graphite.html][Graphite]]    

    Once you have identified the main challenges for the system, explore the different architecture tactics that might address the challenges (Unless you have access to the third edition of Bass et al., you may use [[http://www.ece.ubc.ca/~matei/EECE417/BASS/ch05.html][The chapter on architectural tactics (Chapter 5) from the Second Edition of Bass, Clements, and Kazman]]). 

    How did they decide to address the challenge? Which architecture tactics best correspond to their solution? Exactly how is this tactic instantiated into a workable system architecture?
    
    The intention of this self-study task is that by going in one direction (from an already solved solution to a generic tactic) you also get experience in seeing how the other direction (going from the tactic to a workable solution) may be done.
*** Assignment: Quality Attribute Scenarios
    List, briefly describe, and prioritise the most important quality attributes that you need to consider in your system. Develop quality attribute scenarios for the most important ones.

    {{{tasks}}}
    - Identify the most important quality attributes for your system.
    - Briefly describe each of them so that it is possible to understand what the quality attribute means in the context of your system and why it is imporant.
    - Prioritise your quality attributes so you know which are the most important for your system.
    - Develop /Quality Attribute Scenarios/ for the top five most important quality attributes.

#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Quality Attribute Scenarios)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Prioritised list of Quality Attributes

   List your quality attributes in order of priority and briefly describe them.
4. Quality Attribute Scenarios

   Your five most important quality attributes, expressed as quality attribute scenarios. This may be expressed as figures, but it is more useful if you present them in a table:

   | Aspect           | Value |
   |------------------+-------|
   | Source           |       |
   | Stimulus         |       |
   | Artifact         |       |
   | Environment      |       |
   | Response         |       |
   | Response Measure |       |

   *Note:* You also need to explain your values with one or two sentences for each aspect.
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Are there more than five quality attributes listed?
2. Size of assignment: Are there five quality attribute scenarios?
3. Do the prioritisation of the quality attributes make sense with respect to the system?
4. For each scenario: Are appropriate sources, stimuli, and artifacts listed?
5. For each scenario: Is the environment reasonable?
6. For each scenario: Is the response appropriate given the stimulus?
7. For each scenario: Is the response measure reasonable given the type of response, the stimulus, and the environment?
#+END_tip
*** Assignment: Architecture Tactics
    Explore architectural solutions (in terms of architecture tactics) for your quality attribute scenarios.

    {{{tasks}}}
    - For each quality attribute scenario, identify which architectural tactics (from Bass et al.) that might help you achieve the desired response measure.
    - Explore how you would design the architecture of your system to make use of the identified tactics.
    - Also consider what support you would need on the design level (in terms of classes and interactions between classes).
#+BEGIN_info
{{{DocStructure}}}

{{{assignment(Architecture Tactics)}}}
#+INCLUDE: "./DocStruct.org" org

3. [@3] Architecture Tactics
   1. Tactics for Quality Attribute Scenario 1: <quality attribute name>

      For each scenario:
      - List and describe the tactics that may be relevant.
      - Briefly discuss how you would use the tactic (or why you decide /not/ to use this particular tactic).
      - Identify key components and classes in your design that are affected by applying your selected tactics.

   2. Tactics for Quality Attribute Scenario 2: <quality attribute name>
   3. Tactics for Quality Attribute Scenario 3: <quality attribute name>
   4. Tactics for Quality Attribute Scenario 4: <quality attribute name>
   5. Tactics for Quality Attribute Scenario 5: <quality attribute name>

4. Updated Architecture

   Present an updated architecture (with as many views that are necessary) that includes the tactics you decided to use. Try to mark, in your architecture, which entities are involved in each tactic, and the responsibilities the entity have in relation to the tactic.
#+END_info

{{{commit}}}

#+BEGIN_tip
{{{condSat}}}

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution?
1. Size of assignment: Are two to three tactics explored for each of the five quality attribute scenarios?
2. Will the discussed tactics address the challenges in each quality attribute scenario?
3. Are the tactics adequately translated into a workable architecture and design for the particular system?
4. Does the updated architecture have a reasonable potential to address the quality attribute scenarios?
#+END_tip

*** Update Course Backlog
    This sprint, and the previous, describes a "top-down" approach to creating an architecture. By this I mean that you start with the problem and then you create an overall architecture, and then (theoretically) you continue by doing detailed design (e.g. with the help of RUP/UML) inside each component or module. How would this fit into a workflow that is primarily based on RUP/UML, which can be described as a more "bottom-up" approach?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have created quality attribute scenarios for your most important quality attributes.
   - You have explored architecture tactics that address your quality attribute scenarios.

   You may also have
   - Explored architecture challenges and tactics for one or more open-source system.
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* WAIT Sprint: From UML to Architecture
* TODO Sprint: Implementation and Designing the User Interface
** About This Sprint
   This sprint describes how a user interface can be designed to fit in with the UML use cases.
** User Stories covered in this Sprint
   - As a user interface designer I want to map the software design to the user interface design so that all necessary inputs and outputs are included.
   - As a software designer I want to separate the user interface code from the domain specific code so that I can easily integrate with auto-generated user interface code.
   - As a software designer I want to separate the user interface code from the domain specific code so that I can easily port the system to other (user interface) platforms.
** Introduction
   This sprint is not about user interface design; this is too important a topic to cover half-assedly at the end of a course on object oriented design. This sprint is about doing a rough sketch of the user interface and connecting this with the user interface, and how to connect this with the rest of your design in a meaningful way.

   In older versions of {{{larman}}}, this was referred to as /Real Use Cases/. It is not always necessary to do these, nor is this the only way of designing the user interface. The reason I include this as a sprint is that it raises a few interesting points that need to be addressed in the design and the future implementation. Given that the most recent version of {{{larman}}} does not include Real Use Cases, it may not be that important after all.

   More interesting, however, is how you connect your user interface to your design in a clean and re-usable manner, as is discussed below.
*** User Interface
    The core idea of real use cases is that you make a sketch of the user interface, with all the inputs and buttons and connect to your use cases. For example, consider the user interface in Figure [[fig:UISketch]]. As a side note, the PlantUML code to generate Figure [[fig:UISketch]] is presented below:

#+BEGIN_SRC plantuml :file ./images/FUISketch.png :exports both
salt
{+
{ Drinks-R-Us }

{+ Choose Beverage
 (X) Coffee
 () Tea
 () Water
} | {+ Choose Size
 () Small
 (X) Medium
 () Large
}

{ [ ] Milk | [ ] Sugar }

[Brew!] | [Tea, Earl Grey, Hot]
}
#+END_SRC

#+NAME: fig:UISketch
#+CAPTION: Draft User Interface
#+RESULTS:
[[file:./images/FUISketch.png]]

I include this code to show you that you do not have to be extremely accurate or use graphical user interface builders to generate a sketch to continue working with. On the other hand, if you /are/ using something like QT Builder, you may just as well do your sketches there and save yourself the effort of translating them thither at a later stage.

The next step is to annotate the sketch so you can refer to the different elements in text (see Figure [[fig:UISketchAnnotate]]). We can now revisit the UML Use Case and describe where the information is entered and how it is sent onwards in the system (for clarity I have expressed this in *bold* text in the use case).

#+NAME: fig:UISketchAnnotate
#+CAPTION: Annotated for Easy Reference
[[./images/IUISketchAnnotated.png]]

#+BEGIN_info
- Use Case :: Order Beverage
- Actors :: Thirsty User
- Description :: A Thirsty User arrives at the Drinks-R-Us machine and orders something to drink. They decide what drink they want, the size of their cup, and whether they want milk or sugar with it.
- Main Course of Events :: 
     | Actor                                                                          | System                                                 |
     |--------------------------------------------------------------------------------+--------------------------------------------------------|
     | 1. A Thirsty User arrives at the DRU machine                                   |                                                        |
     |                                                                                | 2. The system informs about available choices.         |
     | 3. The Thirsty User orders Coffee *in Selector 1*                              |                                                        |
     |                                                                                | 4. The system registers the choice of beverage.        |
     | 5. The Thirsty User selects a large cup *in Selector 2*                        |                                                        |
     |                                                                                | 6. The system registers the cup size.                  |
     | 7. The Thirsty User selects Sugar *by pressing "sugar" in Selector 3*          |                                                        |
     |                                                                                | 8. The system registers that sugar should be added.    |
     | 9. The Thirsty User indicates that they is done *by pressing Button 4 (Brew!)* |                                                        |
     |                                                                                | 10. The system brews a large cup of coffee with sugar. |
#+END_info

*** Connecting User Interface to Design
    From a software design standpoint, it is interesting to look at what happens in the system as a response to events in the user interface. On a high-level, it is easy to draw a conceptual image of this, as in Figure [[fig:UIDesignConnection]].

#+NAME: fig:UIDesignConnection
#+CAPTION: Conceptual overview of how the user interface is connected to the rest of the system.
[[./images/IUIDesignConnection.png]]

But how does this work in practice? What part of the system is responsible for owning and creating instances of the user interface? The normal view is that events are sent from the user interface the domain logic. Typically you want to disconnect this one step further, for example to enable automated creation of the classes that deal with user interfaces (belive me, you do not want to go in and touch boilerplate code). This is where the ~UIConnection~ class comes into play (and I agree that it is a crappy name for it). This is a class that is clean from any of the ugly user interface code (create a /button/, position it /there/, and when /this/ event happens, call /that/ method), and will only get called when an event is generated that involves the actual domain logic. It is the job of this class to make sense of all the options that may be made in the user interface, and text that is entered, and then pass this downwards to the domain logic layer.

A few things are noteworthy here. First of all, there is a desire to keep the ~BrewController~ "clean", with only a small set of functions and a well defined interface (high cohesion). The natural optimisation to do here is thus to only deal with user input once the "Brew" button is clicked. Rather than going back and forth between the logic layer and the user interface for every entry in the user interface -- as the use case actually dictates -- there is a tendency to present a "dumb" user interface that only tells you when you are finished what you have done wrong. This is also the bare minimum user interface that you can replace with other forms of communication (for example, a web API endpoint such as ~http://drinksrus.com/brew?beverage=cofee&size=large&sugar=t~, or a command line interface ~brew --size large --sugar coffee~). Since you still need to do input sanitation, this is still the minimum viable product that you somehow need to start building anyway.

But what if you really need to implement the use case as specified? What if you also have textboxes and want to do some form of type-ahead in those text boxes? Then you need to add methods to the ~BrewController~ for each step in the use case, possibly with a state variable so that you cannot select the size of the cup unless you first have selected a beverage. The type-ahead can be done in two ways. You can either send a call to BrewController after every keypress and get an array of what is likely being typed, or you can send an array to the user interface already from the start with all possible alternatives. The former requires a lower initial bandwidth, whereas the latter has lower requirements on a continuous connection and continuous bandwidth. To the best of my knowledge most web-apps use the former (round-trip to the server for every keypress) these days, especially with the help of websockets.

There are some more forces at play here, and I go through some of them in the accompanying screencast with the help of an example application. Noteworthy are the questions of how you connect the different components with as low coupling as possible, how you tweak the generic design patterns so that you can also piggy-back information on events, and how you sometimes need to work around restrictions in the programming language to make things work.

Taken together all of this can become rather complex to comprehend, as is typically the case when you are trying to integrate different frameworks with each other (consider the user interface as one framework, and your domain functionality as another. You may also have further frameworks that you need to connect with your code). One key obstacle is what is known as the "Hollywood principle", that many frameworks assume. This means that you, once you've configured things at startup, hand over control to the framework who then lends it back to you when an event occurs. Of course, this is more difficult to to if you have two or more frameworks each expecting to be in control of your application.

This may be why most texts on object oriented design are quite happy to teach the principles of good design and responsibility-driven design, but conveniently stops at the level of the ~BrewController~, leaving everything above this level to the poor programmer.
** TODO Learning Material
*** Book Chapters
    - {{{larman}}}, Chapters:
      20. [@20] Mapping Designs to Code
      21. Test-Driven Development and Refactoring
*** TODO Screencasts
    - Go through the MVC Dictionary app
*** TODO Lectures
*** Further Reading						   :noexport:
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - User Interface
    - Observer Pattern
    - Layered Architecture
    - Model-View-Controller Architecture

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Self-Study: Small GUI Application
    Make a small GUI application in your programming language of choice to test how a user interface is constructed and connected to the "designed" bits of an application.

    For example, build a "yow" counter:

#+BEGIN_SRC plantuml :file ./images/FYowCounterUI.png
salt
{+
Number of times you have yowed:
{"   0"}
[Yow]
}
#+END_SRC

#+RESULTS:
[[file:./images/FYowCounterUI.png]]

With the classes:
#+BEGIN_SRC plantuml :file ./images/FYowDesign.png
YowGUI -- YowController
YowController -- YowDataStore
YowController : +yow()
YowDataStore : +addYow()
YowDataStore : +getYows()
#+END_SRC

#+RESULTS:
[[file:./images/FYowDesign.png]]


Now, figure out:
- how you should connect the YowController to the ~Yow~ button without violating any design principles.
- how, by using an ~observer~ pattern, you can get the YowGUI to update the yowcounter.

As an additional exercise, which software architecture patterns have I used here? Are there any that are more suitable? How does this change your implementation?
*** Update Course Backlog
    You do not have a choice; you need to understand the design and your choice of programming platform well enough so that you can implement your system. What challenges can you expect during implementation?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have built a small GUI application as self-study.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog   
* DONE Release Sprint: Implementation and Testing	   :A3:PA1415:PA1435:
  CLOSED: [2017-02-16 Thu 11:41]
* DONE Release Sprint: Architecture and Testing		 :A3:PA1443:noexport:
  CLOSED: [2017-02-17 Fri 10:11]
* WAIT Sprint: Quality Attributes
* TODO Sprint: Preparing for the Exam
* TODO Sprint 99: Finalising the Course
* Working Material						   :noexport:
** TODO Three Week Rollcall assignment
** TODO Work in "The Design Pattern Way" into all sprints.
   For example: The DP way to design interactions
** TODO Review Assignments.
   - Is it necessary to do all of this?
   - Can there be a "Design Pattern" way here too
   - What about a Lean way?
** DONE Don't Forget
   CLOSED: [2017-01-26 Thu 15:44]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-01-26 Thu 15:44]
   :END:
   - [X] Use Cases: connect back to requirements (annotate Main Course of Events with links to Business Requirements).
   - [X] Requirements Engineering: Three parallel and different ways of writing requirments: Old (Reqs), Agile (User stories), UML (Use Cases): Add a picture of this...
   - [X] GRASP: Responsibility-driven design
   - [X] Release Sprints

   | PA1415            | PA1435              | PA1443          | PAxxxx          |
   |-------------------+---------------------+-----------------+-----------------|
   | Exam, 3hp         | Exam, 2hp           | Exam 1hp        | Exam 1hp        |
   | Assignment, 4.5hp |                     | Assignments 4hp | Assignments 3hp |
   |                   | Assignment 1, 1.5hp |                 |                 |
   |                   | Assignment 2, 0.5hp |                 |                 |
   |                   | Assignment 3, 2hp   |                 |                 |
   |                   |                     |                 |                 |
   | SUM: 7.5hp        | SUM: 6hp            | SUM: 5hp        | SUM: 4hp        |
   |-------------------+---------------------+-----------------+-----------------|

   Assignment Submissions:
   - Use Cases and Use Case Diagrams
   - Interaction Diagrams and Classes ??
   - Improved Classes and Interactions
   - Design Patterns
   - Implementation/Testing

   Assignments!
   - How many
   - Flow
   - Topic
** DONE Move Submissions from Interactions and Structure into Good Interactions ?? 
   CLOSED: [2017-01-17 Tue 14:15]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-01-17 Tue 14:15]
   :END:
** DONE Find a cleaner way to include Title Page and System Description in assignments.
   CLOSED: [2016-09-30 Fri 09:03]
   The MACRO for assignment title DO NOT WORK; on export it only has the latest set value, which does not work if you have more than one assignment in an export unit (a sprint.)
** DONE Fix Links in Test Sprint
   CLOSED: [2016-09-28 Wed 10:07]
   - Emil - link to his work
   - JUnit
   - Testing Tools
     - unit testing (Grunt, Junit, CPPTest, etc.)
     - Continuous Integration Tools (Jenkins, Drone.io, Travis.io, ...)
** DONE Map for different Courses   
   CLOSED: [2017-02-17 Fri 13:30]
** DONE System Descriptions for Assignments
   CLOSED: [2017-02-17 Fri 13:30]
** DONE Add "Select System for Assignments" in Sprint 0
   CLOSED: [2017-02-17 Fri 13:30]
** TODO Tie in Lectures into Sprints, with preparations I want them to do first
** DONE State Diagrams
   CLOSED: [2016-09-28 Wed 10:07]
** DONE Revisit all sprints with submissions and make sure the sprint test plan is up to date
   CLOSED: [2017-02-17 Fri 13:30]
** TODO Re-do video "Concepts and Classes": Move Objects into a different sheet
** TODO Video: Interaction Diagrams
** TODO Video: Class Diagrams
** TODO Videos: Software Architectures
   - SA Intro
   - Tactics
   - Views
   - Notation
** TODO Assignments in Architecture sprints
** DONE Chapters Used
   CLOSED: [2017-01-26 Thu 15:45]
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2017-01-26 Thu 15:45]
   :END:
   | Chapter | Sprint |                                   |
   |---------+--------+-----------------------------------|
   |       1 |      1 |                                   |
   |       2 |      1 |                                   |
   |       3 |      1 |                                   |
   |       4 |    2,3 |                                   |
   |       5 |    2,3 |                                   |
   |       6 |    2,3 |                                   |
   |       7 |    2,3 |                                   |
   |       8 |      4 |                                   |
   |       9 |      4 |                                   |
   |      10 |      4 |                                   |
   |      11 |      8 |                                   |
   |      12 |        | () Req to Design                  |
   |      13 |      8 |                                   |
   |      14 |      8 |                                   |
   |      15 |      8 |                                   |
   |      16 |      8 |                                   |
   |      17 |      7 |                                   |
   |      18 |      7 |                                   |
   |      19 |      7 | Visibility                        |
   |      20 |     12 | Design to Code                    |
   |      21 |  1,3,5 |                                   |
   |      22 |        | () Tools                          |
   |      23 |        | () Iteration II                   |
   |      24 |        | () Analysis Update                |
   |      25 |      7 |                                   |
   |      26 |      9 | GoF DP                            |
   |      27 |        | () Iteration III                  |
   |      28 |        | () Activity Digrams               |
   |      29 |      6 |                                   |
   |      30 |      3 |                                   |
   |      31 |      8 | Domain Model Refinement           |
   |      32 |        | () More SSD and Contracts         |
   |      33 |     10 | Arch. Analysis                    |
   |      34 |     10 | Log. Arch. Refinement             |
   |      35 |   8,11 | Package Design                    |
   |      36 |      9 | More GoF DP                       |
   |      37 |        | ()? DP Example                    |
   |      38 |     10 | Deployment and Component Diagrams |
   |      39 |     10 | Architecture Documenting 4+1      |
   |      40 |      1 |                                   |
** Icons
https://pixabay.com/en/users/3dman_eu-1553824/
** Backlog
 | Sprint                    | Topic     | Contents                                  | User Story                                                                                                                                                                                     |   |
 |---------------------------+-----------+-------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---|
 | Intro                     | Intro     | Student                                   | As a student I want to pass this course.                                                                                                                                                       |   |
 |                           | Intro     | Student                                   | As a student I want to understand how this course is structured so that I can quickly find the information I need to learn the subject.                                                        |   |
 |                           | Intro     | Student                                   | As a student I want to know why this topic is important so that I can be properly motivated.                                                                                                   |   |
 | Development Methodologies | DevMeth   | UML                                       | As a software designer I want to document my design in a standardised format so that I can communicate it to other software engineers.                                                         |   |
 |                           | DevMeth   | Development Methodologies, GANTT          | As a project manager I want to plan the project so that I can make the best use of my resources.                                                                                               |   |
 |                           | DevMeth   | WBS                                       | As a project manager I want to track the project so that I can see what the current status is.                                                                                                 |   |
 |                           | DevMeth   | Project Estimations                       | As a project manager I want to track the project so that I can forecast whether we will deliver on time or not.                                                                                |   |
 | Requirements Engineering  | RE        | Requirements                              | As a software engineer I want to get an overview of all sources of requirments that may influence which system I build.                                                                        |   |
 |                           | RE        | Requirements                              | - As a requirements engineer I want to know who may have requirements on the system we are building so that I can make sure that all needs are met.                                            |   |
 |                           | RE        | Requirements                              | As a software engineer I want to be able to extract all requirements on the system I build so that I know that I am not missing anything important.                                            |   |
 |                           | RE        | Requirements                              | - As a requirements engineer I want to have a range of methods for finding requirements so that I can choose the best method for each customer.                                                |   |
 |                           | RE        | Backlog, Iterations, Prioritization       | As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.                                                                  |   |
 | Object Oriented Analysis  | OOA       | Use Cases                                 | As a software designer I want to document what the customer is telling me so that I can discuss my understanding of their requirements with them.                                              |   |
 |                           | OOA       | Use Cases                                 | As a software designer I want to document what the customer is telling me so that I can easily continue designing based on a joint understanding.                                              |   |
 |                           | OOA       | Conceptual Model                          | As a software designer I want to document my understanding of the problem domain so that I can easily transform this into an object oriented software system.                                  |   |
 |                           | OOA       | System Sequence Diagram                   | As a software designer I want to understand how users plan on interacting with the system so that I can design the right API endpoints.                                                        |   |
 |                           | OOA       | State Diagrams                            | As a software designer I want to document the states the application can be in so that I can better design them and get an overview of permissible transitions.                                |   |
 |                           | OOA       | Use Cases - Structuring                   | As a software designer I want to be able to reuse common proceduresbetween my use cases so that I only have to maintain them in one place.                                                     |   |
 | Object Oriented Design    | OOD       | Sequence/Collaboration Diagrams           | As a software designer I want to understand how domain concepts interact so that I can select the best way to implement these interactions.                                                    |   |
 |                           | OOA       | Dynamic vs Static                         | As a software designer I want to model both the /dynamic behaviour/ as well as the /static structure/ of the application so that I can communicate both to the developers.                     |   |
 |                           | OOD       | Class Diagrams (also Transition into)     | As a software implementer I want to know which methods and attributes each class contains so that I can implement them.                                                                        |   |
 |                           | OOD       | Package Diagrams / Architecture           | As a software designer I want to be able to divide my design into manageable chunks so that I can get a better overview.                                                                       |   |
 |                           | OOD       | GRASP Patterns                            | As a software designer I want to create a design that adheres to basic design principles so that I am sure that it will "hold" when I add more functionality and start maintaining the system. |   |
 | Design Patterns           | OOD/DP    | Design Patterns                           | As a software desginer I want to be able to use appropriate design patterns where applicable so that I do not have to reinvent the wheel for every problem.                                    |   |
 | Testing                   | Testing   | Testing, Testing Methodologies, Test Plan | As a product manager I want to make sure that we are building software of high quality.                                                                                                        |   |
 |                           | Testing   | Regression Testing, TDD                   | As a product manager I want to make sure that fixed bugs do not re-appear so that I can build the product incrementally.                                                                       |   |
 | Implementation            | Impl      | From Design to Code                       | As a software designer I want to understand how my design will be implemented so that I can facilitate the transition into code.                                                               |   |
 | Extra: Security           | OOD/DP/SE | Security Design Patterns                  | As a security engineer I want to use "secure" design patterns so that I can make sure that the product is secure by design.                                                                    |   |
 | Extra: Games              | OOD/DP/GE | Games Design Patterns                     | As a games developer I want to use commonly accepted game design solutions so that I can be reasonably sure it works within my quality constraints.                                            |   |
 | Extra: Web                | OOD/DP/WE | Web Engineering Patterns                  | As a web developer I want to be able to use design patterns especially suitable for web engineering so that I make the best use of my platform                                                 |   |
 | Extra: More Analysis Help | OOA       | Contracts                                 | As a software designer I want to have a way of thinking about what happens in a system event so that I do not miss any important effects on the system state.                                  |   |
** Goals and Assignments
| Kurskod | Namn                                               | Omfattning | Program                                                    |
|---------+----------------------------------------------------+------------+------------------------------------------------------------|
| PA1415  | Programvarudesign                                  |        7.5 | BSc i Spelprogrammering, BSc i IT-Säkerhet                 |
| PA1434  | Grunder i Objektorienterad Design                  |          4 | CI i IndEk                                                 |
| PA1435  | Objektorienterad Design                            |          6 | CI i Spel- och Programvaruteknik, CI i Industriell Ekonomi |
| PA1443  | Introduktion till Programvarudesign och Arkitektur |          5 | BSc i Programvaruteknik                                    |
|---------+----------------------------------------------------+------------+------------------------------------------------------------|

  | Ass | Kurskod                        | Kursmål                                                                                                                            |
  |-----+--------------------------------+------------------------------------------------------------------------------------------------------------------------------------|
  |   1 | PA1415                         | - på en grundläggande nivå i grupp kunna ta fram krav på en programvara och uttrycka dem i en kravspecifikation                    |
  |   1 | PA1415                         | - i grupp producera en översiktlig utvecklingsprojektplan baserat på en kravspecifikation                                          |
  |   2 | PA1415 (PA1435/PA1434)         | - i grupp kunna skapa en detaljerad objektorienterad design för ett mjukvaruprogram                                                |
  |   3 | PA1415                         | - i grupp kunna implementera ett mjukvaruprogram inom rimlig tid, baserat på en kravspecifikation och en objektorienterad design   |
  |   3 | PA1415 (PA1443)                | - på en grundläggande nivå i grupp kunna planera och genomföra testning av producerad programvara, baserat på en kravspecifikation |
  |   2 | PA1415 (PA1435/PA1434)         | - skapa och analysera objektorienterade artefakter uttryckta i UML                                                                 |
  |   2 | PA1415 (PA1435/PA1434/ PA1443) | - kunna motivera och använda designmönster i utvecklingen av mjukvarusystem                                                        |
  |     |                                |                                                                                                                                    |
  |     |                                | *Kunskap och förståelse*                                                                                                           |
  |   1 | PA1435/PA1434/ PA1443          | - kunna visa förståelse för grundläggande principer i objektorienterad programvaruutveckling.                                      |
  |   1 | PA1435/PA1434                  | - kunna visa förståelse för UML som modelleringsspråk.                                                                             |
  |   1 | PA1435/PA1434/ PA1443          | - kunna visa kunskap om grundläggande designprinciper.                                                                             |
  |   2 | PA1435/PA1434/ PA1443          | - kunna visa kunskap om grundläggande designmönster.                                                                               |
  |   4 | PA1443                         | - kunna visa kunskap om grundläggande mjukvaruarkitekturstilar                                                                     |
  |     |                                |                                                                                                                                    |
  |     |                                | *Färdigheter och förmåga*                                                                                                          |
  |   2 | PA1435/PA1434/ PA1443          | - kunna uttrycka strukturen och beteendet hos ett system i termer av objektorienterade koncept.                                    |
  |   2 | PA1435/PA1434                  | - kunna korrekt använda UML för att uttrycka struktur och beteende hos ett system.                                                 |
  |   3 | PA1435/PA1434                  | - kunna korrekt transformera en objektorienterad design till källkod.                                                              |
  |   2 | PA1435/PA1434                  | - kunna tillämpa designprinciper och designmönster i allmänhet och inom en särskild domän.                                         |
  |   2 | PA1443                         | - kunna tillämpa grundläggande designmönster i en objektorienterad design.                                                         |
  |   2 | PA1443                         | - kunna skapa en objektorienterad design för ett system enligt goda objektorienterade designprinciper                              |
  |   4 | PA1443                         | - kunna tillämpa grundläggande arkitekturstilar för ett mjukvarusystem                                                             |
  |   4 | PA1443                         | - kunna resonera om de kvalitetsegenskaper ett system med en viss arkitekturstil har eller bör ha                                  |
  |   4 | PA1443                         | - kunna resonera om och skapa en grundläggande testplan för ett objektorienterat system                                            |
  |     |                                |                                                                                                                                    |
  |     |                                | *Värderingsförmåga och förhållningssätt*                                                                                           |
  |   3 | PA1435/ PA1434                 | - kunna analysera källkod för eventuella förbättringar.                                                                            |
  |  34 | PA1435/PA1434/ PA1443          | - kunna analysera och kritiskt diskutera en design för eventuella förbättringar.                                                   |
  |-----+--------------------------------+------------------------------------------------------------------------------------------------------------------------------------|

  Old version
 :NOTES:
  | Course Code          | Course Goal                                                                                                                        |
  |----------------------+------------------------------------------------------------------------------------------------------------------------------------|
  | PA1415               | - på en grundläggande nivå i grupp kunna ta fram krav på en programvara och uttrycka dem i en kravspecifikation                    |
  | PA1415               | - i grupp producera en översiktlig utvecklingsprojektplan baserat på en kravspecifikation                                          |
  | PA1415/PA1435/PA1434 | - i grupp kunna skapa en detaljerad objektorienterad design för ett mjukvaruprogram                                                |
  | PA1415               | - i grupp kunna implementera ett mjukvaruprogram inom rimlig tid, baserat på en kravspecifikation och en objektorienterad design   |
  | PA1415               | - på en grundläggande nivå i grupp kunna planera och genomföra testning av producerad programvara, baserat på en kravspecifikation |
  | PA1415/PA1435/PA1434 | - skapa och analysera objektorienterade artefakter uttryckta i UML                                                                 |
  | PA1415/PA1435/PA1434 | - kunna motivera och använda designmönster i utvecklingen av mjukvarusystem                                                        |
  |                      |                                                                                                                                    |
  | PA1435/PA1434        | *Kunskap och förståelse* Efter genomförd kurs ska studenten:                                                                       |
  | PA1435/PA1434        | - kunna visa förståelse för grundläggande principer i objektorienterad programvaruutveckling.                                      |
  | PA1435/PA1434        | - kunna visa förståelse för UML som modelleringsspråk.                                                                             |
  | PA1435/PA1434        | - kunna visa kunskap om grundläggande designprinciper.                                                                             |
  | PA1435/PA1434        | - kunna visa kunskap om grundläggande designmönster.                                                                               |
  |                      |                                                                                                                                    |
  | PA1435/PA1434        | *Färdigheter och förmåga* Efter genomförd kurs ska studenten:                                                                      |
  | PA1435/PA1434        | - kunna uttrycka strukturen och beteendet hos ett system i termer av objektorienterade koncept.                                    |
  | PA1435/PA1434        | - kunna korrekt använda UML för att uttrycka struktur och beteende hos ett system.                                                 |
  | PA1435/PA1434        | - kunna korrekt transformera en objektorienterad design till källkod.                                                              |
  | PA1435/PA1434        | - kunna tillämpa designprinciper och designmönster i allmänhet och inom en särskild domän.                                         |
  |                      |                                                                                                                                    |
  | PA1435/PA1434        | *Värderingsförmåga och förhållningssätt* Efter genomförd kurs ska studenten:                                                       |
  | PA1435/PA1434        | - kunna analysera källkod för eventuella förbättringar.                                                                            |
  | PA1435/PA1434        | - kunna analysera och kritiskt diskutera en design för eventuella förbättringar.                                                   |
  |----------------------+------------------------------------------------------------------------------------------------------------------------------------|
  :END:
** Topics
  | PA1415 | PA1435 | Topic                                            |
  |--------+--------+--------------------------------------------------|
  | PA1415 |        | Development Methodologies (Waterfall/Agile/Lean) |
  | PA1415 |        | Requirements Engineering                         |
  | PA1415 |        | Project Planning                                 |
  | PA1415 |        | Work Breakdown Structures                        |
  | PA1415 |        | Project Estimations                              |
  | PA1415 |        | Testing, Different Levels                        |
  | PA1415 |        | Test Driven Development                          |
  | PA1415 |        | Test Plan                                        |
  |        | PA1435 | Basic Design Methodology (OOA, OOD)              |
  | PA1415 | PA1435 | UML - overview                                   |
  | PA1415 | PA1435 | UML Analysis                                     |
  | PA1415 | PA1435 | UML Design                                       |
  | PA1415 | PA1435 | Basic Design Patterns (GRASP)                    |
  | PA1415 | PA1435 | Design Patterns (GoF)                            |
  | PA1415 | PA1435 | From Design to Code                              |
  | PA1415 | PA1435 | Good vs Bad Design                               |
  |--------+--------+--------------------------------------------------|

** Sprints						       :OLD:noexport:
   0. [@0] Introduction/Formalia
   1. Overview of Development Methodologies
      - Waterfall
      - Agile/Lean
      - RUP
   2. Requirements Engineering
      - Requirement Elicitation
      - Requirements, User Stories, Use Cases
      - Backlog
      - Working with requirements in a Sprint
      - Requirements and Testing
   3. Planning and Estimations
      - Requirements and Prioritisations
      - Requirements for Planning
      - WBS
      - Estimations
      - Project Tracking
   4. Testing
      - Levels of Testing
      - TDD
      - Test plan
   5. Introduction to RUP/UML
      - OOA
      - OOD
      - RUP
      - UML Diagrams
      - UML Dictionary
   6. OO Analysis
      - Use Case Diagrams
      - Use Cases
      - System Sequence Diagrams
      - Conceptual Model
      - State Diagrams
      - Worked Example from Use Case to SSD and Conceptual Model
   7. OO Design
      - Interaction Diagrams
	- Sequence Diagrams
	- Collaboration Diagrams
      - Class Diagrams
   8. Basic Design Patterns
      - GRASP
   9. Common Design Patterns
   10. From Design to Code
       - Java / C++ Quirks
       - OOP in JavaScript
** Lecture Outline					       :OLD:noexport:
*** DONE Introduction (01)
    CLOSED: [2016-03-09 Wed 11:44]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-09 Wed 11:44]
    :END:      
    Classroom only

    - Course Intro
      - About MSV
      - Course Structure
      - Lecture Structure
      - Literature
      - Tools
    - Modelling why care
      - Gorschek paper
      - Sell it anyway
    - Overall OOD Development Methodology
      - Reason: Traceability
      - Reason for all the models: Analysis triangulation
    - Modelling at large
    - OO Analysis
    - OO Design
    - UML
      - Sell UML (Abstract, Precise, Pictoral)
      - UML as a collection of models
      - UML as a methodology
      - UML wankery
    - Design / Design Patterns
    - Exercise in Scale??
*** DONE Development Process (02)
    CLOSED: [2016-03-09 Wed 14:35]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-09 Wed 14:35]
    :END:      
    Upload: Methodologies
    - Waterfall
    - Iterative/Incremental
    - Kanban
    - SCRUM

    Classroom:
    - Process
      - Systematic
      - Disciplined
      - Quantifiable (!)
    - Process vs Project vs Product
    - Discuss:
      - What's good with waterfall?
      - Where would you do design in Scrum?
      - Where would you do design in Kanban?
    - Example: UML Process (Work through an example)
      - Use Case Diagrams
      - Use Cases
      - Conceptual Model
      - Class Diagram
      - Collaboration Diagram
      - Interaction Diagram
      - ?? Flowcharts 
*** DONE Requirements (03)
    CLOSED: [2016-03-17 Thu 09:59]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-17 Thu 09:59]
    :END:      
    Upload: Requirements Specifications
    - ISO 830
    - RFC 2119
    - Standard Templates for Requirements "The system must do X"
    - Standard Template for User Stories
    - Use Cases
      - Use Case Diagrams
      - High Level Use Case
      - Fully Dressed (Expanded) Use Case
    - Prioritising Requirements

    Classroom:	
    - Discuss:
      - How to Find Requirements
      - Goals, Features, Functions, Components (RAM Model)
      - Good and Bad Requirements
      - Black box vs White Box
    - Basic RE process
      - (Re-use old slides)
    - Example
      - Use Case Diagram
      - High Level Use Case
      - Fully Dressed Use Case
*** DONE Modelling Structure (04)
    CLOSED: [2016-03-22 Tue 11:15]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-22 Tue 11:15]
    :END:      
    Upload:
    - Conceptual Model Notation
      - Concept
      - Attributes
      - Associations
      - Multiplicity
      - Data Dictionary (Definition/Intention/_Glossary_)
      - Examples (Instantiated Objects)
    - Class Diagrams
      - Concept vs Class
      - Associations
      - Roles
      - Role Multiplicity
      - Attributes
      - Attribtue Types

    Classroom:
    - Discuss:
      - How to find Concepts/Attributes/Associations?
      - Difference between Attribute and Concept?
      - Multiplicity -- how to think?
    - Slides on Concept Identification
    - How to find Attributes
    - How to find Associations
    - Example:
      - Conceptual Model
      - Class Diagram
*** DONE Modelling Structure II (04)
    CLOSED: [2016-04-13 Wed 11:00]
    :LOGBOOK:  
    - State "DONE"       from "WAIT"       [2016-04-13 Wed 11:00]
    - State "WAIT"       from ""           [2016-04-13 Wed 11:00]
    - State "WAIT"       from ""           [2016-03-22 Tue 14:34]
    :END:      
    - [X] Structuring Use Cases (From Modelling Behaviour Lecture)
*** DONE Modelling Behaviour (05)
    CLOSED: [2016-04-06 Wed 14:28]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-04-06 Wed 14:28]
    :END:      
    Upload:
    - Sequence Diagram
      - Actor
      - Lifeline
      - Event
    - Contract
      - Name
      - Responsibilities
      - Preconditions
      - Postconditions
    - Extended Contract
      - Name
      - Responsibilities
      - Type
      - Cross-References
      - Notes
      - Exceptions
      - Output
      - Preconditions
      - Postconditions
    - State Diagrams
      - State / Event / Transition
      - Notation
	- Nested States
	- Activity in a State
	- Actions on Transitions

    Classroom:
    - Going from Use Case to Sequence Diagram
    - System Sequence Diagram vs regular Sequence Diagram
    - System as a modelling concept
    - Contracts
      - What are they?
      - How should you interpret preconditions?
      - How to interpret postconditions?
      - Stage-and-Curtain execution
    - Discuss:
      - What are extended contracts good for?
    - State Diagrams
      - Examples + Discussion: Common Pitfalls
      - What types of Events can there be in a state diagram?
    - Discuss:
      - How do we fit state diagrams into the UML process?
*** TODO Design -- Collaboration and Responsibilities
    Upload:      
    - [ ] Interaction Diagrams, Collaboration Diagrams
      - Classes and Instances
      - Sequence Numbering
      - ...
    - [ ] Conditions, etc.
    - [ ] Real Use Cases

    Classroom:
    - [-] Discuss
      - What is the difference between Sequence diagrams and Collaboration Diagrams
    - [-] Example:
      - Go from Class Diagram to Sequence Diagram
*** DONE Design Patterns I/II (06) (08, 09)
    CLOSED: [2016-04-21 Thu 14:25]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2016-04-21 Thu 14:25]
    :END:
    Upload:
    - GRASP Patterns
      - Expert
      - Creator
      - Low Coupling
      - High Cohesion
	- Don't talk to strangers
      - Controller
      - Polymorphism
    - Design Patterns
      - Observer
      - Singleton
      - Strategy
      - State
      - Abstract Factory
    - Architecture
      - Layered
      - MVC

    Classroom:
    - Design Patterns Background
    - Levels of Patterns
      - Architecture
      - Design
      - Idioms
      - GRASP
    - Discuss:
      - Design Patterns:
	- Domain Modelling or Development tricks
	- What are they good for?
	- Limitations?
    - Example:
      - How to apply GRASP
      - How to apply DP
      - How to apply AP
    - Example:
      - How to Implement DP's
*** TODO Mapping Design to Code (07)
    Classroom:
    - Implementation Order
    - Class Creation
      - (Why bother, it's done by the tool anyway)
      - Attributes, Methods, etc.
    - Code from Sequence Diagrams
      - This is not automatic, because crappy tools.
    - Language Differences
      - Multiple Inheritance vs Inner Classes vs Anonymous Classes
      - Pointers vs References
      - Aggregation vs Strong Aggregation
      - Callback Programming (Event-Driven Arch.) (Node.js and its ilks)
	- https://blog.risingstack.com/fundamental-node-js-design-patterns/
      - Stateful EDA's??
      - Dependency Injection (Might hold a discussion on this one)
      - NULL as return values
      - Defensive Programming
	- http://c.learncodethehardway.org/book/ex27.html
	- Discuss: Good or Bad? Better to Fail Early?
** Links							   :noexport:
   IEEE 829-2008: http://www.fit.vutbr.cz/study/courses/ITS/public/ieee829.html
** Lost Puppies							   :noexport:
#+BEGIN_SRC dot :file ./images/FSprintMap.svg
digraph {
rankdir=TB;
splines=true;
node [style=filled,fillcolor="/greens3/2"];

s0 [label="Sprint 0: Course Introduction"]
devmet [label="Development Methodologies"]
re [label="Requirements Engineering"]
ucd [label="Use Cases and Use Case Diagrams"]
ce [label="Concepts and Events"]
tst [label="Testing"]
sd [label="State Diagram"]
goodint [label="Good Interactions"]
interact [label="Interactions and Structure"]
dp [label="Design Patterns"]
ui [label="Designing the User Interface"]
sa [label="Introduction to Software Architectures"]
sap [label="Software Architecture Patterns"]
impl [label="Implementation"]
exam [label="Preparing for Exam"]
s99 [label="Sprint 99: Course Wrapup"]


subgraph cluster_intro {
label="Course Introduction";
s0
}

subgraph cluster_development {
label="Software Development";
devmet -> re
}

subgraph cluster_ooa {
label="Object Oriented Analysis";
ucd -> ce -> sd
}

subgraph cluster_qa {
label="Quality Assurance";
tst
}

subgraph cluster_ood {
label="Object Oriented Design";
goodint -> interact -> dp
}


subgraph cluster_sa {
label="Software Architecture";
sa -> sap
}

subgraph cluster_impl {
label="From Design to Code";
ui -> impl
}

subgraph cluster_wrapup {
label="Course Wrap-up"
exam -> s99
}

subgraph PA1415 {
node [style=filled,fillcolor="/greens3/2"];
edge [label="PA1415", color="green", fontcolor="green"]
s0 -> devmet
re -> ucd
sd -> tst
tst-> goodint
dp -> sa
sap -> ui
impl -> exam
}

  
subgraph PA1435 {
node [style=filled,fillcolor="/blues3/2"];
edge [label="PA1435", color="blue", fontcolor="blue"]
s0 -> ucd 
sd -> tst -> goodint
dp -> sa
sap -> ui
impl -> exam
}
 
subgraph PA1443 {
node [style=filled,fillcolor="/bupu3/2"];
edge [label="PA1443", color="blueviolet", fontcolor="blueviolet"]
s0 -> ucd
ce -> goodint
dp -> impl
impl -> exam
}

}
#+END_SRC
