#+Title: Software Design Courses
#+Subtitle: PA1415, PA1435
#+Author: Mikael Svahnberg
#+Email: Mikael.Svahnberg@bth.se
#+Date: 2016-08-18
#+EPRESENT_FRAME_LEVEL: 1
#+OPTIONS: email:t <:t todo:t f:t ':t toc:nil
# #+STARTUP: showall
#+STARTUP: beamer

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org/org.css" />
# #+INFOJS_OPT: view:overview toc:nil ltoc:nil mouse:underline buttons:nil path:org/org-info.js up:http:www.zombo.com
#+HTML: <br/>

# #+LATEX_HEADER: \usepackage[a4paper]{geometry}
#+LATEX_CLASS_OPTIONS: [10pt,t,a4paper]
# #+LATEX_CLASS: beamer
#+BEAMER_THEME: BTH_msv

#+MACRO: pa1415 PA1415 Software Design
#+MACRO: pa1435 PA1435 Object Oriented Design
#+MACRO: larman C. Larman, "Applying UML and Patterns", 3d Edition
#+MACRO: commit Commit and push this document to your project repository.
#+MACRO: submit Submit the assignment as one or several PDFs on It's Learning.

* Sprint Structure						   :noexport:
** About This Sprint
** User Stories covered in this Sprint
** Introduction
** Learning Material
*** Book Chapters
*** Screencasts
*** Lectures
*** Articles
*** Further Reading
** Experiential Learning
*** Sprint Test Plan
*** Assignment Submission
*** Update Course Backlog
** Sprint Acceptance Tests
   You are done with this sprint when:
   
* Sprint 0: Course Introduction					   :noexport:
** About This Sprint
   This sprint introduces the course and the course structure.
** User Stories covered in this Sprint
   - As a student I want to pass this course.
   - As a student I want to understand how this course is structured so that I can quickly find the information I need to learn the subject.
   - As a student I want to know why this topic is important so that I can be properly motivated.
** Introduction
   Welcome to the course!

   Of course you want to pass the course, and I want you to too. This document is intended to give an overview of how the course is structured, and give you a "map" of sorts to the rest of the course material. It is my hope that this will help you find the material you want easily so that you can focus on learning each part of the course.

   The course is divided into a series of /Sprints/, that is, short iterations that focus on a small number of issues per sprint. I have borrowed this term from an agile development methodology called [[https://en.wikipedia.org/wiki/Scrum_(software_development)][Scrum]], which is something you will learn more about in this course and are sure to encounter in your future career as well.

   Speaking of agile, there are a few other things I have borrowed from there as well. The /User Stories/ that each sprint document starts with is one such thing. A user story is a sort of stylised requirement, and I use them to set you into the right frame of mind for each sprint. As you notice, the user story contains information about which /perspective/ you should have, the /goals/ you should achieve, and a brief explanation of /why/ this goal is important.

   Related to this is the /Sprint Acceptance Tests/ that you find at the bottom of each sprint document. These acceptance tests tell you how we plan on ensuring that the goal of the sprint has been reached.

   The bulk of the sprint consists of /Learning Material/, and /Experiential Learning/. Learning material are book chapters, videos, blog posts, etc. that you can use to learn more about the topic in the sprint. Experiential Learning (which is not a good name, but I can't think of any better) consists of different activities you should /do/ as part of the sprint. Some of these activities are just practice activities. Others are activities that will help you organise the material better. Others again are those activities that we (as teachers) would like to look at to assess your progress. Let me repeat this:

#+BEGIN_note
Experiential Learning are things you are supposed to /do/, and includes:
 - Things you do for practice
 - Things you do to organise the material
 - Things you submit as assignments to the teachers for marking
#+END_note

   Some activities are started during this sprint, and then I ask you to revisit them during every subsequent sprint. The idea with these activities are to help you structure your learning, and give you a means to follow your own progress.

   So, without further ado, let's get started with the learning material. /Good Luck!/
** Learning Material
*** Course Structure
    The course has an online presence as well as a campus existense.

    The online presence consists of these pages, and is organised as a set of sprints, where each sprint focus on a small topic and a few user stories. In each sprint there are things to read and watch, as well as activities to do. The result of some of those activities will be submitted as assignments for marking.

    The campus existense consists of lectures (that I try to run as seminars) and exercises. My idea is that you first study the online material, and then we can have lively discussions during the lectures/seminars. Basically, you go through the design notation and a basic understanding of the topic with the online material and then we discuss together what makes a /good/ design.

    The exercises are done in smaller groups and are more geared towards your specific assignments. Here, the idea is to go through what you are expected to do in the assignments and go through examples of this.

    There are also feedback meetings planned where you get feedback on the assignments that you submitted so that you may improve them.
*** Course Goals
    Below, the course goals for the two courses {{{pa1415}}} and {{{pa1435}}} are listed. As you notice, the PA1435 version is of a newer format, but also contains less focus on requirements engineering, project management, and testing activities. This will of course to some extent influence what you are expected to do and deliver, but will only have a limited effect on the lecture series since the topics are still quite intertwined.

| {{{pa1435}}}                                                                                    | {{{pa1415}}}                                                                                                                       |
|-------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------|
|                                                                                                 | Efter genomförd kurs skall studenten:                                                                                              |
|                                                                                                 | - på en grundläggande nivå i grupp kunna ta fram krav på en programvara och uttrycka dem i en kravspecifikation                    |
|                                                                                                 | - i grupp producera en översiktlig utvecklingsprojektplan baserat på en kravspecifikation                                          |
| *Kunskap och förståelse* Efter genomförd kurs ska studenten:                                    |                                                                                                                                    |
| - kunna visa förståelse för grundläggande principer i objektorienterad programvaruutveckling.   |                                                                                                                                    |
| - kunna visa förståelse för UML som modelleringsspråk.                                          |                                                                                                                                    |
| - kunna visa kunskap om grundläggande designprinciper.                                          |                                                                                                                                    |
| - kunna visa kunskap om grundläggande designmönster.                                            |                                                                                                                                    |
|                                                                                                 |                                                                                                                                    |
| *Färdigheter och förmåga* Efter genomförd kurs ska studenten:                                   |                                                                                                                                    |
| - kunna uttrycka strukturen och beteendet hos ett system i termer av objektorienterade koncept. | - i grupp kunna skapa en detaljerad objektorienterad design för ett mjukvaruprogram                                                |
| - kunna korrekt använda UML för att uttrycka struktur och beteende hos ett system.              | - skapa och analysera objektorienterade artefakter uttryckta i UML                                                                 |
| - kunna korrekt transformera en objektorienterad design till källkod.                           | - i grupp kunna implementera ett mjukvaruprogram inom rimlig tid, baserat på en kravspecifikation och en objektorienterad design   |
| - kunna tillämpa designprinciper och designmönster i allmänhet och inom en särskild domän.      | - kunna motivera och använda designmönster i utvecklingen av mjukvarusystem                                                        |
|                                                                                                 |                                                                                                                                    |
|                                                                                                 | - på en grundläggande nivå i grupp kunna planera och genomföra testning av producerad programvara, baserat på en kravspecifikation |
|                                                                                                 |                                                                                                                                    |
| *Värderingsförmåga och förhållningssätt* Efter genomförd kurs ska studenten:                    |                                                                                                                                    |
| - kunna analysera källkod för eventuella förbättringar.                                         |                                                                                                                                    |
| - kunna analysera och kritiskt diskutera en design för eventuella förbättringar.                |                                                                                                                                    |
|-------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------|
*** Why is this course Important?
*** TODO Course Roadmap						   :noexport:
*** What should I do with the Sprint Test Plan?
    The Sprint Test Plan is a way to get an overview of your expectations in the course, in relation to the provided material, and align it with my expectations as course responsible and examiner. In some sense, it is also your strategy for learning the topics. I will not mark your Sprint Test Plan -- you are creating and maintaining this for your own sake.

    The Sprint Test Plan will be revisited during every sprint, so that you have an updated record of what you need to learn to pass the course.

    I am loosely basing my suggestion for the Sprint Test Plan document on the IEEE 829-2008 standard. Feel free to add other information to it if you think it is relevant.
*** What is this "Course Backlog" thing?
    As you study, I expect that you will get more questions, or additional information sources (blog pages etc.) that you would like to read, and I hope you will also get ideas for places where you would like to test what you have learnt. Put these into a course backlog document (it will help if you put them in a roughly prioritised order), and then spend time during each sprint to resolve your backlog items.

    At the end of the course, it is my hope that your backlog contains pointers to yourself with how you should go forward with the knowledge gained. For example, how can you use what you have learnt in upcoming courses? Are there any particularly interesting things you have found that you would like to study more? Are there any courses you are interested in taking as a consequence of taking this course? Are there any courses you would like to /replace/ in your education as a consequence of taking this course? Are there any ideas you can use for your bachelor or master's thesis?

    The course backlog is revisited in every sprint. I will not mark it; you create it for your own benefit.
** Experiential Learning
*** Create Infrastructure
    *Introduction.* In your future career you are going to use configuration management systems such as [[http://svnbook.red-bean.com/][Subversion]] or [[https://git-scm.com/][Git]], so why not start already now? This gives you an easy way to share work between your colleagues, and opens up for me to review your work even before you have submitted it.

    If you also write your documents in for example [[https://daringfireball.net/projects/markdown/][Markdown]], they are formatted for you by github. Myself, I am partial to [[http://orgmode.org/][Org-mode]] and [[https://www.gnu.org/software/emacs/][Emacs]], especially because of the nice integration with [[http://plantuml.com/][PlantUML]] for generating design diagrams and the excellent export facilities. Org-mode is also nicely supported by github.

    *Things to do:*
    - [[https://education.github.com/][Create an account on Github]] (or use your existing one)
    - Create a Project for the course =OOD-<course code>-<your name>=
    - Invite me ([[https://github.com/mickesv][mickesv]]) to the project
    - checkout your project and create a directory structure:
      - =/Assignments/=
      - =/SprintTestPlan/=
      - =/CourseBacklog/=
    - add a file to each directory, otherwise you will not be able to commit them. For example, add an empty =.gitignore= file to each directory.
    - commit and push
*** Sprint Test Plan
    Create a document with the following sections:
    - /Test Items./ These are the assignments you are expected to submit for marking. It will probably be a good idea if you are able to tag them with the corresponding sprint, so that you can easily find them.
    - /Features to be Tested./ These are the user stories at the top of every sprint. Describe each of these features in terms of the object oriented modelling concepts or software development concepts that you need to master before you can satisfy the user story.
    - /Approach./ Here, you will describe /your/ strategy for ensuring that you have learnt the material in the sprint. How do you ensure that you are confident that the assignments you submit will pass with the grade you are aiming for?
    - /Item Pass/Fail Criteria./ What do you have to be able to show to yourself to ensure that you have learnt the material in the sprint? What do you have to show in the submitted assignments?
    - /Schedule./ When do you plan on passing each test item and feature?
    - /Planning Risks and Contingencies./ Are there any foreseeable risks that may limit your ability to pass the course on time? What is your contingency plan?
    - /Glossary./ In this section you will build up a glossary of important terms in the course that you can use when studying. I suggest you collaborate with the rest of the class in the course discussion forum (on It's Learning) and post your terms and definitions there so that they can be discussed.

    In this sprint, the following items can be added already (you may think of more items, please add them too):

    - Test Items
      - Exam [[https://studentportal.bth.se/web/studentportal.nsf/web.xsp/tentamen_under_kommande_veckor][Check Date]]
      - Exam Re-sit [[https://studentportal.bth.se/web/studentportal.nsf/web.xsp/tentamen_under_kommande_veckor][Check Date]]
    - Approach
      - Outline your plan for reading the book and doing the sprints in time to be ready for the exam.
      - Describe your plan for joining a group of students (for the group assignments, and for study groups) with the same ambition level as you yourself have.
    - Item Pass/Fail Criteria
      - Outline your ambition level; what grade are you aiming for?
    - Schedule
      - Dates for assignment submissions are available on It's Learning. Copy them here.
      - Add the exam dates.
    - Planning Risks and Contingencies
      - Do you plan on taking any vacations (e.g., skiing trip, easter, ascension day, etc.)? When will you study more to compensate for this? Are your team-mates informed and ok with that you contribute less during these vacations?
      - What is the expected workload for the courses you may be taking in parallel? Does your plan for /this/ course accomodate your plans for the other courses?
      - Do you have time available if you are asked to complete your submitted assignments with more information?
      - Are there any other risks you see at this stage?
    - Glossary
      - Scrum
      - Sprint
      - User Story
      - Test Plan
*** Buy Course Books
*Main Literature (Both Courses)*
#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/ILarman.jpg]]

C. Larman, /Applying UML and Patterns/, Prentice Hall, 3rd Edition.

This book is a complete guide to all things UML, with plenty of examples and detailed descriptions of all diagrams and how to think when using them. The reading instructions in each sprint are based on the 3rd edition, but I recommend you to try to find an older edition since they are essentially the same but with less text.
#+HTML: <br/><br/><br/><br/><br/><br/>

*Reference Literature (PA1415)*
#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/ISommerville.jpg]]

I. Sommerville, /Software Engineering/, Pearson, 8th edition, 2006.

There is also a 9th and a 10th edition (and, of course, the preceeding editions). It does not really matter which one you get. You will use this book as a reference to look up e.g. how a GANTT chart works in case the internet is down.
#+HTML: <br/><br/><br/><br/><br/><br/>

*Reference Literature (PA1435)*
#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/IGamma.jpg]]

Gamma, Helm, Johnson, Vlissides, /Design Patterns, Elements of Reusable Object-Oriented Software/, Addison-Wesley Professional.

This book, also called the Gang of Four book is /the/ reference work when it comes to design patterns. You will be using this book a lot in your future career. If you want to save some money, the most common design patterns are also covered in C. Larman (and these are the ones we will be focusing on in these courses).

/Note to PA1415:/ I warmly recommend that you too get this book even if it is not oficially part of "your" course plan.
#+HTML: <br/><br/><br/><br/><br/><br/>

#+ATTR_HTML: :width 100 :style float:left;margin-right:1em;
[[./images/INystrom.jpg]]

R. Nystrom, /Game Programming Patterns/, Genever Benning, 2014.

Also Available at: http://gameprogrammingpatterns.com/contents.html
#+HTML: <br/><br/><br/><br/><br/><br/>

#+HTML: &nbsp;
*** Form Groups
    We expect the assignments to be done in /groups of three to five people/. Use the following (in this order) to find and/or form a group:

    1. Your friends
    2. It's Learning
    3. First Classroom Lecture
    4. Course Teacher

    Decide in your group how to deal with configuration management (e.g., who creates the git repository (remember to share it with me)), and decide on a schedule for when and how often you plan on working. If you know that you need to be out of touch for some reason (e.g. spring break), agree within the team how to handle this.        
*** Assignment Submission					   :noexport:
*** Update Course Backlog
    Where do you go from here? Are there any questions already now that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have bought the literature you want/need for the course.
   - You have joined a group.
   - You have created a github account, created a project repository, and committed/pushed the directory structure.
   - You have read the Learning Materials

   You may also have
   - Created a Sprint Test Plan
   - Created a Course Backlog
* Sprint: Development Methodologies				   :noexport:
** About This Sprint
   This sprint introduces different development methodologies. It is primarily targeted at {{{pa1415}}}.
** User Stories covered in this Sprint
   - As a project manager I want to plan the project so that I can make the best use of my resources.
   - As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.
   - As a project manager I want to track the project so that I can see what the current status is.
   - As a project manager I want to track the project so that I can forecast whether we will deliver on time or not.
   - As a software designer I want to document my design in a standardised format so that I can communicate it to other software engineers.
** Introduction
   In this sprint, we focus on a couple of issues surrounding the /development process/. First of all, there are a number of choices of which developent process to use, from the intuitively easy to grasp waterfall process to the highly individualised kanban process. Which process type to use depends to some extent on the product you are trying to build, but perhaps more so on which organisation you have. Basically, with stable development teams and fairly stable requirements, you can perhaps do an iterative or incremental project, but the more user interaction, continuously changing requirements, and staff turnover you expect, your organisation will tend to move towards more agile processes. There is also a lot of hype involved here. Companies that do agile are perceived as more modern, hip, and better.

   Most processes internally follow a waterfall course of events, with planning, requirements engineering, analysis and design, implementation, testing, deployment, and evaluation. The differences boil down to the amount of work that one iteration takes on, the size of the development teams, and the length of each iteration. Again, in agile there are also a lot of buzzwords added, but that's essentially it. So simple, and yet so powerful. You see, /as/ the scope and timespan for each iteration is reduced (down to weeks or even days), you get quicker feedback loops. You develop much less before you get feedback on what you have done. You also need to be smarter with what you develop so that you can get the /most important/ feedback first.

   This is where the concept of a /Minimum Viable Product/ comes in. A minimum viable product, or an MVP, is a product that supports an entire end to end flow. For example, if you are building a hotel booking system, the MVP may be a product that allows you to search and book one single room. Logging in, booking double rooms with extra beds, adding a minibar, room payment, etc. comes later. Searching for and booking a single room means you have /some/ user interface in place, you have a database structure, and you have /some/ architecture with a structure for how to name API endpoints.

*** Project Planning and Tracking
   Once you have decided which development methodology to use, you need to plan your project. You have already decided if you are going to do all analysis before all design or whether you are going to do the full analysis-design-implement-test chain for each feature in your system. But /when/ are you going to do what, and /who/ is going to do what. You may, for example, have some persons in your project that are specialised on user interfaces, on databases, or on exploratory testing. So you need to plan every person and every part of the process. 

   The first step of planning is to break down each task into smaller, more manageable tasks. For example, the task "Search for Room" in the hotel management system mentioned above, may consist of the tasks "database design", "GUI design", "implementation", and "testing". Each of these tasks are easier to estimate the size and difficulty of than the overall task. You can also now start assigning different parts of this task to different people, if you like. This breakdown is usually referred to as a /Work Breakdown Structure/, or a WBS. It is often graphically represented as a tree (see Figure [[fig:WBS]]), but may just as well be represented as several columns in a spreadsheet (see Table [[tab:WBS]]).

#+BEGIN_SRC dot :file images/FWBSExample.png
digraph {
rankdir=BT;
splines=true;
node [shape=box];

"..."
sr [label="Search for Room"]
sr -> "..."
"Database Design" -> sr
"GUI Design" -> sr
"Implementation" -> sr
"Testing" -> sr
"Implement DB" -> "Implementation"
"Implement Logic" -> "Implementation"
"Implement GUI" -> "Implementation"
"Create Tests" -> "Testing"
"Run Tests" -> "Testing"
}
#+END_SRC

#+CAPTION: An example of a graphical representation of a part of a WBS.
#+NAME: fig:WBS
#+RESULTS:
[[file:images/FWBSExample.png]]

#+CAPTION: An example of a spreadsheet representation of a part of a WBS.
#+NAME: tab:WBS
| Feature Group | Feature         | Tasks           | Sub-Tasks       |
|---------------+-----------------+-----------------+-----------------|
| ...           | Search for Room | Database Design |                 |
|               |                 | GUI Design      |                 |
|               |                 | Implementation  | Implement DB    |
|               |                 |                 | Implement Logic |
|               |                 |                 | Implement GUI   |
|               |                 | Testing         | Create Tests    |
|               |                 |                 | Run Tests       |

Having the data in a spreadsheet format makes it (IMHO) easier to work with, and also enables you to easily add more columns with data on who is responsible for the task, your effort estimations, your current status, etc. Essentially, you have the starting point for easily creating a /GANTT/ chart.

GANTT charts visualise your project in terms of activities and calendar dates, but you may just as well add more information to it to make it a full-fledged project tracking tool. For example, a simple format is to include the following information (Table [[tab:PPData]]).

#+CAPTION: Project Planning data that may be added in a GANTT chart
#+NAME: tab:PPData
| Task Name    | Estimated Effort (in hours) | Start Date | End Date                                                | Responsible    | Spent Time | Progress (in percent) | Projected Effort            | Over/Undertime                          | ... And here starts the GANTT chart proper with one column per day |
|--------------+-----------------------------+------------+---------------------------------------------------------+----------------+------------+-----------------------+-----------------------------+-----------------------------------------+--------------------------------------------------------------------|
| Example Task |                          20 | 2016-01-01 | =(Start Date) + (Estimated Effort)/(Length of Workday)= | Example Person |         12 |                    50 | =(spent time) / (progress)= | =(estimated effort)-(projected effort)= |                                                                    |

The discussion above focus on the /work performed/ (or the planned work). In contrast, agile methodologies focus on the /earned value/, which gives a slightly different picture. Whereas you can use the information above to tell your boss whether you are on time or not, you are not able to say at a glance how happy this has made the customer, or how many features you have left to before you are done. For these purposes, we use /Earned Value charts/ and /Burn charts/.

An Earned Value chart has three lines in it
- Planned Value :: How much of the estimated effort should have been completed at a specific point in time.
- Earned Value :: How much of the estimated effort was actually implemented at a specific point in time.
- Actual Cost :: How much effort was actually spent.

This is typically presented in a cumulative earned value chart (where the previous assessment period are added to the next, so that planned value end up at 100% at the far right of the chart. In Figures [[fig:EVChartP]], [[fig:EVChartC]], and [[fig:EVChart]] each of these lines are added. The x-axis represent the time, and the y-axis is some measure of value. This can be in hours, progress, pounds, story points, collected pokemons, or whatever makes sense for your project. Just make sure that it is a unit that is fixed /a priori/, and not something that will change throughout the project. For example, the number of lines of code (LOC) may seem a nice measure, but you know as well as I do that this will become larger than expected, and so you will end up not knowing how much more you need to write before the project is done (as opposed to as big as you initially expected it to be).

The planned value represent how much of the total value you plan on having done for each weeek (cumulative, so the difference in the amount of value added per week can only be seen by the differing slope of the line). If we add the actual cost (Figure [[fig:EVChartC]], sorry that the colour of the lines change, I CBA to fix it right now), we can see that we are spending about as much resources as planned. Specifically, we are spending /more/ than planned up until week 8, and after that we apparently come to grips with the project and continue spending less than planned. This graph shows the current state at week 18, which is why the actual costs flatline after that. Adding the eraned value, finally, gives the situation in Figure [[fig:EVChart]], where we see what we actually managed to deliver for the costs we invested. Up until week 8, we are delivering what is expected (the Earned value curve completely overlays the planned curve), but for a higher cost than expected. From week 8 to week 11, we are delivering more than expected. At best, we are one week ahead of schedule (the biggest horizontal difference between the Earned Value curve and the Planned Value curve). At week 11 we again slip behind shedule for a while, catching up in week 16 and 17, but then falling horribly behind schedule in week 18.

#+CAPTION: Earned Value Chart: Planned
#+NAME: fig:EVChartP
[[./images/IEV_Planned.png]]

#+CAPTION: Earned Value Chart: Adding Actual Cost
#+NAME: fig:EVChartC
[[./images/IEV_Cost.png]]

#+CAPTION: Earned Value Chart
#+NAME: fig:EVChart
[[./images/IEV_Earned.png]]

So what we see in this type of chart is a quick and easy measure of whether we are using our resources as planned (is the actual cost above or below the planned value curve?), and whether we are ahead of, or behind the planned schedule (is the earned value curve above or below the planned value curve?). We can then quickly decide whether we should add more resources to the project. In the example in Figure [[fig:EVChart]] we obviously need to do something if we are going to deliver as expected, for example spending the resources we already have allocated to the project (the difference between planned value and actual cost curves).

A burndown chart essentially turns this chart upside down. Partially, this is done for psychological reasons; it is easier to see how much or how little remains), but more importantly it enables us to easily visualise what happens when we add more work in the middle of a project. Consider the example in Figure [[fig:Burndown]]. The plan is that the project should be complete at week 22. However, at week 5 and week 15, more work is added to the project, so the number of story points still to complete goes up. This means that at week 22, there are still some forty-odd story points left to complete and the project is not done. This is just one example of how a burndown chart can be used to easily visualise the consequences of changing the scope mid-project. Agile development methodologies are not averse to changing the scope -- rather the opposite -- but they /do/ insist on that the consequences are known and easily understood.

#+CAPTION: Burndown chart
#+NAME: fig:Burndown
[[./images/FBurndown_Replan.png]]


*** Design Documentation
#+ATTR_HTML: :width 600
#+NAME: Arne01
[[./images/arne01.png]]

The last user story for this sprint is a bit of an oddball. What, one may wonder, does design documentation have to do with development methodologies. The reason for this is that the currently dominating design documentation format, the Unified Modelling Language (UML), also prescribes a certain way of doing the design, and a certain order for things to be done. This process is known as the /Unified Process/, or the /Rational Unified Process/ (because the originators created the company Rational and wanted to make more money off everything around UML). The Unified Process claims to be agile (we can debate this in the classroom), and is iterative and incremental and whatever buzzword /du jour/. We are not going into detail about all of this in this course, and will focus almost solely on the analysis and design stages, but even here, or especially here the different UML diagrams prescribe a certain order, so that you may use what you learn in one diagram as input to creating the next diagram. Thus:

- We do Requirements Engineering (outside the scope of UML) to find out what the customers and other stakeholders expect from the system.
- We do UML Use Cases to document the requirements in the context of the processes they are going to be used, so that we can communicate with the stakeholders about them.
- We do UML Use Case Diagrams to get an overview of, and understand how the UML Use Cases fit together.
- We do a Conceptual Model based on the requirements and the use cases to understand the problem domain better.
- We do UML State Diagrams based on the requirements and the use cases to understand the dynamic behaviour better.
- We do UML System Sequence Diagrams to understand which system events are generated by each UML Use Case.
- We may do UML Design Contracts to understand how each system operation from the UML System Sequence Diagrams changes the state of the application and instances of domain concepts.
- We do UML Class Diagrams to understand which domain concepts are important to implement, and how to implement them and their relations.
- We do UML Interaction Diagrams to understand how objects (instances of the classes) interact to solve one particular system event from the UML System Sequence Diagrams.
- We revise the UML Class Diagrams based on the UML Interaction Diagrams we just did.
- We implement the system based on the UML Class Diagram and the UML Interaction Diagrams.
- We write test cases based on the UML use cases.

Remember earlier where I mentioned that UML/RUP claims to be agile? Please take a moment to reflect upon whether you are able to do this entire list and remain agile. 

In 2014 a colleague of mine did a survey [fn:TGO-paper] among nearly 4000 professional software developers about their software development practices in general. One of the questions was the seemingly innocent /"Do you model?"/. Answers ranged from "no" to "hell no!", as presented in Figure [[fig:TGOSurvey]].

[fn:TGO-paper] T. Gorschek, E. Tempero, L. Angelis, /On the use of software design models in software development practice: An empirical investigation/, in Journal of Systems and Software 95(2014):176--193.


#+CAPTION: Survey Question and Answers
#+NAME: fig:TGOSurvey
  [[./images/ISurveyModelling.png]]


In the freetext answers a different story emerges:

#+BEGIN_info
The industrial software developers who answered the survey do use sketches, informal models, casual diagrams, etc, but not formal UML.
#+END_info

They were also allowed to provide a a further explanation to their answer. Common explanations were:
    - "Only for very complex designs, sometimes"
    - "Only use initially then start coding (diagrams not kept/updated)"
    - "Enables visualisation of the big picture/high level"
    - "Other types of models but not UML"
    - "Use models to communicate and coordinate with other developers"

... And many more, but the long and the short of it is that /models are not used as researchers expect/. Instead they are used for *conceptual analysis and exploration, problem solving, visualisation, and communication*. And this is the reason for why modelling and UML is worth bothering about. In order to visualise and communicate efficiently, it is helpful to use a common standard, which UML contributes. That way you can focus on /what/ you want to model and discuss instead of spending time explaining /how/ you have chosen to represent the information. For the analysis, exporation, and problem solving aspects it also helps to have a common notation to use. Try explaining how to tie your shoelace while at the same time invent a new language for it, and you'll see what I mean.

That being said, /you will probably never ever going to use all of UML in one particular project/, and after you complete this course, /no-one will probably ever require you to stick fully to the prescribed notation/.

So, why bother?

By taking a course in object oriented modelling, you will get training in a particular mindset, where you begin to analyse a problem in terms of its /objects/ and their /interactions/. This problem solving mindset is difficult to reach when bogged down with all the implementation details. Also, while you will not use /all/ diagrams outside this course, knowledge of which diagrams exist and how they fit together will enable you to make an informed decision about /what/ models are necessary for you to understand the problem and to communicate it. You should, however, bear in mind that there are some good things with doing the full monty UML as well, and by cherry-picking models and parts of the process you are sacrificing them. The trick is to be able to do this with full awareness of what it is you sacrifice.

So, with those heartwarming words, let's delve into /not/ UML, but development processes instead. You will notice that I have thrown in a few book chapters that are not precisely related to development methods, and some of the chapters will appear again in other sprints. But now is as good a time as any to get started on them.
** Learning Material
*** Book Chapters
    - {{{larman}}}: Chapters 1, 2, 4, 21, 40.
      1. Object-Oriented Analysis and Design
      2. Iterative, Evolutionary, and Agile
      3. Case Studies (we will be using the POST case study)
      21. [@21] Test-Driven Development and Refactoring
      40. [@40] More on Iterative Development and Agile Project Management
*** Screencasts
    - [[https://play.bth.se/media/Development+Process/1_gmy3m68z][Development Process]]
*** Lectures							   :noexport:
*** Further Reading
    - [[https://www.mountaingoatsoftware.com/presentations/an-introduction-to-scrum][Introduction to Scrum by Mike Kohn]]
    - [[http://www.workbreakdownstructure.com/][Work Breakdown Structure]]
    - [[http://www.gantt.com/][GANTT charts]]
    - [[http://www.dummies.com/how-to/content/earned-value-management-terms-and-formulas-for-pro.html][Earned Value charts]]
    - [[http://alistair.cockburn.us/Earned-value+and+burn+charts][Earned Value and Burn Charts by Alistar Cockburn]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear solution to each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Waterfall Development
    - Iterative Development
    - Incremental Development
    - Agile
    - Scrum
    - Kanban
    - Minimum Viable Product (MVP)
    - Work Breakdown Structure (WBS)
    - GANTT chart
    - Earned Value Charts
    - Burn Charts (Also: Burndown charts and burn-up charts)
    - UML
    - Unified Processs (Also: Rational Unified Process RUP)

    Make sure that you understand what each item is, but also what the differences between them are (where applicable).
*** Assignment Submission
    Create a Assignment Plan document (e.g., as a GANTT spreadsheet). Add the assignments that you will need to submit in this course, and do a brief breakdown of them into their most obvious tasks. Add early time estimates for these tasks.

    There is no formal submission in this sprint, but make sure that the plan is committed and pushed to your project repository.
*** Update Course Backlog
    Which development methodology do you plan on using for your projects in this course? Which development methodology would you like to know more about? Which development methodologies are you likely to encounter in the future? Is there any methodology that seems particularly suitable for other courses?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.    
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have read the Learning Materials.
   - You have created your Assignment Plan and committed/pushed it to your project repository.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
* Sprint: Requirements Engineering				   :noexport:
** About This Sprint
   This sprint briefly introduces the topic requirements engineering. It is primarily targeted at {{{pa1415}}}.
   
   For more information on this topic, see e.g. the course =PA1412 Praktisk Kravhantering=.

#+BEGIN_note
   *Note:* In this sprint you will begin with what will eventually be delivered as a part of Assignment 1. In subsequent sprints you will continue with what you produce here and dive deeper into UML. You will thus only produce a partial delivery in this sprint.
#+END_note
** User Stories covered in this Sprint
   - As a requirements engineer I want to know who may have requirements on the system we are building so that I can make sure that all needs are met.
   - As a requirements engineer I want to have a range of methods for finding requirements so that I can choose the best method for each person or source of requirements.
   - As a requirements engineer I want to document the found requirements so that I can discuss them with the customer.
   - As a requirements engineer I want to document the found requirements so that I can communicate them to the developers.
   - As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.
** Introduction
   Before you start designing your system, you need to find out /what/ to design and build. There are of course different ways of doing this. The traditional way advocates that you need to fully understand the entire system before you go ahead with the design (cf. /waterfall development/), whereas at the other end the agile approach (e.g. as advocated by [[http://www.extremeprogramming.org/][eXtreme Programming]] and the [[http://agilemanifesto.org/][Agile Manifesto]]) is that you should only do as much requirements engineering up front as is necessary to understand how to start building, since the requirements are going to change anyway. Note that they do not say "Don't do it!"; they say "Do as little as possible, but not less".

   It is thus important to decide early how much requirements engineering you should do before you start with the project. Incidentally, there is a difference between the traditional, so called /bespoke/ requirements engineering where you start a project when a customer knocks on the door and then you do requirements engineering as part of that project, and the /continuous/ requirements engineering where you always do requirements engineering and spawn new development projects as a result of the requirements engineering process. The latter suits the type of products that you develop and sell to more than one customer, while the former is more suitable for one-off projects. For this course, I would suggest a pragmatic approach (akin to the agile way): Do as much requirements engineering so that you have a rough overview of what the system should do, and do proper requirements engineering on what you need to know do make a Minimum Viable Product. 

   There are many sources and techniques for doing requirements elicitation (i.e., finding the requirements), from reading the old documentation, analysing competitor's products, interviewing users, running surveys among user groups, or simply inventing the requirements yourself. If you do requirements engineering you will be using a mixture of these. Typically, you will start by doing an unstructured interview with a manager to get a broad overview of what they want the system to do. You will then try to define end user groups and find a couple of representative persons from each user group and conduct further interviews with them. At first, these interviews will be exploratory and unstructured, but will pretty soon become semi-structured as you learn about the major features of the system, so that you will be getting further details about each of these major features.

   Finding out who may have an interest in the system (a /stakeholder/) is so important that I have even added a separate user story for it in this sprint. This is not limited to end-users. Other stakeholders may include (but is not limited to): the organisation that is going to maintain and continue development of the system, system service technicians that will be doing backups and adding users and other running maintenance, external parties that you may connect to (for example banks to deal with payments), legal texts (that's right: a text can be a stakeholder), other departments in the organisation you build for that require your system to jack in with their processes, and so on.

#+CAPTION: Requirements Engineering Overview (Simplified)
#+NAME: fig:REProcess
[[./images/FRE_Process.png]]

*** Interviews
I've already touched upon elicitation techniques. The one you are likely to use the most is /Interviews/. "Interview" is actually a cover-all phrase that encompasses a whole range of different techniques that involves two people or more with (at least) voice contact. You /may/ thus do interviews over phone, but I would not recommend it since you loose a lot of nuances that can be learnt by observing body language. Video conference or face-to-face meetings IRL are the most common interview settings. You can be one person interviewing one other person, or there can be more people either doing the interview or being interviewed (although at some point it is perhaps better to run the meeting as a [[https://en.wikipedia.org/wiki/Focus_group][focus group]]).

In its most simple form, you conduct the interview as an /open interview/ with /open answers/. In this setting, you basically just talk, and together explore what the application should do. You rarely have the luxury to be this unstructured, even in the first interview. I would recommend you to do as much homework as possible beforehand so that you have at least a small set of starting questions that you can use to get the interview going and to get back on track when you feel that you have diverged too far from the interview goals. Having a set of questions moves the interview into a /semi-structured/ format, where you are able to follow up on the answers given with further impromptu questions. The extreme is a /structured/ interview where you have a specific set of questions that you want answered in a particular order without room for any further probing. This is typically only used in research contexts.

Similarly, you can allow /open answers/, typically early on when you want to explore and look for new information, or you can restrict the answers to a /closed answer/ space, where each question can e.g. be answered with one of four alternatives. This is good for confirming what you have previously learnt; you can collect answers from larger groups of people and quickly analyse them, and the idea is that at that stage you should not expect to find any new information.

Thus, a requirements engineer will probably use semi-structured open answered interviews. In this course, however, this will not be the case as it would be out of scope for the course. You will instead have to create the requirements yourself (more on this under the Experiential Learning in this sprint).

How you behave during an interview influences the results, because your behaviour can make the interview subjects more or less prone to answer your questions. In Table [[tab:InterviewsDnD]] I have compiled a list of do's and don'ts in interview situations (we have actually used this list to assess requirements elicitation interviews in the requirements engineering courses at BTH).

#+CAPTION: Do and Don't in an Interview Situation
#+NAME: tab:InterviewsDnD
| Do                                                       | Don't                                                                    |
|----------------------------------------------------------+--------------------------------------------------------------------------|
| Do    prepare thoroughly for the meeting                 | Don't put your laptop on the table as a wall between you and your client |
| Do    prepare a checklist for the meeting                | Don't keep your cap on your head                                         |
| Do    introduce yourself properly                        | Don't interrupt the customer                                             |
| Do    ask about access to stakeholders                   | Don't interrupt each other                                               |
| Do    ask about access to previous systems               | Don't take no notes                                                      |
| Do    book the next meeting                              | Don't record the interview without asking                                |
| Do    ask about quality requirements                     | Don't assume stuff                                                       |
| Do    make sure you know who you are talking to, and why | Don't provide requirements                                               |
| Do    ask about deadlines                                | Don't provide goldplating                                                |
|                                                          | Don't technobabble                                                       |
|                                                          | Don't sit quiet                                                          |
|                                                          | Don't kiss up (too much)                                                 |
|                                                          | Don't follow your meeting checklist manically                            |
|                                                          | Don't share war-stories about other customers and systems                |
|                                                          | Don't ask about the budget at the first meeting                          |
|                                                          | Don't argue among yourselves                                             |
*** Specification
    Once you have found the requirements, your next step (after analysing them and negotiating them with the customer, but that is also outside the scope of this course) is to /Specify/ the requirements. There is an IEEE standard, [[fig:SRS][IEEE 830]], for how to structure your requirements document, assuming you specify requirements in the traditional way. The good thing about this is that it has existed for many years, and people are used to seeing it and signing contract based on it. The bad thing about it is that it is not as well known or easy to understand as requirements engineering researchers would like to think it is, and with a few moments of education I am certain that you will be able to educate your customers on any document and requirements format you choose.

#+NAME: fig:SRS
#+BEGIN_info
*IEEE 830 Standard for Software Requirements Specifications*
   1. Introduction
      1. Purpose of the Requirements Document
      2. Scope of the Product
      3. Definitions, Acronyms, and Abbreviations
      4. References
      5. Overview of the Remainder of the Document
   2. General Description
      1. Product Perspective
      2. Product Functions
      3. User Characteristics
      4. General Constraints
      5. Assumptions and Dependencies
   3. Specific Requirements
      Functional, non-functional, and interface requirements
   4. Appendices
   5. Index
#+END_info

To simplify, there are two plus one ways of writing requirements. The two ways are traditional requirements and user stories. The plus one way is UML use cases. UML:ists themselves claim that use cases are not requirments, they are merely scenarios where one or several requirements are "exercised". I would rather avoid re-formatting the requirements once more and just add more documentation that will only be used once, so I would try very hard to get away with only documenting the requirements within the context of a use case if I must use them.

#+BEGIN_SRC ditaa :file ./images/FRESpecification.png
        +------------------+  +-----------+
        | Requirements     |  | UML       |
        | cGRE             |  | Use Cases |
        |                  |  | cBLU      |
        +------------------+  |           |
                              |           |
        +------------------+  |           |
        | User Stories     |  |           |
        | cGRE             |  |           |
        |                  |  |           |
        +------------------+  +-----------+
#+END_SRC

#+CAPTION: Two plus one way of specifying requirements
#+NAME: fig:REtwoplusone
#+RESULTS:
[[file:./images/FRESpecification.png]]

Traditional requirements may be specified as figures, tables, sketches, or plaintext, with the plaintext version being the one most commonly discussed. They usually follow a standardised format with a number of attributes per requirement (title, description, source, date, etc.), and a standardised template for the actual requirement. User Stories are supposed to be less documentation so they try to include the most relevant of all of this information into a single one-liner. Shorter iterations, a more direct path from inception to implementation, and closer collaboration with the customer makes it easier to do away with a lot of the information considered necessary in traditional requirements.

UML use cases are covered in a different course sprint, so I will only briefly mention them here. With a use case, you are attempting to put the requirements into a context. Of course, this means that you need to write more, since you also need to add information about the context. This is one of the reasons why they are not considered requirements -- they are simply too verbose. This verbosity also means that a developer is unlikely to do use cases for every requirement and every part of the system; but will rather do them for those parts of the system where there is a usage flow that is difficult to grasp in one sentence, and where you are likely to hold a "conversation" with the system to fulfill a higher need. For example, searching for a hotel room is a one-liner. /Booking/ a room on the other hand may involve
- a search
- a narrowing of the results to specific types of rooms
- a check whether the room is available
- a selection of the room
- input of information about the person booking the room, and
- a confirmation that the room is booked.

Each of these items may, in turn, comprise more than several requirements, including at least one requirement that restricts the order in which these actions must be performed.

*** Prioritisation
[[./images/I0Programmer.jpg]]

So, which requirement should you focus on developing first?

In traditional requirements engineering, there is a whole phase solely dedicated to requirements prioritisation. Agile software development methodologies (such as Scrum) also assumes that you always have your user stories prioritised in your backlog. Essentially, you are doing insertion sort whenever you add a new user story, while also checking that the priority of the existing items do not change as a result of adding the new user story. Each sprint begins with a review of the backlog, before you select among the top prioritised user stories which you should develop in the sprint. If the user story is really big (called an /epic/), one of the actions you may do is to break it down into more manageable user stories and put these into the backlog.

This, of course, does not answer the question since it only explains /how/ you decide, but not /on what grounds/. Also here, you can probably build a research career on deciding which factors should influence your prioritisation (see, for example, Ruhe and Saliu's paper "The art and Science of Release Planning" [fn:Ruhe]), but a few good starting points are:

- Value for the customer
- Cost of implementation (Cost and Value can be nicely combined as e.g. Karlsson and Ryan [fn:CostValue] shows).
- Penalty for not implementing

UML/RUP would advocate that you wait with prioritising your requirements and instead prioritise the UML use cases, so that you deliver the most important features first. This does not mean that you need to implement the full flow of events in one go; always keep the Minimum Viable Product in mind.

[fn:Ruhe] G. Ruhe and M. O. Saliu. /The art and science of software release planning/. IEEE Software, 22(6):47–53, 2005.
[fn:CostValue] J. Karlsson and K. Ryan. A cost-value approach for prioritizing requirements. IEEE Software, 14(5):67– 74, 1997.

*** Summary
Requirements Engineering is a big topic, and can be quite complex. The introduction above is just meant to get you started. I have, for example, only touched upon the difference between bespoke and market-driven requirements engineering. I have not mentioned any of the challenges involved when you do large scale requirements engineering or very large scale requirements engineering. Nor have I gone through all the different techniques available for eliciting requirements, checklists for analysis, requirements verification, etc. etc. You will get some more information about some of these things in the screencast "Requirements Engineering", and for the rest I direct you towards one of the requirements engineering courses offered at BTH.

I include some of the UML Use Case learning material in this sprint which will give you a head start for the next sprint, but the focus on what you are expected to do is "traditional" requirements engineering.

A note also about elicitation techniques: I say earlier that you are most likely going to use interviews. Well... In this course that's not quite true. In this course you are going to create the requirements yourself, based on a brief system description.
** Learning Material
*** Book Chapters
    - {{{larman}}}: Chapters 4,5,6, and 7.
      4. [@4] Inception is Not the Requirements Phase
      5. Evolutionary Requirements
      6. Use Cases
      7. Other Requirements
*** Screencasts
      - [[https://play.bth.se/media/Requirements+Engineering/1_epma2li8/41750261][Requirements Engineering]]
      - [[https://play.bth.se/media/Use+Cases/1_d4tqygel/41750261][Use Cases]]
*** TODO Lectures						   :noexport:
    Ideas:
    - Requirements Elicitation Roleplay?
    - Good and Bad Requirements?
*** TODO Further Reading					   :noexport:
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Requirements Engineering
      - Requirements Elicitation
      - Stakeholders
      - Software Requirements Specification (SRS)
      - RFC 2119
      - Requirements Prioritisation
    - Quality Attribute (Also: Non-functional Requirement)
    - User Story
    - Epic
    - Backlog
    - Acceptance Test
    - Use Case

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.
*** Self-Study: Requirements Interview
    Let's say you are going to build a student simulator. As a part of this you need to find out the morning practices of a typical student.
    
    Interiew a couple of student colleagues on what they do in the mornings. Try to plan beforehand, and have your colleague assess what you do good and what you can improve during the interview.
*** Self-Study: Requirements Specification
     Try to write down a common process for what you elicited above, i.e. the "getting up, getting ready, and getting to uni in the morning"-process.

     Express this process as:
    - regular requirements (consider their apartment, their mother, the bus, etc. as part of "the system")
    - user stories (think about the role they have for each part, and the motivation for why they want something done)
    - use cases  (consider their apartment, their mother, the bus, etc. as part of "the system")
*** Assignment Submission: Requirements Document
    Your main task is to write user stories based on the system description for the assignments.

    *Tasks*
    1. Describe the system in terms of the most important workflows, as "epics". Add conditions of satisfaction to each epic.
    2. List the epics in order of importance, and add a brief motivation for why you have ordered them the way you have.
    3. Take the three most important epics, and break them down to more manageable user stories. Add conditions of satisfaction to the user stories. Order them according to priority, and add a brief motivation.

#+BEGIN_info
    *Document Structure:*

1. Title Page
   1. Title: "User Stories for System: <system name>"
   2. Sub-title: "Assignment in the course {{{pa1415}}}"
   3. Date
   4. Authors and Author Contribution

      Add a table with all authors, their social security numbers, and the share in percent that the author has contributed in thinking (discussing, reasoning, etc.) and in actually writing the submitted assignment document.

      | Author Name | Social Security Number | Thinking | Writing |
      |-------------+------------------------+----------+---------|
      |             |                        |          |         |
2. System Description

   A brief description (2-3 paragraphs) of your interpretation of what the goal of the system is.
3. High-level Epics
   1. Motivation for Priority
   2. Epics (ordered most important first)
4. User Stories
   1. Motivation for Priority
   2. User Stories and Epics (ordered most important first)
5. References
#+END_info    

#+BEGIN_note
*Please note* that the "User Stories and Epics" shall include /both/ the remaining epics from section 3 in the document /and/ the broken down user stories.

*Please also note* that the user stories from the epics that you break down will probably be interlaced; the least important user stories from the top-most epic need not be more important than the most important user stories from the second epic. You will thus have to review the priorities of /all/ user stories against all other user stories and epics.

*Also also note*, when you go forward you will want each user story to have a unique ID so that you can refer back to them.
#+END_note

{{{commit}}}

#+BEGIN_tip
*Conditions of Satisfaction*

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution 
1. Size of assignment: Are there 5-10 epics and 10-30 user stories?
2. Is there a significant difference in scope between the epics and the user stories?
3. Are the epics and user stories well formed (including actor, goal, and reason)?
4. Are there relevant conditions of satisfaction for each user story/epic?
5. Is there a reasonable motivation for the priorities of the epics and user stories?
6. Does the prioritisation actually follow the motivation?
#+END_tip

*** Update Course Backlog
    How do you translate your user stories into UML use cases? How do you use the prioritised order to decide on a development schedule? Why are you specifying your requirements first as user stories if you are then going to re-specify them as UML use cases immediately afterwards?

    What other means are there for eliciting requirements? How may you gain experience in using them?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have read the Learning Materials.
   - You have created the "User Stories" document and committed/pushed it to your project repository.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Performed self-study requirements interviews
   - Documented the results from the self-study interviews in different formats.
* Sprint: Use Cases and Use Case Diagrams
** About This Sprint
   This sprint introduces UML use cases and UML use case diagrams as a means of putting requirements into a context and understanding the interactions between users and the system.
** User Stories covered in this Sprint
   - As a software designer I want to document what the customer is telling me so that I can discuss my understanding of their requirements with them.
   - As a software designer I want to document what the customer is telling me so that I can easily continue designing based on a joint understanding.
   - As a software designer I want to be able to reuse common procedures between my use cases so that I only have to maintain them in one place.
   - As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.
   - As a product manager I want to make sure that we are building software of high quality.
** Introduction
   UML use cases is the first step into Object-Oriented Analysis, according to RUP. The core of a use case is a small set of attributes (name, involved actors, brief description, main course of events, alternative flows). Depending on which version of the course book (Larman) you have you may extend this set with more attributes, and they will have different names (for example Brief (or high-level) use cases and fully dressed (or expanded) use cases) depending on how much information you provide. Outside of this course, it is not important what you call the attributes, or what you call the use cases themselves. What is important, though, is that you establish an order in which to work with the use cases, and that you decide on one standardised format -- at least for your project, but preferrably for your organisation -- since this simplifies both readability and the creation of the use cases.

#+BEGIN_info
*An Example of a Use Case*

- Use Case :: Order Ice Cream
- Actors :: Kid, Ice Cream Man
- Description :: A kid arrives at the ice cream truck and orders an ice cream.
     The Ice Cream Man delivers the ice cream, and informes the kid about the price.
     The kid pays and eats their ice cream.
- Main Course of Events ::
     | Actor                                                    | System                                                           |
     |----------------------------------------------------------+------------------------------------------------------------------|
     | 1. A kid arrives at the ice cream truck                  |                                                                  |
     |                                                          | 2. The system informs about available choices                    |
     | 3. The kid orders an ice cream                           |                                                                  |
     |                                                          | 4. The system prepares the ice cream and informs about the price |
     | 5. The ice cream man delivers the ice cream.             |                                                                  |
     | 6. The kid pays.                                         |                                                                  |
     | 7. The ice cream man enters the payment into the system. |                                                                  |
     |                                                          | 8. The system gives change on the paid amount.                   |
- Alternative Flow of Events :: 6. The kid eats the ice cream and gets sucked into the ice cream van and turned into more ice cream.
#+END_info

   The usefulness of use cases lies in that you put a bunch of requirements into a working scenario. A scenario is easier for both the end-users and for the developers to understand. Rather than having to go through all possible alternative branches and edge cases, you focus on describing /one instance/ of interacting with the system. In the example above, it is not "any kid" that arrives at "any ice cream truck". It is one /specific/ kid (Let's call him Bob) arriving at /one specific/ ice cream truck, at /one particular time/. Yes, we do take some shortcuts by saying that the kid orders "an ice cream" instead of "a vanilla ice cream" in order to simplify a bit, but initially we try to avoid anything that may create branches in the main course of events. When we iterate the use case we may see that there are alternative flows to cover (like the [[http://www.imdb.com/title/tt0113376/][surprise twist]] in the example).

[[./images/Iwow-that-escalated.jpg]]

It is also important to remember that the main course of events should describe a /positive flow/, i.e. a flow where the operation succeeds and everyone leaves the use case happily. All the negative flows (for example, the kid does not have enough cash, the ice cream man is out of voodoo dolls, etc.) should be covered as alternative flows.

*** Use Cases as Test Cases
    As a developer, you may use this use case straight off as a test case for the system. Find Bob, put him in front of the ice cream truck, and tell him to order an ice cream. If you are able to execute the use case as specified, you have a passing test case. You are of course not done with your tests here, since the use case is not complete. If you think about it, you may select different flavours of ice cream, you may ask for one or several scoops of ice cream, you can ask for a cone or a cup, you can pay with cash or card, and so on. All of these choices ought to be covered in the use case and the corresponding test cases. You may also pay up-front or after delivery, but this may be better represented as two separate use cases.
*** Use Cases and Business Requirements
    Take the use case above. Now quickly tell me which business requirements that are involved.

    Do the reverse. Take a requirement. Quickly tell me which use cases this requirement is realised in.

    You can't, can you? This is one of the downsides of use cases if we "do things by the book". All is not lost, however. It is relatively easy to augment the use case format to cover for these two situations.

    The quickest is to add one attribute "Dependencies" (or "Relevant Requirements", or whatever you wish to name it) and simply list all requirements that you are using in the use case. The downside to this approach is that you do not know /how/ the requirements are involved. Let's say that you have a requirement that /"As a customer I want to know if there are any nuts in the ice cream because I am allergic to hazelnuts"/. When should this requirement be used? When the system informs about the available choices? When the kid orders the ice cream? When the kid has already payed?

    Another option is to add a column to the main course of events instead:

#+CAPTION: Adding Business Requirements to a Use Case's Main Course of Events
#+NAME: tab:UC-BR
         | Actor                                                | System                                                           | Business Requirements                                                                                                              |
         |------------------------------------------------------+------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------|
         | 1. A kid arrives at the ice cream truck              |                                                                  |                                                                                                                                    |
         |                                                      | 2. The system informs about available choices                    | BR1: "As a customer I want to know what choices are available because I don't like vanilla"                                        |
         |                                                      |                                                                  | BR2: "As a customer I want to know if there are any nuts in the ice cream because I am allergic to hazelnuts"                      |
         |                                                      |                                                                  | Note: Also list lactose, gluten etc.                                                                                               |
         | 3. The kid orders an ice cream                       |                                                                  | BR3: "As a customer I want to order a particular flavour of ice cream so that I can get the ice cream I like."                     |
         |                                                      | 4. The system prepares the ice cream and informs about the price | BR4: "As an ice cream man I want to get payed before I deliver the ice cream to avoid them pesky kids running away without paying" |
         | 5. The ice cream man delivers the ice cream.         |                                                                  |                                                                                                                                    |
         | 6. The kid pays.                                     |                                                                  |                                                                                                                                    |
         | 7. The ice cream man enters the pay into the system. |                                                                  |                                                                                                                                    |
         |                                                      | 8. The system gives change on the paid amount.                   |                                                                                                                                    |

    Of course, this is more difficult to index (but only slightly and it is easily programmed). You also need not write the entire requirement in the Business Requirements column -- just the requirement's ID. You may think that for a larger system, this kind of cross-referencing may become difficult because you need to have a pretty firm grasp of the entire requirement's database in order to be able to identify the relevant requirements. However, you would then be assuming (a) that all requirements engineering is done before analysis/design in a waterfall methodology, (b) that you could write the use case without this awareness, and (c) that you cannot add requirements to the use case later and alter the main course of events accordingly. Neither of these are true.

    You may wonder why you /should/ link use cases and requirements at all? Simply because you are /not/ following a strict waterfall development methodology in a one-off development. When a requirement changes you want to be able to quickly find out where you have designed and implemented the requirement, and when you are implementing the use case you may have more questions, or you may have different idea of how to solve the problem, and then you need to check what was actually stated in the requirement (and who stated it so you can talk to them about it).
*** Use Cases and Quality Attributes
    Another issue that is not included in the default use cases are /quality attributes/. I suppose you /could/ add it in the regular use case, so that every system response has a subordinate clause specifying the quality constraints. But why not re-use the idea suggested above. Quality requirements are -- once specified -- just ordinary requirements, so you can add them in the "Business Requirements" column for every system response. This makes it easy to add several quality constraints on each system response. Even better, you do not need to have the same quality constraints on the entire use case. For example, presenting the list of ice cream flavours MUST be done within two seconds, but accepting a credit card payment MAY take up to five seconds.
*** Use Case Diagrams
    Roughly (and don't hold me to this, because there are many situations where this is not true) there will be one use case per feature in the system, for a loose definition of feature. (There, did I weasel out that sentence sufficiently to not say anything meaningful?)
    
    This means that there may be quite a lot of use cases, and it may become difficult to get an overview of them if all you have are their textual form. /Use Case Diagrams/ are the UML answer, with the intention of visually clearing up:

- What the /boundaries/ are of the system(s) (to which system does which use case belong)
- What /actors/ are involved for each system and in each use case
- What /use cases/ there are in each system
- What /relationships/ there are between use cases, between use cases and actors, and betwen systems.
*** Use Case Reuse
    When doing larger use cases, you may encounter smaller pieces of processes that are needed by the big use case but are not really dealing with the same problem. For example, what does money and payment have to do with ordering ice-cream (my kids struggle with this one too). There may be alternative ways of doing something, where each way in turn has a number of sub-steps. In order to keep the main use case clean and focused on one problem, and in order to create reusable bits of processes, you can break out behaviour from the main use case into sub-use-cases.

#+BEGIN_SRC plantuml :file ./images/FStructuringUC1.png
scale 400 width
left to right direction

rectangle POS {
(BuyItems)
(CreditPayment)
(CashPayment)
(CheckPayment)
(CreditPayment) .> (BuyItems) : include
(CashPayment) .> (BuyItems) : include
(CheckPayment) .> (BuyItems) : include

}

Cashier -> (BuyItems)
Customer -> (BuyItems)

:Credit Authorisation Service: as CAS

CAS -> (CreditPayment)
#+END_SRC

#+CAPTION: Example of a Use Case Diagram where the BuyItems use case includes CashPayment, CheckPayment, and CreditPayment.
#+NAME: fig:UCInclude
#+RESULTS:
[[file:./images/FStructuringUC1.png]]
*** Use Case Prioritisation
    Prioritising use cases is at first no different than prioritising requirements or user stories, the difference is that it is the first UML artefact available for you to prioritise. The ground rule is:

#+BEGIN_info
    First implement use cases that /significantly influence/ the core system architecture.
#+END_info
    
   This is pretty much the same advice as you would get in Agile development methodologies, with their focus on a Minimum Viable Product (MVP). The question is, of course, what does "significantly influence" mean? Larman suggests a few guidelines for what may increase the ranking of a use case:

#+BEGIN_info
   Increase the ranking of a use case if it
   - has direct impact on architectural design
     - example: adds classes to domain layer, require persistent services
   - includes risky, time-critical, complex functions
   - involves new research or technology
   - represents primary business processes
   - directly supports revenue or decreased costs
#+END_info

   Also remember that you need not implement a use case completely in one iteration. The Minimum Viable Product in the ice cream example is, for example, to get a selection of ice creams and order one. Payment (and authentication etc. etc.) is not part of the MVP, so you can wait with this until a later iteration. If you look at the involved business requirements, this may make more sense to you.

*** Story Points
    I think it is time I introduce another agile concept, namely that of /Story Points/. You will need this because once you have ranked your use cases, user stories, or requirements, you need a way to determine how much you should commit to in the sprint you are planning for.

    Decide on a unit. This may be "hours to develop", "[[http://spacequest.wikia.com/wiki/Buckazoid][Buckazoids]]", "[[https://en.wikipedia.org/wiki/Spanish_dollar][pieces of eight]]", or just plain and simple "Story points". Take the first item to estimate from your backlog and agree how many story points it is worth. With this as a base, you then have a relative point that you can assess the remainder of your items against ("Is it more or less than item #1? How much more? Twice? Thrice?"). A common advice is to use a series of possible values for how many story points an item may get. Commonly suggested is to use the fibonacci sequence (1, 2, 3, 5, 8, 13, 21, 34, 45) since it climbs quickly.

    /You will never use the story points outside your team/, so it does not matter that they are not absolute. Inside your team, you will use them to measure /velocity/, i.e. "how many story points do you complete per week". First, you now have a nice measure of whether everything is ok in your team and in your product, if you are completing as many story points per week as you usually do (your average velocity). Second, you have a means with which to plan your iterations. If you know that your average velocity is =X= per week with a confidence interval of =+/- 10%= and your sprint is planned to last for =Y= weeks, then you know you will /at least/ be able to commit to =0.9X * Y= story points in your sprint. Your manager will probably not be happy about this because they expect more from you. So you get closer to the upper bound =1.1X * Y= instead, and this makes the manager unhappy when you fail to meet your goal. I can't teach you how best to placate your manager, but this will at least give you an idea of which ballpark you have to play in.

    Of course, when you split up a UML use case into parts that can be implemented in separate iterations, you need to estimate the story points for each part. Good luck!
** Learning Material
*** Book Chapters
    - {{{larman}}}: Chapters 4, 5, 6, 7, 21, 30
      4. [@4] Inception is Not the Requirements Phase	 
      5. Evolutionary Requirements
      6. Use Cases
      7. Other Requirements
      21. [@21] Test Driven Development and Refactoring
      30. [@30] Relating Use Cases
*** Screencasts
  - [[https://play.bth.se/media/Use+Cases/1_d4tqygel/41750261][Use Cases]]
  - [[https://play.bth.se/media/Structuring+Use+Cases/1_seaeffad][Structuring Use Cases]]
*** TODO Lectures						   :noexport:
*** Further Reading
    - [[https://agilefaq.wordpress.com/2007/11/13/what-is-a-story-point/][What is a Story Point?]]
    - [[https://www.mountaingoatsoftware.com/blog/what-are-story-points][What are Story Points (M. Cohn)]]
    - [[https://www.mountaingoatsoftware.com/blog/story-points-are-still-about-effort][Story Points are Still about Effort (M. Cohn)]]
    - [[https://www.mountaingoatsoftware.com/blog/the-main-benefit-of-story-points][The Main Benefit of Story Points (M. Cohn)]]
** Experiential Learning
*** Sprint Test Plan
    Go through the user stories for this sprint and make sure you have a clear understanding of how to solve each of them.

    Revisit and update your risks and contingencies section.

    Add and/or revise the following items to your glossary:
    - Use Case
    - Use Case Diagram
    - Sub Use Case
    - Test Case
    - Quality Attribute
      - Quality Aspect
      - Quality Requirement
      - Quality Constraint
    - Minimum Viable Product (MVP) [fn::This term may be new to some of you but not all, because you may be following a different path through the sprints. You can expect more of these terms that some of you already know about.]
    - Story Points
    - Velocity

    Make sure you understand what each item is, the notation for them, and how to use them either in isolation or together with the other concepts.    
*** Self-Study: Use Cases
    Take a system that you are familiar with. List the use cases in this system in a Use Case Diagram, along with the actors involved. Pick a couple of use cases that requires you to interact with the system in several steps and complete the use cases with a "main course of events". Think about alternative flows and add them too.

    Remember that all actors are not visible. For example, in a messaging application you would have both sender, recipient, and possibly forwarding agent as actors.
*** Self-Study: Planning
    Gather your team. Decide on a system that you want to plan (for example, the system that you just listed the use cases for), and engage in a game of [[https://www.crisp.se/bocker-och-produkter/planning-poker][Planning Poker]] to estimate the sizes of all the use cases.

    Give your use cases a rough priority, e.g. using the [[https://en.wikipedia.org/wiki/MoSCoW_method][MOSCoW method]], and see if you can divide your thusly created backlog into reasonably sized sprints.
*** Assignment Submission: Use Case Overview
    *{{{pa1415}}}*: In this part of the assignment you will continue with the requirements document that you have already created and transform your user stories into UML use cases.

    *{{{pa1435}}}*: In this part of the assignment you will write UML use cases based on the system description for the assignments.

    *Tasks:*
    1. Create a /Use Case Diagram/
       - Identify all /actors/ that are interacting with the system.
       - Identify all /use cases/ of the system (features).
       - Identify which actors are involved in each use case.
       - Identify any other relations between the use cases.
    2. Briefly describe the actors in a dictionary.
    3. Describe the use cases in a high-level description, containing:
       - Use Case Name
       - Primary Actor
       - Brief Description
    4. For students of *{{{pa1415}}}*, link your user stories to the relevant use cases by adding an attribute:
       - Concerned User Stories
	 
#+BEGIN_info
*Document Structure:*

1. Title Page
   1. Title: "Overview of Use Cases for System: <system name>"
   2. Sub-title: "Assignment in the course <course code><course name>"
   3. Date
   4. Authors and Author Contribution

      Add a table with all authors, their social security numbers, and the share in percent that the author has contributed in thinking (discussing, reasoning, etc.) and in actually writing the submitted assignment document.

      | Author Name | Social Security Number | Thinking | Writing |
      |-------------+------------------------+----------+---------|
      |             |                        |          |         |
2. System Description

   A brief description (2-3 paragraphs) of your interpretation of what the goal of the system is.

3. Use Case Diagram
4. Description of Actors
5. High-Level Use Cases
6. References
#+END_info

{{{commit}}}

#+BEGIN_tip
*Conditions of Satisfaction*

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. Size of assignment: Are there 15-25 high-level use cases?
2. Are all relevant actors identified and described?
3. Are all relevant use cases identified and briefly described?
4. For each use case, are all the relevant actors linked?
5. Is the use case diagram well formed?
6. Do all the use cases have all attributes?
7. Do all the use cases have unique and good names?
8. Do all the use cases have a sufficient and proper description?
9. (*PA1415*) Are the use cases linked to the relevant user stories?
10. (*PA1415*) Are all user stories linked in at least one use case?
#+END_tip
*** Assignment Submission: Implementation Plan
    In this part of the assignment you will prioritise your use cases and plan your first sprints.

    *Tasks:*
    1. Order your UML use cases (created above) according to their importance.

       *{{{pa1415}}}* Make sure this order corresponds to the prioritised list of user stories that you have created earlier. You do not have to strictly adhere to the priorities of the user stories, but you need to document and motivate any major deviations that you do.

    2. Motivate your ordering in terms of how this allows you to build a minimum viable product first.
    3. Assign story points to each use case.
    4. Decide and motivate how many story points you will have time for in this course (=your first iteration) and per iteration. Set a MAX, a MIN, and an AVERAGE value per iteration.
    5. Assign your use cases to iterations such that you
       1. Create a minimum viable product in your first iteration (motivate why which this is the case).
       2. Have a reasonable amount of story points allocated per iteration, in relation to the MAX, MIN, and AVERAGE values defined.

#+BEGIN_info
    *Document Structure:*

1. Title Page
   1. Title: "Implementation Plan for System: <system name>"
   2. Sub-title: "Assignment in the course <course code><course name>"
   3. Date
   4. Authors and Author Contribution

      Add a table with all authors, their social security numbers, and the share in percent that the author has contributed in thinking (discussing, reasoning, etc.) and in actually writing the submitted assignment document.

      | Author Name | Social Security Number | Thinking | Writing |
      |-------------+------------------------+----------+---------|
      |             |                        |          |         |
2. System Description

   A brief description (2-3 paragraphs) of your interpretation of what the goal of the system is.

3. Prioritised List of Use Cases
   1. Motivation for Priorities
   2. Use Cases
      
      Include: use case name and size in story points. Present the list ordered according to priority (most important first).
4. Estimated Velocity Per Iteration

   Here you list your MAX, MIN, and AVERAGE number of story points that you think you will have time for per iteration. Pay special attention to the first iteration since this is the one you will continue with in the rest of the course.

5. Implementation Plan
   1. Motivation for Implementation Plan
   2. Iterations and Use Cases
#+END_info

{{{commit}}}

#+BEGIN_tip
*Conditions of Satisfaction*

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. Size of assignment: Does the first iteration contain 5-10 use cases?
2. Size of (future) assignments: Does the suggested iteration velocity in relation to the size in story points per use case represent a reasonable development speed?
3. Is the relative size in story points reasonable for each use case?
4. Does the first iteration contain a workable and acceptable Minimum Viable Product?
5. Is there a reasonable amount of work (in terms of story points) assigned to each iteration.
6. (*PA1415*) Does the order of implementation of the use cases correspond to the priorities of the involved user stories?
#+END_tip

*** Assignment Submission: Detailed Use Cases for First Iteration
And, finally, you detail the use cases that you are focusing on in the first iteration.

*Tasks:*
1. Extend the use case descriptions for the use cases in your first iteration in your Implementation Plan so that they also contain the following attributes:
   - Preconditions
   - Main Course of Events (or Main Success Scenario)
   - Alternative Flow of Events (or Extensions)
   - Special Requirements

#+BEGIN_info
    *Document Structure:*

1. Title Page
   1. Title: "Detailed Use Cases for Iteration 1 of System: <system name>"
   2. Sub-title: "Assignment in the course <course code><course name>"
   3. Date
   4. Authors and Author Contribution

      Add a table with all authors, their social security numbers, and the share in percent that the author has contributed in thinking (discussing, reasoning, etc.) and in actually writing the submitted assignment document.

      | Author Name | Social Security Number | Thinking | Writing |
      |-------------+------------------------+----------+---------|
      |             |                        |          |         |
2. System Description

   A brief description (2-3 paragraphs) of your interpretation of what the goal of the system is.

3. Detailed Use Cases
   
   List your detailed use cases here.
#+END_info

{{{commit}}}


#+BEGIN_tip
*Conditions of Satisfaction*

When marking this part of the assignment we are looking for the following:

0. [@0] Does the title page contain a table with authors and author contribution
1. Size of assignment: Are all use cases in the first iteration from the Implementation Plan described?
2. Are the preconditions relevant?
3. Is it a reasonable main course of events?
4. Does the main course of events end successfully?
5. Does the alternative flow of events cover the obvious ways in which the use case can fail or take an alternate route?
#+END_tip

*** Assignment Submission

    {{{submit}}}
    
    Your submission shall include the following documents:
    - (*PA1415*) User Stories
    - Overview of Use Cases
    - Implementation Plan
    - Detailed Use Cases for First Iteration
*** Update Course Backlog    
    How do you design a system from your use cases? What should you look for when you are trying to understand the structure of your system? What about the behaviour of the system?

    Are there any other questions that you want answered? Add them, along with a brief strategy for how to find an answer.
** Sprint Acceptance Tests
   You are done with this sprint when:
   - You have created an "Overview of Use Cases" document
   - You have created an "Implementation Plan" document
   - You have created a "Detailed Use Cases for First Iteration" document
   - You have committed/pushed these documents to your project repository
   - [[./org/checked.png]] You have submitted the documents for marking.
   - [[./org/checked.png]] *PA1415* You have also included the "User Stories" document in your submission.

   You may also have
   - Updated your Sprint Test Plan
   - Updated your Course Backlog
   - Written self-study Use Cases
   - As self-study played planning poker.
* Sprint: Concepts and Events					   :noexport:
** notes							   :noexport:
   - System Events
   - Test Document (II)
   - Domain Model   
* Sprint: Test Document						   :noexport:
* Sprint: Classes						   :noexport:
** notes							   :noexport:
   - Class Diagram
   - Packages
   - Architectures (Layered, MVC)
   - GRASP?
* Sprint: Interaction						   :noexport:
** notes							   :noexport:
   - Objects
   - Sequence Diagrams
   - Collaboration Diagrams
   - Contracts?
   - Feeding into Class Diagrams
   - GRASP?
* Sprint: Good Interactions					   :noexport:
** notes							   :noexport:
   - GRASP
* Sprint: Design Patterns					   :noexport:
** notes							   :noexport:





* Working Material						   :noexport:
** Don't Forget
   - [X] Use Cases: connect back to requirements (annotate Main Course of Events with links to Business Requirements).
   - [X] Requirements Engineering: Three parallel and different ways of writing requirments: Old (Reqs), Agile (User stories), UML (Use Cases): Add a picture of this...
   - [ ] GRASP: Responsibility-driven design

   | PA1415            | PA1435              |
   |-------------------+---------------------|
   | Exam, 3hp         | Exam, 2hp           |
   | Assignment, 4.5hp |                     |
   |                   | Assignment 1, 1.5hp |
   |                   | Assignment 2, 0.5hp |
   |                   | Assignment 3, 2hp   |
   |                   |                     |
   | SUM: 7.5hp        | SUM: 6hp            |
   |-------------------+---------------------|

   Assignments!
   - How many
   - Flow
   - Topic
** TODO System Descriptions for Assignments
** TODO Add "Select System for Assignments" in Sprint 0
** TODO Tie in Lectures into Sprints, with preparations I want them to do first
** TODO Sprint 99: Wrap-up
** Chapters Used
   | Chapter | Sprint |
   |---------+--------|
   |       1 | 1      |
   |       2 | 1      |
   |       3 | 1      |
   |       4 | 2,3    |
   |       5 | 2,3    |
   |       6 | 2,3    |
   |       7 | 2,3    |
   |       8 |        |
   |       9 |        |
   |      10 |        |
   |      11 |        |
   |      12 |        |
   |      13 |        |
   |      14 |        |
   |      15 |        |
   |      16 |        |
   |      17 |        |
   |      18 |        |
   |      19 |        |
   |      20 |        |
   |      21 | 1,3    |
   |      22 |        |
   |      23 |        |
   |      24 |        |
   |      25 |        |
   |      26 |        |
   |      27 |        |
   |      28 |        |
   |      29 |        |
   |      30 | 3      |
   |      31 |        |
   |      32 |        |
   |      33 |        |
   |      34 |        |
   |      35 |        |
   |      36 |        |
   |      37 |        |
   |      38 |        |
   |      39 |        |
   |      40 | 1      |
** Backlog
 | Sprint                    | Topic     | Contents                                  | User Story                                                                                                                                                                                     |   |
 |---------------------------+-----------+-------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---|
 | Intro                     | Intro     | Student                                   | As a student I want to pass this course.                                                                                                                                                       |   |
 |                           | Intro     | Student                                   | As a student I want to understand how this course is structured so that I can quickly find the information I need to learn the subject.                                                        |   |
 |                           | Intro     | Student                                   | As a student I want to know why this topic is important so that I can be properly motivated.                                                                                                   |   |
 | Development Methodologies | DevMeth   | UML                                       | As a software designer I want to document my design in a standardised format so that I can communicate it to other software engineers.                                                         |   |
 |                           | DevMeth   | Development Methodologies, GANTT          | As a project manager I want to plan the project so that I can make the best use of my resources.                                                                                               |   |
 |                           | DevMeth   | WBS                                       | As a project manager I want to track the project so that I can see what the current status is.                                                                                                 |   |
 |                           | DevMeth   | Project Estimations                       | As a project manager I want to track the project so that I can forecast whether we will deliver on time or not.                                                                                |   |
 | Requirements Engineering  | RE        | Requirements                              | As a software engineer I want to get an overview of all sources of requirments that may influence which system I build.                                                                        |   |
 |                           | RE        | Requirements                              | - As a requirements engineer I want to know who may have requirements on the system we are building so that I can make sure that all needs are met.                                            |   |
 |                           | RE        | Requirements                              | As a software engineer I want to be able to extract all requirements on the system I build so that I know that I am not missing anything important.                                            |   |
 |                           | RE        | Requirements                              | - As a requirements engineer I want to have a range of methods for finding requirements so that I can choose the best method for each customer.                                                |   |
 |                           | RE        | Backlog, Iterations, Prioritization       | As a project manager I need to decide what to focus on building right now so that I best satisfy all customers' expectations.                                                                  |   |
 | Object Oriented Analysis  | OOA       | Use Cases                                 | As a software designer I want to document what the customer is telling me so that I can discuss my understanding of their requirements with them.                                              |   |
 |                           | OOA       | Use Cases                                 | As a software designer I want to document what the customer is telling me so that I can easily continue designing based on a joint understanding.                                              |   |
 |                           | OOA       | Conceptual Model                          | As a software designer I want to document my understanding of the problem domain so that I can easily transform this into an object oriented software system.                                  |   |
 |                           | OOA       | System Sequence Diagram                   | As a software designer I want to understand how users plan on interacting with the system so that I can design the right API endpoints.                                                        |   |
 |                           | OOA       | State Diagrams                            | As a software designer I want to document the states the application can be in so that I can better design them and get an overview of permissible transitions.                                |   |
 |                           | OOA       | Use Cases - Structuring                   | As a software designer I want to be able to reuse common procedures between my use cases so that I only have to maintain them in one place.                                                    |   |
 | Object Oriented Design    | OOD       | Sequence/Collaboration Diagrams           | As a software designer I want to understand how domain concepts interact so that I can select the best way to implement these interactions.                                                    |   |
 |                           | OOA       | Dynamic vs Static                         | As a software designer I want to model both the /dynamic behaviour/ as well as the /static structure/ of the application so that I can communicate both to the developers.                     |   |
 |                           | OOD       | Class Diagrams (also Transition into)     | As a software implementer I want to know which methods and attributes each class contains so that I can implement them.                                                                        |   |
 |                           | OOD       | Package Diagrams / Architecture           | As a software designer I want to be able to divide my design into manageable chunks so that I can get a better overview.                                                                       |   |
 |                           | OOD       | GRASP Patterns                            | As a software designer I want to create a design that adheres to basic design principles so that I am sure that it will "hold" when I add more functionality and start maintaining the system. |   |
 | Design Patterns           | OOD/DP    | Design Patterns                           | As a software desginer I want to be able to use appropriate design patterns where applicable so that I do not have to reinvent the wheel for every problem.                                    |   |
 | Testing                   | Testing   | Testing, Testing Methodologies, Test Plan | As a product manager I want to make sure that we are building software of high quality.                                                                                                        |   |
 |                           | Testing   | Regression Testing, TDD                   | As a product manager I want to make sure that fixed bugs do not re-appear so that I can build the product incrementally.                                                                       |   |
 | Implementation            | Impl      | From Design to Code                       | As a software designer I want to understand how my design will be implemented so that I can facilitate the transition into code.                                                               |   |
 | Extra: Security           | OOD/DP/SE | Security Design Patterns                  | As a security engineer I want to use "secure" design patterns so that I can make sure that the product is secure by design.                                                                    |   |
 | Extra: Games              | OOD/DP/GE | Games Design Patterns                     | As a games developer I want to use commonly accepted game design solutions so that I can be reasonably sure it works within my quality constraints.                                            |   |
 | Extra: Web                | OOD/DP/WE | Web Engineering Patterns                  | As a web developer I want to be able to use design patterns especially suitable for web engineering so that I make the best use of my platform                                                 |   |
 | Extra: More Analysis Help | OOA       | Contracts                                 | As a software designer I want to have a way of thinking about what happens in a system event so that I do not miss any important effects on the system state.                                  |   |
** Goals
  | Course Code   | Course Goal                                                                                                                        |
  |---------------+------------------------------------------------------------------------------------------------------------------------------------|
  | PA1415        | - på en grundläggande nivå i grupp kunna ta fram krav på en programvara och uttrycka dem i en kravspecifikation                    |
  | PA1415        | - i grupp producera en översiktlig utvecklingsprojektplan baserat på en kravspecifikation                                          |
  | PA1415/PA1435 | - i grupp kunna skapa en detaljerad objektorienterad design för ett mjukvaruprogram                                                |
  | PA1415        | - i grupp kunna implementera ett mjukvaruprogram inom rimlig tid, baserat på en kravspecifikation och en objektorienterad design   |
  | PA1415        | - på en grundläggande nivå i grupp kunna planera och genomföra testning av producerad programvara, baserat på en kravspecifikation |
  | PA1415/PA1435 | - skapa och analysera objektorienterade artefakter uttryckta i UML                                                                 |
  | PA1415/PA1435 | - kunna motivera och använda designmönster i utvecklingen av mjukvarusystem                                                        |
  |               |                                                                                                                                    |
  | PA1435        | *Kunskap och förståelse* Efter genomförd kurs ska studenten:                                                                       |
  | PA1435        | - kunna visa förståelse för grundläggande principer i objektorienterad programvaruutveckling.                                      |
  | PA1435        | - kunna visa förståelse för UML som modelleringsspråk.                                                                             |
  | PA1435        | - kunna visa kunskap om grundläggande designprinciper.                                                                             |
  | PA1435        | - kunna visa kunskap om grundläggande designmönster.                                                                               |
  |               |                                                                                                                                    |
  | PA1435        | *Färdigheter och förmåga* Efter genomförd kurs ska studenten:                                                                      |
  | PA1435        | - kunna uttrycka strukturen och beteendet hos ett system i termer av objektorienterade koncept.                                    |
  | PA1435        | - kunna korrekt använda UML för att uttrycka struktur och beteende hos ett system.                                                 |
  | PA1435        | - kunna korrekt transformera en objektorienterad design till källkod.                                                              |
  | PA1435        | - kunna tillämpa designprinciper och designmönster i allmänhet och inom en särskild domän.                                         |
  |               |                                                                                                                                    |
  | PA1435        | *Värderingsförmåga och förhållningssätt* Efter genomförd kurs ska studenten:                                                       |
  | PA1435        | - kunna analysera källkod för eventuella förbättringar.                                                                            |
  | PA1435        | - kunna analysera och kritiskt diskutera en design för eventuella förbättringar.                                                   |
  |---------------+------------------------------------------------------------------------------------------------------------------------------------|

** Topics
  | PA1415 | PA1435 | Topic                                            |
  |--------+--------+--------------------------------------------------|
  | PA1415 |        | Development Methodologies (Waterfall/Agile/Lean) |
  | PA1415 |        | Requirements Engineering                         |
  | PA1415 |        | Project Planning                                 |
  | PA1415 |        | Work Breakdown Structures                        |
  | PA1415 |        | Project Estimations                              |
  | PA1415 |        | Testing, Different Levels                        |
  | PA1415 |        | Test Driven Development                          |
  | PA1415 |        | Test Plan                                        |
  |        | PA1435 | Basic Design Methodology (OOA, OOD)              |
  | PA1415 | PA1435 | UML - overview                                   |
  | PA1415 | PA1435 | UML Analysis                                     |
  | PA1415 | PA1435 | UML Design                                       |
  | PA1415 | PA1435 | Basic Design Patterns (GRASP)                    |
  | PA1415 | PA1435 | Design Patterns (GoF)                            |
  | PA1415 | PA1435 | From Design to Code                              |
  | PA1415 | PA1435 | Good vs Bad Design                               |
  |--------+--------+--------------------------------------------------|

** Sprints						       :OLD:noexport:
   0. [@0] Introduction/Formalia
   1. Overview of Development Methodologies
      - Waterfall
      - Agile/Lean
      - RUP
   2. Requirements Engineering
      - Requirement Elicitation
      - Requirements, User Stories, Use Cases
      - Backlog
      - Working with requirements in a Sprint
      - Requirements and Testing
   3. Planning and Estimations
      - Requirements and Prioritisations
      - Requirements for Planning
      - WBS
      - Estimations
      - Project Tracking
   4. Testing
      - Levels of Testing
      - TDD
      - Test plan
   5. Introduction to RUP/UML
      - OOA
      - OOD
      - RUP
      - UML Diagrams
      - UML Dictionary
   6. OO Analysis
      - Use Case Diagrams
      - Use Cases
      - System Sequence Diagrams
      - Conceptual Model
      - State Diagrams
      - Worked Example from Use Case to SSD and Conceptual Model
   7. OO Design
      - Interaction Diagrams
	- Sequence Diagrams
	- Collaboration Diagrams
      - Class Diagrams
   8. Basic Design Patterns
      - GRASP
   9. Common Design Patterns
   10. From Design to Code
       - Java / C++ Quirks
       - OOP in JavaScript
** Lecture Outline					       :OLD:noexport:
*** DONE Introduction (01)
    CLOSED: [2016-03-09 Wed 11:44]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-09 Wed 11:44]
    :END:      
    Classroom only

    - Course Intro
      - About MSV
      - Course Structure
      - Lecture Structure
      - Literature
      - Tools
    - Modelling why care
      - Gorschek paper
      - Sell it anyway
    - Overall OOD Development Methodology
      - Reason: Traceability
      - Reason for all the models: Analysis triangulation
    - Modelling at large
    - OO Analysis
    - OO Design
    - UML
      - Sell UML (Abstract, Precise, Pictoral)
      - UML as a collection of models
      - UML as a methodology
      - UML wankery
    - Design / Design Patterns
    - Exercise in Scale??
*** DONE Development Process (02)
    CLOSED: [2016-03-09 Wed 14:35]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-09 Wed 14:35]
    :END:      
    Upload: Methodologies
    - Waterfall
    - Iterative/Incremental
    - Kanban
    - SCRUM

    Classroom:
    - Process
      - Systematic
      - Disciplined
      - Quantifiable (!)
    - Process vs Project vs Product
    - Discuss:
      - What's good with waterfall?
      - Where would you do design in Scrum?
      - Where would you do design in Kanban?
    - Example: UML Process (Work through an example)
      - Use Case Diagrams
      - Use Cases
      - Conceptual Model
      - Class Diagram
      - Collaboration Diagram
      - Interaction Diagram
      - ?? Flowcharts 
*** DONE Requirements (03)
    CLOSED: [2016-03-17 Thu 09:59]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-17 Thu 09:59]
    :END:      
    Upload: Requirements Specifications
    - ISO 830
    - RFC 2119
    - Standard Templates for Requirements "The system must do X"
    - Standard Template for User Stories
    - Use Cases
      - Use Case Diagrams
      - High Level Use Case
      - Fully Dressed (Expanded) Use Case
    - Prioritising Requirements

    Classroom:	
    - Discuss:
      - How to Find Requirements
      - Goals, Features, Functions, Components (RAM Model)
      - Good and Bad Requirements
      - Black box vs White Box
    - Basic RE process
      - (Re-use old slides)
    - Example
      - Use Case Diagram
      - High Level Use Case
      - Fully Dressed Use Case
*** DONE Modelling Structure (04)
    CLOSED: [2016-03-22 Tue 11:15]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-03-22 Tue 11:15]
    :END:      
    Upload:
    - Conceptual Model Notation
      - Concept
      - Attributes
      - Associations
      - Multiplicity
      - Data Dictionary (Definition/Intention/_Glossary_)
      - Examples (Instantiated Objects)
    - Class Diagrams
      - Concept vs Class
      - Associations
      - Roles
      - Role Multiplicity
      - Attributes
      - Attribtue Types

    Classroom:
    - Discuss:
      - How to find Concepts/Attributes/Associations?
      - Difference between Attribute and Concept?
      - Multiplicity -- how to think?
    - Slides on Concept Identification
    - How to find Attributes
    - How to find Associations
    - Example:
      - Conceptual Model
      - Class Diagram
*** DONE Modelling Structure II (04)
    CLOSED: [2016-04-13 Wed 11:00]
    :LOGBOOK:  
    - State "DONE"       from "WAIT"       [2016-04-13 Wed 11:00]
    - State "WAIT"       from ""           [2016-04-13 Wed 11:00]
    - State "WAIT"       from ""           [2016-03-22 Tue 14:34]
    :END:      
    - [X] Structuring Use Cases (From Modelling Behaviour Lecture)
*** DONE Modelling Behaviour (05)
    CLOSED: [2016-04-06 Wed 14:28]
    :LOGBOOK:  
    - State "DONE"       from "TODO"       [2016-04-06 Wed 14:28]
    :END:      
    Upload:
    - Sequence Diagram
      - Actor
      - Lifeline
      - Event
    - Contract
      - Name
      - Responsibilities
      - Preconditions
      - Postconditions
    - Extended Contract
      - Name
      - Responsibilities
      - Type
      - Cross-References
      - Notes
      - Exceptions
      - Output
      - Preconditions
      - Postconditions
    - State Diagrams
      - State / Event / Transition
      - Notation
	- Nested States
	- Activity in a State
	- Actions on Transitions

    Classroom:
    - Going from Use Case to Sequence Diagram
    - System Sequence Diagram vs regular Sequence Diagram
    - System as a modelling concept
    - Contracts
      - What are they?
      - How should you interpret preconditions?
      - How to interpret postconditions?
      - Stage-and-Curtain execution
    - Discuss:
      - What are extended contracts good for?
    - State Diagrams
      - Examples + Discussion: Common Pitfalls
      - What types of Events can there be in a state diagram?
    - Discuss:
      - How do we fit state diagrams into the UML process?
*** TODO Design -- Collaboration and Responsibilities
    Upload:      
    - [ ] Interaction Diagrams, Collaboration Diagrams
      - Classes and Instances
      - Sequence Numbering
      - ...
    - [ ] Conditions, etc.
    - [ ] Real Use Cases

    Classroom:
    - [-] Discuss
      - What is the difference between Sequence diagrams and Collaboration Diagrams
    - [-] Example:
      - Go from Class Diagram to Sequence Diagram
*** DONE Design Patterns I/II (06) (08, 09)
    CLOSED: [2016-04-21 Thu 14:25]
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2016-04-21 Thu 14:25]
    :END:
    Upload:
    - GRASP Patterns
      - Expert
      - Creator
      - Low Coupling
      - High Cohesion
	- Don't talk to strangers
      - Controller
      - Polymorphism
    - Design Patterns
      - Observer
      - Singleton
      - Strategy
      - State
      - Abstract Factory
    - Architecture
      - Layered
      - MVC

    Classroom:
    - Design Patterns Background
    - Levels of Patterns
      - Architecture
      - Design
      - Idioms
      - GRASP
    - Discuss:
      - Design Patterns:
	- Domain Modelling or Development tricks
	- What are they good for?
	- Limitations?
    - Example:
      - How to apply GRASP
      - How to apply DP
      - How to apply AP
    - Example:
      - How to Implement DP's
*** TODO Mapping Design to Code (07)
    Classroom:
    - Implementation Order
    - Class Creation
      - (Why bother, it's done by the tool anyway)
      - Attributes, Methods, etc.
    - Code from Sequence Diagrams
      - This is not automatic, because crappy tools.
    - Language Differences
      - Multiple Inheritance vs Inner Classes vs Anonymous Classes
      - Pointers vs References
      - Aggregation vs Strong Aggregation
      - Callback Programming (Event-Driven Arch.) (Node.js and its ilks)
	- https://blog.risingstack.com/fundamental-node-js-design-patterns/
      - Stateful EDA's??
      - Dependency Injection (Might hold a discussion on this one)
      - NULL as return values
      - Defensive Programming
	- http://c.learncodethehardway.org/book/ex27.html
	- Discuss: Good or Bad? Better to Fail Early?
** Links							   :noexport:
   IEEE 829-2008: http://www.fit.vutbr.cz/study/courses/ITS/public/ieee829.html
